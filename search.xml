<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二、VMware 中 Linux 网络配置及环境初始化]]></title>
    <url>%2F2019%2F09%2F25%2F%E4%BA%8C%E3%80%81VMware%20%E4%B8%AD%20Linux%20%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[[toc] 1、linux 网络连接问题弹出界面eth0：错误：激活连接失败：Device not managed by NetworkManager or unavailable 参考：https://my.oschina.net/u/2324318/blog/1814002 2、linux 配置静态ip，方便 xshell 远程2-1、修改网络配置文件https://blog.csdn.net/attend_/article/details/79025172 12345678910111213141516171819EVICE=eth0TYPE=EthernetUUID=d3349997-0d0c-48c4-be1c-189f960ebfddONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.2.129GATEWAY=192.168.2.1DNS1=222.168.160.70DNS2=114.114.114.114DEFROUTE=yesIPV4_FAILURE_FATAL=yesIPV6INIT=noNAME="System eth0"HWADDR=00:0c:29:b3:31:cdLAST_CONNECT=1556613678NETMASK=255.255.255.0USERCTL=noPEERDNS=yes 2-2、静态ip 配置好后，重启网络服务 service network restart2-3、关闭防火墙 service iptables stop2-4、编辑-虚拟网络编辑器内 NAT 设置子网ip 和网关(网关为windows ipv4 默认网关例如 192.168.2.1，子网ip 192.168.2.0 必须和网关在同一网段，2 为网段)。 2-5、虚拟机无法ping 通主机ip，但是可以ping 通网关https://blog.csdn.net/sinat_25306771/article/details/527619262-6、网络已通，ssh无法连接服务器 ？vmnet8 使用动态分配的ip 与虚拟机ip 不在同一网段导致ssh 不能连接。参考：https://www.jianshu.com/p/ee44f0cd7743 4、如何为linux 换镜像仓库，yum安装找不到镜像仓库？ 设置镜像仓库参考：https://blog.csdn.net/inslow/article/details/54177191 5、yum 安装mysql 不成功镜像仓库导致。。建议官网下载压缩包解压安装。参考：http://orchome.com/238https://blog.csdn.net/pengzhenjie36/article/details/75053059 6、RPM 包安装方式的MySQL卸载参考：https://www.jianshu.com/p/7b8c4dea6829 7、更新yum 源（使用yum 下载安装软件，yum 仓库使用源一定要配置好）参考：https://blog.csdn.net/u013850277/article/details/79240695]]></content>
      <categories>
        <category>Linux 学习</category>
      </categories>
      <tags>
        <tag>Linux 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、Linux操作手册]]></title>
    <url>%2F2019%2F09%2F25%2F%E4%B8%80%E3%80%81Linux%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[[toc] 一、Linux 简介 二、关于操作系统的选型 三、Linux-安装 Ubuntu Server 16.04 X64 四、服务器远程控制及网络配置。4-1、配置网络参考：VMware 中 Linux 网络配置及环境初始化 安装 ssh 五、目录结构说明 目录 说明 bin 存放二进制可执行文件(ls,cat,mkdir等) boot 存放用于系统引导时使用的各种文件 dev 用于存放设备文件 etc 存放系统配置文件 home 存放所有用户文件的根目录 lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt 系统管理员安装临时文件系统的安装点 opt 额外安装的可选应用程序包所放置的位置 proc 虚拟文件系统，存放当前内存的映射 root 超级用户目录 sbin 存放二进制可执行文件，只有root才能访问 tmp 用于存放各种临时文件 usr 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录 var 用于存放运行时需要改变数据的文件 六、操作文件目录命令 命令 说明 语法 参数 参数说明 ls 显示文件和目录列表 ls [-alrtAFR] [name…] -l 列出文件的详细信息 -a 列出当前目录所有文件，包含隐藏文件 mkdir 创建目录 mkdir [-p] dirName -p 父目录不存在情况下先生成父目录 cd 切换目录 cd [dirName] touch 生成一个空文件 echo 生成一个带内容文件 echo abcd &gt; 1.txt，echo 1234 &gt;&gt; 1.txt cat 显示文本文件内容 cat [-AbeEnstTuv] [–help] [–version] fileName cp 复制文件或目录 cp [options] source dest rm 删除文件 rm [options] name… -f 强制删除文件或目录 -r 同时删除该目录下的所有文件 mv 移动文件或目录 mv [options] source dest find 在文件系统中查找指定的文件 -name 文件名 grep 在指定的文本文件中查找指定的字符串 tree 用于以树状图列出目录的内容 pwd 显示当前工作目录 ln 建立软链接 more 分页显示文本文件内容 head 显示文件开头内容 tail 显示文件结尾内容 -f 跟踪输出 七、系统管理命令 命令 说明 stat 显示指定文件的相关信息,比ls命令显示内容更多 who 显示在线登录用户 hostname 显示主机名称 uname 显示系统信息 top 显示当前系统中耗费资源最多的进程 ps 显示瞬间的进程状态 du 显示指定的文件（目录）已使用的磁盘空间的总量 df 显示文件系统磁盘空间的使用情况 free 显示当前内存和交换空间的使用情况 ifconfig 显示网络接口信息 ping 测试网络的连通性 netstat 显示网络状态信息 clear 清屏 kill 杀死一个进程 八、重启与压缩命令重启命令 shutdown 命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。 命令 语法 参数 参数说明 shutdown shutdown [-t seconds] [-rkhncfF] time [message] -t seconds 设定在几秒钟之后进行关机程序 -k 并不会真的关机，只是将警告讯息传送给所有只用者 -r 关机后重新开机（重启） -h 关机后停机 -n 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机 -c 取消目前已经进行中的关机动作 -f 关机时，不做 fcsk 动作(检查 Linux 档系统) -F 关机时，强迫进行 fsck 动作 time 设定关机的时间 message 传送给所有使用者的警告讯息 解压缩命令 命令 语法 参数 参数说明 tar tar [-cxzjvf] 压缩打包文档的名称 欲打包目录 -c 建立一个归档文件的参数指令 -x 解开一个归档文件的参数指令 -z 是否需要用 gzip 压缩 -j 是否需要用 bzip2 压缩 -v 压缩的过程中显示文件 -f 使用档名，在 f 之后要立即接档名 -tf 查看归档文件里面的文件 1234567实例：1、tar 命令打包tar -cvf 打包名 欲打包目录 tar -cvf xxx.tar filename2、tar 命令解包tar -xvf xxx.tar 九、Linux 编辑器vim 运行模式编辑模式：等待编辑命令输入。插入模式：编辑模式下，输入 i 进入插入模式，插入文本信息。命令模式：在编辑模式下，输入 : 进行命令模式。 :命令q 直接退出vi:wq 保存后退出vi ，并可以新建文件:q! 强制退出:w file 将当前内容保存成某个文件:set number 在编辑文件显示行号:set nonumber 在编辑文件不显示行号 十、Linux 软件包管理10-1、使用 Root 用户 在实际生产操作中，我们基本上都是使用超级管理员账户操作 Linux 系统，也就是 Root 用户，Linux 系统默认是关闭 Root 账户的，我们需要为 Root 用户设置一个初始密码以方便我们使用。 1234567891011121314151617181、设置 Root 账户密码sudo passwd root2、切换到 Rootsu root3、设置远程允许远程登录 Rootvim /etc/ssh/sshd_config# Authentication:LoginGraceTime 120#PermitRootLogin without-password //注释此行PermitRootLogin yes //加入此行StrictModes yes重启服务service ssh restart 10-2、用户账户说明 普通用户：普通用户在系统上的任务是进行普通操作。 超级管理员：管理员在系统上的任务是对普通用户和整个系统进行管理。对系统具有绝对的控制权，能够对系统进行一切操作。用 root 表示，root 用户在系统中拥有最高权限，默认下 Ubuntu 用户的 root 用户是不能登录的。 安装时创建的系统用户：此用户创建时被添加到 admin 组中，在 Ubuntu 中，admin 组中的用户默认是可以使用 sudo 命令来执行只有管理员才能执行的命令的。如果不使用 sudo 就是一个普通用户。 10-3、组账户说明 私有组：当创建一个用户时没有指定属于哪个组，Linux 就会建立一个与用户同名的私有组，此私有组只含有该用户。标准组：当创建一个用户时可以选定一个标准组，如果一个用户同时属于多个组时，登录后所属的组为主组，其他的为附加组。 10-4、账户系统文件说明 1、/etc/passwd每一行代表一个账号，众多账号是系统正常运行所必须的，例如 bin，nobody 每行定义一个用户账户，此文件对所有用户可读。每行账户包含如下信息：root:x:0:0:root:/root:/bin/bash 用户名： 就是账号，用来对应 UID，root UID 是 0。 口令： 密码，早期 UNIX 系统密码存在此字段，由于此文件所有用户都可以读取，密码容易泄露，后来这个字段数据就存放到 /etc/shadow 中，这里只能看到 X。 用户标示号（UID）： 系统内唯一，root 用户的 UID 为 0，普通用户从 1000 开始，1-999 是系统的标准账户，500-65536 是可登陆账号。 组标示号（GID）： 与 /etc/group 相关用来规定组名和 GID 相对应。 注释： 注释账号 宿主目录（主文件夹）： 用户登录系统后所进入的目录 root 在 /root/itcast 命令解释器（shell）： 指定该用户使用的 shell ，默认的是 /bin/bash 2、/etc/shadow为了增加系统的安全性，用户口令通常用 shadow passwords 保护。只有 root 可读。每行包含如下信息：root:$6$Reu571.V$Ci/kd.OTzaSGU.TagZ5KjYx2MLzQv2IkZ24E1.yeTT3Pp4o/yniTjus/rRaJ92Z18MVy6suf1W5uxxurqssel.:17465:0:99999:7::: 账号名称： 需要和 /etc/passwd 一致。 密码： 经过加密，虽然加密，但不表示不会被破解，该文件默认权限如下： -rw——- 1 root root 1560 Oct 26 17:20 passwd- 只有root能都读写 最近修改密码日期： 从1970-1-1起，到用户最后一次更改口令的天数。 密码最小时间间隔： 从1970-1-1起，到用户可以更改口令的天数。 密码最大时间间隔： 从1970-1-1起，必须更改的口令天数。 密码到期警告时间： 在口令过期之前几天通知。 密码到期后账号宽限时间。 密码到期禁用账户时间： 在用户口令过期后到禁用账户的天数。 保留。 3、/etc/group用户组的配置文件 ：root:x:0: 用户组名称 用户组密码： 给用户组管理员使用，通常不用。 GID： 用户组的ID。 此用户支持的账号名称： 一个账号可以加入多个用户组，例如想要 itcast 加入 root 这个用户组，将该账号填入该字段即可 root❌0:root, icast 将用户进行分组是 Linux 对用户进行管理及控制访问权限的一种手段。一个中可以有多个用户，一个用户可以同时属于多个组。该文件对所有用户可读。 4、/etc/gshadow该文件用户定义用户组口令，组管理员等信息只有root用户可读。root:*:: 用户组名。 密码列。 用户组管理员的账号。 用户组所属账号。 10-5、账户管理常用命令 1、增加用户2、修改用户3、删除用户4、组账户维护5、口令维护6、用户和组状态 十一、Linux 用户和组管理十二、Linux 文件权限管理十三、Linux 安装 Java十四、Linux 安装 Tomcat十五、Linux 安装 MySQL十六、部署应用到生产环境]]></content>
      <categories>
        <category>Linux 学习</category>
      </categories>
      <tags>
        <tag>Linux 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven使用手册]]></title>
    <url>%2F2019%2F05%2F16%2FMaven%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[[toc]Maven 导言：生产环境下开发不再是一个项目一个工程，而是每一个模块创建一个工程，而多个模块整合在一起就需要使用到像 Maven 这样的构建工具。 一、为什么使用Maven?（Why）1.1、真的需要吗？1Maven 是干什么用的？这是很多同学在刚开始接触 Maven 时最大的问题。之所以会提出这个问题，是因为即使不使用 Maven 我们仍然可以进行 B/S 结构项目的开发。从表述层、业务逻辑层到持久化层再到数据库都有成熟的解决方案——不使用 Maven 我们一样可以开发项目啊？ 1这里给大家纠正一个误区，Maven 并不是直接用来辅助编码的，它战斗的岗位并不是以上各层。所以我们有必要通过企业开发中的实际需求来看一看哪些方面是我们现有技术的不足。 1.2、究竟为什么？为什么要使用 Maven？它能帮助我们解决什么问题？ ①、添加第三方 jar 包 12在今天的 JavaEE 开发领域，有大量的第三方框架和工具可以供我们使用。要使用这些 jar 包最简单的方法就是复制粘贴到 WEB-INF/lib 目录下。但是这会导致每次创建一个新的工程就需要将 jar 包重复复制到 lib 目录下，从而造成工作区中存在大量重复的文件，让我们的工程显得很臃肿。 而使用 Maven 后每个 jar 包本身只在本地仓库中保存一份，需要 jar 包的工程只需要以坐标的方式简单的引用一下就可以了。不仅极大的节约了存储空间，让项目更轻巧，更避免了重复文件太多而造成的混乱。 ②、jar 包之间的依赖关系 123jar 包往往不是孤立存在的，很多 jar 包都需要在其他 jar 包的支持下才能够正常工作，我们称之为 jar 包之间的依赖关系。最典型的例子是：commons-fileupload-1.3.jar 依赖于 commons-io-2.0.1.jar，如果没有 IO 包，FileUpload 包就不能正常工作。 那么问题来了，你知道你所使用的所有 jar 包的依赖关系吗？当你拿到一个新的从未使用过的 jar 包，你如何得知他需要哪些 jar 包的支持呢？如果不了解这个情况，导入的 jar 包不够，那么现有的程序将不能正常工作。再进一步，当你的项目中需要用到上百个 jar 包时，你还会人为的，手工的逐一确认它们依赖的其他 jar 包吗？这简直是不可想象的。 而引入 Maven 后，Maven 就可以替我们自动的将当前 jar 包所依赖的其他所有 jar 包全部导入进来，无需人工参与，节约了我们大量的时间和精力。用实际例子来说明就是：通过 Maven 导入 commons-fileupload-1.3.jar 后，commons-io-2.0.1.jar 会被自动导入，程序员不必了解这个依赖关系。 ③、获取第三方 jar 包 123JavaEE 开发中需要使用到的 jar 包种类繁多，几乎每个 jar 包在其本身的官网上的获取方式都不尽相同。为了查找一个 jar 包找遍互联网，身心俱疲，没有经历过的人或许体会不到这种折磨。不仅如此，费劲心血找的 jar 包里有的时候并没有你需要的那个类，又或者又同名的类没有你要的方法——以不规范的方式获取的 jar 包也往往是不规范的。 使用 Maven 我们可以享受到一个完全统一规范的 jar 包管理体系。你只需要在你的项目中以坐标的方式依赖一个 jar 包，Maven 就会自动从中央仓库进行下载，并同时下载这个 jar 包所依赖的其他 jar 包 ——规范、完整、准确！一次性解决所有问题！ Tips：在这里我们顺便说一下，统一的规范几乎可以说成是程序员的最高信仰。如果没有统一的规范，就意味着每个具体的技术都各自为政，需要以诸多不同的特殊的方式加入到项目中；好不容易加入进来还会和其他技术格格不入，最终受苦的是我们。而任何一个领域的统一规范都能够极大的降低程序员的工作难度，减少工作量。例如：USB 接口可以外接各种设备，如果每个设备都有自己独特的接口，那么不仅制造商需要维护各个接口的设计方案，使用者也需要详细了解每个设备对应的接口，无疑是非常繁琐的。 ④、将项目拆分成多个工程模块 123随着 JavaEE 项目的规模越来越庞大，开发团队的规模也与日俱增。一个项目上千人的团队持续开发很多年对于 JavaEE 项目来说再正常不过。那么我们想象一下：几百上千的人开发的项目是同一个 Web 工程。那么架构师、项目经理该如何划分项目的模块、如何分工呢？这么大的项目已经不可能通过 package 结构来划分模块，必须将项目拆分成多个工程协同开发。多个模块工程中有的是 Java 工程，有的是 Web 工程。 那么工程拆分后又如何进行互相调用和访问呢？这就需要用到 Maven 的依赖管理机制。大家请看我们的 Survey 调查项目拆分的情况： 上层模块依赖下层，所以下层模块中定义的 API 都可以为上层所调用和访问。 二、什么是Maven (What)?2.1、Maven 简介1Maven 是 Apache 软件基金会组织维护的一款自动化构建工具，专注服务于 Java 平台的项目构建和依赖管理。Maven 这个单词的本意是：专家，内行。读音是['meɪv(ə)n]或['mevn]。 2.2、什么是构建构建：构建并不是创建，创建一个工程并不等于构建一个项目。要了解构建的含义我们应该由浅入深的从以下三个层面来看： ①、纯 Java 代码 1大家都知道，我们 Java 是一门编译型语言，.java 扩展名的源文件需要编译成.class 扩展名的字节码文件才能够执行。所以编写任何 Java 代码想要执行的话就必须经过编译得到对应的.class 文件。 ②、Web 工程 12当我们需要通过浏览器访问 Java 程序时就必须将包含 Java 程序的 Web 工程编译的结果“拿”到服务器上的指定目录下，并启动服务器才行。这个“拿”的过程我们叫部署。 我们可以将未编译的 Web 工程比喻为一只生的鸡，编译好的 Web 工程是一只煮熟的鸡，编译部署的过程就是将鸡炖熟。 Web 工程和其编译结果的目录结构对比见下图： ③、实际项目 123在实际项目中整合第三方框架，Web 工程中除了 Java 程序和 JSP 页面、图片等静态资源之外，还包括第三方框架的 jar 包以及各种各样的配置文件。所有这些资源都必须按照正确的目录结构部署到服务器上，项目才可以运行。 所以综上所述：构建就是以我们编写的 Java 代码、框架配置文件、国际化等其他资源文件、JSP 页面和图片等静态资源作为“原材料”，去“生产”出一个可以运行的项目的过程。 那么项目构建的全过程中都包含哪些环节呢？ 2.3、 构建过程的几个主要环节 ①、清理：删除以前的编译结果，为重新编译做好准备。 ②、编译：将 Java 源程序编译为字节码文件。 ③、测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。 ④、报告：在每一次测试后以标准的格式记录和展示测试结果。 ⑤、打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web 工程对应 war 包。 ⑥、安装：在 Maven 环境下特指将打包的结果——jar 包或 war 包安装到本地仓库中。 ⑦、部署：将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。 2.4 、自动化构建1234其实上述环节我们在 Eclipse 中都可以找到对应的操作，只是不太标准。那么既然 IDE 已经可以进行构建了我们为什么还要使用 Maven 这样的构建工具呢？我们来看一个小故事：这是阳光明媚的一天。托马斯向往常一样早早的来到了公司，冲好一杯咖啡，进入了自己的邮箱——很不幸，QA 小组发来了一封邮件，报告了他昨天提交的模块的测试结果——有 BUG。“好吧，反正也不是第一次”，托马斯摇摇头，进入 IDE，运行自己的程序，编译、打包、部署到服务器上，然后按照邮件中的操作路径进行测试。“嗯，没错，这个地方确实有问题”，托马斯说道。于是托马斯开始尝试修复这个 BUG，当他差不多有眉目的时候已经到了午饭时间。 下午继续工作。BUG 很快被修正了，接着托马斯对模块重新进行了编译、打包、部署，测试之后确认没有问题了，回复了 QA 小组的邮件。 一天就这样过去了，明媚的阳光化作了美丽的晚霞，托马斯却觉得生活并不像晚霞那样美好啊。 让我们来梳理一下托马斯这一天中的工作内容 1从中我们发现，托马斯的很大一部分时间花在了“编译、打包、部署、测试”这些程式化的工作上面，而真正需要由“人”的智慧实现的分析问题和编码却只占了很少一部分。 1能否将这些程式化的工作交给机器自动完成呢？——当然可以！这就是自动化构建。 1此时 Maven 的意义就体现出来了，它可以自动的从构建过程的起点一直执行到终点： 2.5 Maven 核心概念Maven 能够实现自动化构建是和它的内部原理分不开的，这里我们从 Maven 的九个核心概念入手，看看 Maven 是如何实现自动化构建的 。 ①POM ②约定的目录结构 ③坐标 ④依赖管理 ⑤仓库管理 ⑥生命周期 ⑦插件和目标 ⑧继承 ⑨聚合 三、How?123Maven 的核心程序中仅仅定义了抽象的生命周期，而具体的操作则是由 Maven 的插件来完成的。可是Maven 的插件并不包含在 Maven 的核心程序中，在首次使用时需要联网下载。 下载得到的插件会被保存到本地仓库中。本地仓库默认的位置是：~\.m2\repository。 如果不能联网可以使用我们提供的 RepMaven.zip 解压得到。 3.1、具体操作参见“Maven 操作指南.txt。”3.2、约定的目录结构约定的目录结构对于 Maven 实现自动化构建而言是必不可少的一环，就拿自动编译来说，Maven 必须能找到 Java 源文件，下一步才能编译，而编译之后也必须有一个准确的位置保持编译得到的字节码文件。我们在开发中如果需要让第三方工具或框架知道我们自己创建的资源在哪，那么基本上就是两种方式： ①通过配置的形式明确告诉它 。 ②基于第三方工具或框架的约定Maven 对工程目录结构的要求就属于后面的一种。 现在 JavaEE 开发领域普遍认同一个观点：约定&gt;配置&gt;编码。意思就是能用配置解决的问题就不编码，能基于约定的就不进行配置。而 Maven 正是因为指定了特定文件保存的目录才能够对我们的 Java 工程进行自动化构建。 四、POM1Project Object Model：项目对象模型。将 Java 工程的相关信息封装为对象作为便于操作和管理的模型。 Maven 工程的核心配置。可以说学习 Maven 就是学习 pom.xml 文件中的配置。 4-1、坐标 几何中的坐标[1]、在一个平面中使用 x、y 两个向量可以唯一的确定平面中的一个点。[2]、在空间中使用 x、y、z 三个向量可以唯一的确定空间中的一个点。 Maven 的坐标使用如下三个向量在 Maven 的仓库中唯一的确定一个 Maven 工程。[1]、groupid：公司或组织的域名倒序+当前项目名称[2]、artifactId：当前项目的模块名称[3]、version：当前模块的版本 123&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;Hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; 如何通过坐标到仓库中查找 jar 包？ [1]、将 gav 三个向量连起来com.atguigu.maven+Hello+0.0.1-SNAPSHOT [2]、以连起来的字符串作为目录结构到仓库中查找com/atguigu/maven/Hello/0.0.1-SNAPSHOT/Hello-0.0.1-SNAPSHOT.jar※注意：我们自己的 Maven 工程必须执行安装操作才会进入仓库。安装的命令是：mvn install 五、依赖Maven 中最关键的部分，我们使用 Maven 最主要的就是使用它的依赖管理功能。要理解和掌握 Maven 的依赖管理，我们只需要解决一下几个问题： ①、依赖的目的是什么当A jar包用到了B jar包中的某些类时，A就对B产生了依赖，这是概念上的描述。那么如何在项目中以依赖的方式引入一个我们需要的jar包呢？答案非常简单，就是使用dependency标签指定被依赖jar包的坐标就可以了。 12345&lt;dependency&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;Hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; ②、依赖的范围大家注意到上面的依赖信息中除了目标jar包的坐标还有一个scope设置，这是依赖的范围。依赖的范围有几个可选值，我们用得到的是：compile、test、provided三个。 [1]、从项目结构角度理解 compile 和 test 的区别结合具体例子：对于HelloFriend来说，Hello就是服务于主程序的，junit是服务于测试程序的。HelloFriend 主程序需要 Hello 是非常明显的，测试程序由于要调用主程序所以也需要 Hello，所以 compile范围依赖对主程序和测试程序都应该有效。HelloFriend的测试程序部分需要junit也是非常明显的，而主程序是不需要的，所以test范围依赖仅仅对于主程序有效。 [2]、从开发和运行这两个不同阶段理解 compile 和 provided 的区别 [3]、有效性总结 compile test provided 主程序 √ × √ 测试程序 √ √ √ 参与部署 √ × × ③、依赖的传递性A依赖B，B依赖C，A能否使用C呢？那要看B依赖C的范围是不是compile，如果是则可用，否则不可用。 ④、依赖的排除如果我们在当前工程中引入了一个依赖是A，而A又依赖了 B，那么 Maven 会自动将 A 依赖的 B 引入当前工程，但是个别情况下B有可能是一个不稳定版，或对当前工程有不良影响。这时我们可以在引入A的时候将B排除。[1]、情景举例 [2]、配置方式 12345678910111213&lt;dependency&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;HelloFriend&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; [3]、排除后的效果 ⑤、统一管理所依赖jar包的版本对同一个框架的一组jar包最好使用相同的版本。为了方便升级框架，可以将jar包的版本信息统一提取出来[1]、统一声明版本号 123&lt;properties&gt; &lt;atguigu.spring.version&gt;4.1.1.RELEASE&lt;/atguigu.spring.version&gt; &lt;/properties&gt; 其中atguigu.spring.version部分是自定义标签。 [2]、引用前面声明的版本号 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;atguigu.spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; …… &lt;/dependencies&gt; [3]、其他用法 123&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; ⑥、依赖的原则：解决 jar 包冲突[1]、路径最短者优先 [2]、路径相同时先声明者优先 这里“声明”的先后顺序指的是 dependency 标签配置的先后顺序。 六、仓库6-1、分类[1]、本地仓库：为当前本机电脑上的所有 Maven 工程服务。[2]、远程仓库 (1)、私服：架设在当前局域网环境下，为当前局域网范围内的所有 Maven 工程服务。 (2)、中央仓库：架设在 Internet 上，为全世界所有 Maven 工程服务。 (3)、中央仓库的镜像：架设在各个大洲，为中央仓库分担流量。减轻中央仓库的压力，同时更快的响应用户请求。 6-2、仓库中的文件 [1]、Maven 的插件 。 [2]、我们自己开发的项目的模块 。 [3]、第三方框架或工具的 jar 包 。 ※不管是什么样的 jar 包，在仓库中都是按照坐标生成目录结构，所以可以通过统一的方式查询或依赖。 六、生命周期6.1、什么是 Maven 的生命周期？Maven 生命周期定义了各个构建环节的执行顺序，有了这个清单，Maven 就可以自动化的执行构建命令了。 Maven 有三套相互独立的生命周期，分别是： ①、Clean Lifecycle 在进行真正的构建之前进行一些清理工作。 ②、Default Lifecycle 构建的核心部分，编译，测试，打包，安装，部署等等。 ③、Site Lifecycle 生成项目报告，站点，发布站点。 它们是相互独立的，你可以仅仅调用 clean 来清理工作目录，仅仅调用 site 来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。 每套生命周期都由一组阶段 (Phase) 组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行 mvn clean，这个 clean 是 Clean 生命周期的一个阶段。有 Clean 生命周期，也有 clean 阶段。 1、Clean 生命周期Clean 生命周期一共包含了三个阶段：①pre-clean 执行一些需要在 clean 之前完成的工作②clean 移除所有上一次构建生成的文件③post-clean 执行一些需要在 clean 之后立刻完成的工作 2、Site 生命周期①pre-site 执行一些需要在生成站点文档之前完成的工作②site 生成项目的站点文档③post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备④site-deploy 将生成的站点文档部署到特定的服务器上这里经常用到的是 site 阶段和 site-deploy 阶段，用以生成和发布 Maven 站点，这可是 Maven 相当强大的功能，Manager 比较喜欢，文档及统计数据自动生成，很好看。 3、Default 生命周期Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段： validate generate-sources process-sourcesgenerate-resourcesprocess-resources 复制并处理资源文件，至目标目录，准备打包。compile 编译项目的源代码。process-classes generate-test-sources process-test-sourcesgenerate-test-resourcesprocess-test-resources 复制并处理资源文件，至目标测试目录。test-compile 编译测试源代码。process-test-classestest 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。prepare-packagepackage 接受编译好的代码，打包成可发布的格式，如 JAR。pre-integration-test integration-test post-integration-test verifyinstall 将包安装至本地仓库，以让其它项目依赖。deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享或部署到服务器上运行。 6.2、 生命周期与自动化构建运行任何一个阶段的时候，它前面的所有阶段都会被运行，例如我们运行 mvn install 的时候，代码会被编译，测试，打包。这就是 Maven 为什么能够自动执行构建过程的各个环节的原因。此外，Maven 的插件机制是完全依赖 Maven 的生命周期的，因此理解生命周期至关重要。插件和目标●Maven 的核心仅仅定义了抽象的生命周期，具体的任务都是交由插件完成的。●每个插件都能实现多个功能，每个功能就是一个插件目标。●Maven 的生命周期与插件目标相互绑定，以完成某个具体的构建任务。例如：compile 就是插件 maven-compiler-plugin 的一个目标；pre-clean 是插件 maven-clean-plugin 的一个目标。 七、继承7.1、为什么需要继承机制？由于非 compile 范围的依赖信息是不能在“依赖链”中传递的，所以有需要的工程只能单独配置。例如： 以下工程pom配置Hello 12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; HelloFriend &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; MakeFriend &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 此时如果项目需要将各个模块的 junit 版本统一为 4.9，那么到各个工程中手动修改无疑是非常不可取的。使用继承机制就可以将这样的依赖信息统一提取到父工程模块中进行统一管理。 创建父工程创建父工程和创建一般的 Java 工程操作一致，唯一需要注意的是：打包方式处要设置为 pom。 在子工程中引用父工程 1234567891011121314151617181920212223242526272829303132333435&lt;parent&gt; &lt;!-- 父工程坐标 --&gt; &lt;groupId&gt;...&lt;/groupId&gt; &lt;artifactId&gt;...&lt;/artifactId&gt; &lt;version&gt;...&lt;/version&gt; &lt;relativePath&gt;从当前目录到父项目的 pom.xml 文件的相对路径&lt;/relativePath&gt; &lt;/parent&gt; &lt;parent&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 指定从当前子工程的pom.xml文件出发，查找父工程的pom.xml的路径 --&gt; &lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; 此时如果子工程的 groupId 和 version 如果和父工程重复则可以删除。 11.4 在父工程中管理依赖将 Parent 项目中的 dependencies 标签，用 dependencyManagement 标签括起来 &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 在子项目中重新指定需要的依赖，删除范围和版本号 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 八、聚合8.1、为什么要使用聚合？将多个工程拆分为模块后，需要手动逐个安装到仓库后依赖才能够生效。修改源码后也需要逐个手动进行 clean 操作。而使用了聚合之后就可以批量进行 Maven 工程的安装、清理工作。 8.2、如何配置聚合？在总的聚合工程中使用 modules/module 标签组合，指定模块工程的相对路径即可 1234&lt;modules&gt; &lt;module&gt;../Hello&lt;/module&gt; &lt;module&gt;../HelloFriend&lt;/module&gt; &lt;module&gt;../MakeFriends&lt;/module&gt; &lt;/modules&gt; 13 Maven 酷站我们可以到 http://mvnrepository.com/搜索需要的 jar 包的依赖信息。]]></content>
      <categories>
        <category>开发工具相关</category>
      </categories>
      <tags>
        <tag>Maven使用手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、MySQL 基础]]></title>
    <url>%2F2019%2F04%2F28%2FMySQL%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[[toc] 一、为什么要学习数据库 1、持久化数据到本地。 2、可以实现结构化查询，方便管理。 二、数据库的相关概念DBMS、DB、SQL 1、DB：数据库，保存一组有组织的数据的容器。 2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据。 3、SQL:结构化查询语言，用于和DBMS通信的语言。 三、数据库存储数据的特点 1、数据存放到表中，然后表再放到库中。 2、一个库中可以有多张表，每张表具有唯一的表名用来标识自己。 3、表中有一个或多个列，列又称为“字段”，相当于java中“属性”。 4、表中的每一行数据，相当于java中“对象”。 四、初始 MySQL4-2、MySQL 产品的介绍 1、MySQL 的背景 前身属于瑞典的一家公司，MySQL AB。 08 年被 sun 公司收购。 09 年 sun 被 oracle 收购。 2、MySQL 的优点 1、开源、免费、成本低。 2、性能高、移植性也好。 3、体积小，便于安装。 4-3、MySQL 产品的安装 ★ 1、属于c/s架构的软件，一般来讲安装服务端。 企业版。 社区版(5.5、5.6、5.7、8.0)。 4-4、MySQL 服务的启动和停止 ★12345方式一：计算机——右击管理——服务方式二：通过管理员身份运行 net start 服务名（启动服务） net stop 服务名（停止服务） 4-5、MySQL 服务的登录和退出 ★123456789方式一：通过mysql自带的客户端 只限于root用户方式二：通过windows自带的客户端 登录： mysql 【-h主机名 -P端口号 】-u用户名 -p密码 退出： exit或ctrl+C 4-6、MySQL 的常见命令和语法规范常见命令1234567891011121314151617181920212223242526-- 1.查看当前所有的数据库。show databases;-- 2.打开指定的库。use 库名-- 3.查看当前库的所有表。show tables;-- 4.查看其它库的所有表。show tables from 库名;-- 5.创建表。create table 表名( 列名 列类型, 列名 列类型， 。。。);-- 6.查看表结构。desc 表名;-- 7.查看服务器的版本。select version();-- 方式一：登录到mysql服务端。mysql -- version;或 mysql --V;-- 方式二：没有登录到mysql服务端。 语法规范12345671.不区分大小写,但建议关键字大写，表名、列名小写。2.每条命令最好用分号结尾。3.每条命令根据需要，可以进行缩进 或换行。4.注释。 单行注释：#注释文字 单行注释：-- 注释文字 多行注释：/* 注释文字 */ 4-7、SQL 的语言分类。12345678DQL（Data Query Language）：数据查询语言 select DML(Data Manipulate Language):数据操作语言 insert 、update、deleteDDL（Data Define Languge）：数据定义语言 create、drop、alterTCL（Transaction Control Language）：事务控制语言 commit、rollback 五、DQL语言的学习 ★5-1、基础查询 ★12345678语法：SELECT 要查询的东西【FROM 表名】;类似于Java中 :System.out.println(要打印的东西);特点：①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在。②要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数 。 5-2、条件查询 ★1234567891011121314151617181920212223242526条件查询：根据条件过滤原始表的数据，查询到想要的数据语法：select 要查询的字段|表达式|常量值|函数from 表where 条件 ;分类：一、条件表达式 示例：salary&gt;10000 条件运算符： &gt; &lt; &gt;= &lt;= = != &lt;&gt;二、逻辑表达式示例：salary&gt;10000 &amp;&amp; salary&lt;20000逻辑运算符： and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false or(||)：两个条件只要有一个成立，结果为true，否则为false not(!)：如果条件成立，则not后为false，否则为true三、模糊查询示例：last_name like &apos;a%&apos; 5-3、排序查询 ★123456789语法：select 要查询的东西from 表where 条件order by 排序的字段|表达式|函数|别名 【asc|desc】 5-4、常见函数 ★1234567891011121314151617181920212223242526272829303132333435363738一、单行函数1、字符函数 concat拼接 substr截取子串 upper转换成大写 lower转换成小写 trim去前后指定的空格和字符 ltrim去左边空格 rtrim去右边空格 replace替换 lpad左填充 rpad右填充 instr返回子串第一次出现的索引 length 获取字节个数 2、数学函数 round 四舍五入 rand 随机数 floor向下取整 ceil向上取整 mod取余 truncate截断3、日期函数 now当前系统日期+时间 curdate当前系统日期 curtime当前系统时间 str_to_date 将字符转换成日期 date_format将日期转换成字符4、流程控制函数 if 处理双分支 case语句 处理多分支 情况1：处理等值判断 情况2：处理条件判断 5、其他函数 version版本 database当前库 user当前连接用户 5-5、分组函数 ★123456789101112131415sum 求和max 最大值min 最小值avg 平均值count 计数特点：1、以上五个分组函数都忽略null值，除了count(*)2、sum和avg一般用于处理数值型 max、min、count可以处理任何数据类型3、都可以搭配distinct使用，用于统计去重后的结果4、count的参数可以支持： 字段、*、常量值，一般放1 建议使用 count(*) 5-6、分组查询 ★12345678910111213141516语法：select 查询的字段，分组函数from 表group by 分组的字段特点：1、可以按单个字段分组2、和分组函数一同查询的字段最好是分组后的字段3、分组筛选 针对的表 位置 关键字分组前筛选： 原始表 group by的前面 where分组后筛选： 分组后的结果集 group by的后面 having4、可以按多个字段分组，字段之间用逗号隔开5、可以支持排序6、having后可以支持别名 5-7、连接查询 ★12笛卡尔乘积：如果连接条件省略或无效则会出现解决办法：添加上连接条件。 一、传统模式下的连接 ：等值连接——非等值连接。 1.等值连接的结果 = 多个表的交集。 2.n表连接，至少需要n-1个连接条件。 3.多个表不分主次，没有顺序要求。 4.一般为表起别名，提高阅读性和性能。 二、sql99语法：通过join关键字实现连接。 123456789101112131415161718含义：1999年推出的sql语法支持：等值连接、非等值连接 （内连接）外连接交叉连接语法：select 字段，...from 表1【inner|left outer|right outer|cross】join 表2 on 连接条件【inner|left outer|right outer|cross】join 表3 on 连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】好处：语句上，连接条件和筛选条件实现了分离，简洁明了！ 三、自连接案例：查询员工名和直接上级的名称 sql99 123SELECT e.last_name,m.last_name FROM employees e JOIN employees m ON e.`manager_id`=m.`employee_id`; sql92 123SELECT e.last_name,m.last_name FROM employees e,employees m WHERE e.`manager_id`=m.`employee_id`; 5-8、子查询 √含义： 1一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询。 特点： 123456789101112131415161、子查询都放在小括号内2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧3、子查询优先于主查询执行，主查询使用了子查询的执行结果4、子查询根据查询结果的行数不同分为以下两类：① 单行子查询 结果集只有一行 一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= 非法使用子查询的情况： a、子查询的结果为一组值 b、子查询的结果为空 ② 多行子查询 结果集有多行 一般搭配多行操作符使用：any、all、in、not in in： 属于子查询结果中的任意一个就行 any和all往往可以用其他查询代替 5-9、分页查询 ★应用场景： 1实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句。 语法： 1234567select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【起始的条目索引，】条目数; 特点： 123456781.起始条目索引从0开始2.limit子句放在查询语句的最后3.公式：select * from 表 limit （page-1）*sizePerPage,sizePerPage假如:每页显示条目数sizePerPage要显示的页数 page 5-10、union联合查询 √引入： union 联合、合并 语法： 12345select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】 特点： 1231、多条查询语句的查询的列数必须是一致的2、多条查询语句的查询的列的类型几乎相同3、union代表去重，union all代表不去重 六、DML语言的学习 ★6-2、插入语句语法： insert into 表名(字段名，…) values(值1，…); 特点： 123451、字段类型和值类型一致或兼容，而且一一对应。2、可以为空的字段，可以不用插入值，或用null填充。3、不可以为空的字段，必须插入值。4、字段个数和值的个数必须一致。5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致 。 6-3、修改语句修改单表语法： 12update 表名 set 字段=新值,字段=新值【where 条件】 修改多表语法： 1234update 表1 别名1,表2 别名2 set 字段=新值，字段=新值 where 连接条件 and 筛选条件 1、如何对一张表的数据进行批量更新？ 6-4、删除语句方式1：delete语句 1、单表的删除： ★ 1delete from 表名 【where 筛选条件】 2、多表的删除： 1234delete 别名1，别名2from 表1 别名1，表2 别名2where 连接条件and 筛选条件; 方式2：truncate语句 1truncate table 表名 两种方式的区别【面试题】 12345678#1.truncate不能加where条件，而delete可以加where条件。#2.truncate的效率高一丢丢。#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始。#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始。#4.truncate删除不能回滚，delete删除可以回滚。 七、DDL语言的学习7-1、库和表的管理 √库的管理： 1234一、创建库create database 库名二、删除库drop database 库名 表的管理： 123456789101112131415161718192021222324252627282930#1.创建表CREATE TABLE IF NOT EXISTS stuinfo( stuId INT, stuName VARCHAR(20), gender CHAR, bornDate DATETIME);DESC studentinfo;#2.修改表 alter语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;#①修改字段名ALTER TABLE studentinfo CHANGE COLUMN sex gender CHAR;#②修改表名ALTER TABLE stuinfo RENAME [TO] studentinfo;#③修改字段类型和列级约束ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;#④添加字段ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;#⑤删除字段ALTER TABLE studentinfo DROP COLUMN email;#3.删除表DROP TABLE [IF EXISTS] studentinfo; 7-2、常见数据类型介绍 √ 整型： 小数： 浮点型 定点型 字符型： 日期型： Blob类型： 7-3、常见约束 √ NOT NULL DEFAULT UNIQUE CHECK PRIMARY KEY FOREIGN KEY 八、TCL语言的学习事务和事务处理含义：通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态特点：（ACID） 原子性：要么都执行，要么都回滚。 一致性：保证数据的状态操作前和操作后保持一致。（比如：钱的总额一定，分布式数据库中数据存储保持一致性。） 隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰。 持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改。8-1、事务的分类 隐式事务，没有明显的开启和结束事务的标志。 123比如insert、update、delete语句本身就是一个事务。- 显式事务，具有明显的开启和结束事务的标志。 1234567891、开启事务取消自动提交事务的功能2、编写事务的一组逻辑操作单元（多条sql语句）insertupdatedelete3、提交事务或回滚事务 8-2、使用到的关键字12345678set autocommit=0;start transaction;commit;rollback;savepoint 断点commit to 断点rollback to 断点 8-3、事务的隔离级别 1、事务并发问题如何发生？当多个事务同时操作同一个数据库的相同数据时。 2、事务的并发问题有哪些？ 脏读：一个事务读取到了另外一个事务未提交的数据。 不可重复读：同一个事务中，多次读取到的数据不一致。 幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据。 3、如何避免事务的并发问题？ 12345通过设置事务的隔离级别1、READ UNCOMMITTED。2、READ COMMITTED 可以避免脏读。3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读。4、SERIALIZABLE可以避免脏读、不可重复读和幻读。 4、设置隔离级别： 1set session|global transaction isolation level 隔离级别名; 5、查看隔离级别： 1select @@tx_isolation; 九、视图的讲解 √ 含义：理解成一张虚拟的表。 视图和表的区别： 使用方式 占用物理空间 视图 完全相同 不占用，仅仅保存的是sql逻辑 表 完全相同 占用 视图的好处： 1、sql语句提高重用性，效率高。 2、和表实现了分离，提高了安全性。9-1、视图的创建 1234语法：CREATE VIEW 视图名AS查询语句; 9-2、视图的增删改查12345678910111213141、查看视图的数据 ★SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name='Partners';2、插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES('虚竹',90);3、修改视图的数据UPDATE my_v4 SET last_name ='梦姑' WHERE last_name='虚竹';4、删除视图的数据DELETE FROM my_v4; 9-3、某些视图不能更新包含以下关键字的sql语句： 分组函数、distinct、group by、having、union或者union all。 常量视图。 Select中包含子查询。 join from一个不能更新的视图。 where子句的子查询引用了from子句中的表。9-4、视图逻辑的更新 123456789101112#方式一：重新创建CREATE OR REPLACE VIEW test_v7ASSELECT last_name FROM employeesWHERE employee_id&gt;100;#方式二: 修改更新视图逻辑ALTER VIEW test_v7ASSELECT employee_id FROM employees;SELECT * FROM test_v7; 9-5、视图的删除1DROP VIEW test_v1,test_v2,test_v3; 9-6、视图结构的查看12DESC test_v7;SHOW CREATE VIEW test_v7; 十、变量10-1、系统变量 1、全局变量(作用域：针对于所有会话（连接）有效，但不能跨重启) 123456789101112查看所有全局变量SHOW GLOBAL VARIABLES;查看满足条件的部分系统变量SHOW GLOBAL VARIABLES LIKE &apos;%char%&apos;;查看指定的系统变量的值SELECT @@global.autocommit;为某个系统变量赋值SET @@global.autocommit=0;SET GLOBAL autocommit=0; 2、会话变量(作用域：针对于当前会话（连接）有效) 12345678910111213查看所有会话变量SHOW SESSION VARIABLES;查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE &apos;%char%&apos;;查看指定的会话变量的值SELECT @@autocommit;SELECT @@session.tx_isolation;为某个会话变量赋值SET @@session.tx_isolation=&apos;read-uncommitted&apos;;SET SESSION tx_isolation=&apos;read-committed&apos;; 10-2、自定义变量 1、用户变量 12345678910111213141516171819- 声明并初始化SET @变量名=值;SET @变量名:=值;SELECT @变量名:=值;- 赋值方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表;- 使用select @变量名; 2、局部变量 123456789101112131415声明：declare 变量名 类型 【default 值】;赋值：方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表;使用：select 变量名 10-3、系统变量和自定义变量区别 作用域 定义位置 语法 用户变量 当前会话 会话的任何地方 加@符号，不用指定类型 局部变量 定义它的BEGIN END中 BEGIN END的第一句话 一般不用加@,需要指定类型 十一、存储过程和函数 含义：一组经过预先编译的sql语句的集合。 好处： 1、提高了sql语句的重用性，减少了开发程序员的压力。 2、提高了效率。 3、减少了传输次数。 分类： 1、无返回无参。 2、仅仅带in类型，无返回有参。 3、仅仅带out类型，有返回无参。 4、既带in又带out，有返回有参。 5、带inout，有返回有参。11-1、创建存储过程 1、DELIMITER 关键字及语法 123456789101112mysql 默认以分号为语句的结束，但是在创建存储过程时 sql 语句中一般会出现多个分号。为了不让语句过早遇见分号;执行。在创建语句首行使用该关键字+特殊符号来指定其他字符为语句的结束。最后再指定 delimiter ; 恢复分号为语句结束标志。例如：DELIMITER $$ DROP TRIGGER IF EXISTS `updateegopriceondelete`$$ CREATE TRIGGER `updateegopriceondelete` AFTER DELETE ON `customerinfo` FOR EACH ROW BEGIN DELETE FROM egoprice WHERE customerId=OLD.customerId; END$$ DELIMITER ; 2 、语法 1234567891011121314151617181920212223242526272829303132#1、语法create procedure 存储过程名(in|out|inout 参数名 参数类型,...)begin 存储过程体end#2、类似于方法修饰符 返回类型 方法名(参数类型 参数名,...)&#123; 方法体;&#125;#3、注意1、需要设置新的结束标记delimiter 新的结束标记示例：delimiter $CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)BEGIN sql语句1; sql语句2;END $2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end3、参数前面的符号的意思in:该参数只能作为输入 （该参数不能做返回值）out：该参数只能作为输出（该参数只能做返回值）inout：既能做输入又能做输出 11-2、调用存储过程1call 存储过程名(实参列表) 11-3、创建函数 学过的函数：LENGTH、SUBSTR、CONCAT 等。 语法 12345CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型BEGIN 函数体END 11-4、调用函数1SELECT 函数名（实参列表） 11-5、函数和存储过程的区别 关键字 调用语法 返回值 应用场景 函数 FUNCTION SELECT 函数() 只能是一个 一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个 存储过程 PROCEDURE CALL 存储过程() 可以有0个或多个 一般用于更新 十二、流程控制结构12-1、分支一、if函数 语法：if(条件，值1，值2) 特点：可以用在任何位置 二、case语句 语法： 情况一：类似于switch case 表达式 when 值1 then 结果1或语句1(如果是语句，需要加分号) when 值2 then 结果2或语句2(如果是语句，需要加分号) ... else 结果n或语句n(如果是语句，需要加分号) end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要） 情况二：类似于多重if case when 条件1 then 结果1或语句1(如果是语句，需要加分号) when 条件2 then 结果2或语句2(如果是语句，需要加分号) ... else 结果n或语句n(如果是语句，需要加分号) end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要） 特点： 可以用在任何位置 三、if elseif语句 语法： if 情况1 then 语句1; elseif 情况2 then 语句2; ... else 语句n; end if; 特点： 只能用在begin end中！！！！！！！！！！！！！！！ 三者比较： 应用场合 if函数 简单双分支 case结构 等值判断 的多分支 if结构 区间判断 的多分支 12-2、循环语法： 【标签：】WHILE 循环条件 DO 循环体 END WHILE 【标签】; 特点： 只能放在BEGIN END里面 如果要搭配leave跳转语句，需要使用标签，否则可以不用标签 leave类似于java中的break语句，跳出所在循环！！！]]></content>
      <categories>
        <category>MySQL基础</category>
      </categories>
      <tags>
        <tag>MySQL基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、SQL 转换：Oracle 转 MySQL]]></title>
    <url>%2F2019%2F04%2F25%2FMySQL%E6%9B%BF%E4%BB%A3Oracle%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[什么是自增长？ 自增长只能用于表中的其中一个字段。 自增长只能被分配给固定表的固定的某一字段，不能被多个表共用。 自增长会把一个未指定或NULL值的字段自动填上。 一、在 Oracle 中如何实现 MySQL 的自增长？请看下面的实例： 1-1、在 MYSQL 里有这样一张表: 123456789CREATE TABLE Movie( id INT NOT NULL AUTO_INCREMENT, name VARCHAR(60) NOT NULL, released YEAR NOT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB; INSERT INTO Movie (name,released) VALUES ('Gladiator',2000); INSERT INTO Movie (id,name,released) VALUES (NULL,'The Bourne Identity',1998); 1-2、在 ORACLE 是这样的使用序列对象+触发器来完成 MySQL 的自增长功能 1234567CREATE TABLE Movie( id INT NOT NULL, name VARCHAR2(60) NOT NULL, released INT NOT NULL, PRIMARY KEY (id) ); CREATE SEQUENCE MovieSeq; 1INSERT INTO Movie (id,name,released) VALUES (MovieSeq.NEXTVAL,'Gladiator',2000); 在 Oracle 下为表添加一个触发器，就可以实现 MySQL 自增长功能:123456781. CREATE OR REPLACE TRIGGER BRI_MOVIE_TRG 2. BEFORE INSERT ON Movie 3. FOR EACH ROW 4. BEGIN 5. SELECT MovieSeq.NEXTVAL INTO :new.id FROM DUAL; 6. END BRI_MOVIE_TRG; 7. . 8. RUN; 这样，插入记录就可以成为 MYSQL 风格： 1INSERT INTO Movie (name,released) VALUES ('The Lion King',1994); 下面我们来看看如何在 mysql 数据里使用 Oracle 序列语法 .NEXTVAL 和 .CURVAL。 二、MySQL 如何实现 Oracle 序列？一般使用序列 (Sequence) 来处理主键字段，在 MySQL中 是没有序列的，但是 MySQL有提供了自增长 (increment) 来实现类似的目的，但也只是自增，而不能设置步长、开始索引、是否循环等，最重要的是一张表只能由一个字段使用自增，但有的时候我们需要两个或两个以上的字段实现自增（单表多字段自增），MySQL本身是实现不了的，但我们可以用创建一个序列表，使用函数来获取序列的值。 我们假设在 MySQL 中序列的语法是: 123NEXTVAL(’sequence’);CURRVAL(’sequence’);SETVAL(’sequence’,value); 123456789DROP TABLE IF EXISTS sequence; CREATE TABLE sequence ( name VARCHAR(50) NOT NULL, current_value INT NOT NULL, increment INT NOT NULL DEFAULT 1, PRIMARY KEY (name) ) ENGINE=InnoDB; INSERT INTO sequence VALUES ('MovieSeq',3,5); 测试一下结果：测试 currval 函数使用 123456789101112131415/* currval 函数的实现 */ DROP FUNCTION IF EXISTS currval; DELIMITER $ CREATE FUNCTION currval (seq_name VARCHAR(50)) RETURNS INTEGER CONTAINS SQL BEGIN DECLARE value INTEGER; SET value = 0; SELECT current_value INTO value FROM sequence WHERE name = seq_name; RETURN value; END$ DELIMITER ; 1234567891011121314151617181920211. mysql&gt; SELECT currval('MovieSeq'); 2. +---------------------+ 3. | currval('MovieSeq') | 4. +---------------------+ 5. | 3 | 6. +---------------------+ 7. 1 row in set (0.00 sec) 8. mysql&gt; SELECT currval('x'); 9. +--------------+ 10. | currval('x') | 11. +--------------+ 12. | 0 | 13. +--------------+ 14. 1 row in set, 1 warning (0.00 sec) 15. mysql&gt; show warnings; 16. +---------+------+------------------+ 17. | Level | Code | Message | 18. +---------+------+------------------+ 19. | Warning | 1329 | No data to FETCH | 20. +---------+------+------------------+ 21. 1 row in set (0.00 sec) 测试 nextval 函数使用 12345678910111213/* nextval 函数的实现 */DROP FUNCTION IF EXISTS nextval; DELIMITER $ CREATE FUNCTION nextval (seq_name VARCHAR(50)) RETURNS INTEGER CONTAINS SQL BEGIN UPDATE sequence SET current_value = current_value + increment WHERE name = seq_name; RETURN currval(seq_name); END$ DELIMITER ; 12345678910111213141516171819202122231. mysql&gt; select nextval('MovieSeq'); 2. +---------------------+ 3. | nextval('MovieSeq') | 4. +---------------------+ 5. | 15 | 6. +---------------------+ 7. 1 row in set (0.09 sec) 9. mysql&gt; select nextval('MovieSeq'); 10. +---------------------+ 11. | nextval('MovieSeq') | 12. +---------------------+ 13. | 20 | 14. +---------------------+ 15. 1 row in set (0.01 sec) 17. mysql&gt; select nextval('MovieSeq'); 18. +---------------------+ 19. | nextval('MovieSeq') | 20. +---------------------+ 21. | 25 | 22. +---------------------+ 23. 1 row in set (0.00 sec) 测试 setval 函数的使用 12345678910111213/* setval 函数的实现 */DROP FUNCTION IF EXISTS setval; DELIMITER $ CREATE FUNCTION setval (seq_name VARCHAR(50), value INTEGER) RETURNS INTEGER CONTAINS SQL BEGIN UPDATE sequence SET current_value = value WHERE name = seq_name; RETURN currval(seq_name); END$ DELIMITER ; 12345678910111213141516171819202122231. mysql&gt; select setval('MovieSeq',150); 2. +------------------------+ 3. | setval('MovieSeq',150) | 4. +------------------------+ 5. | 150 | 6. +------------------------+ 7. 1 row in set (0.06 sec) 9. mysql&gt; select curval('MovieSeq'); 10. +---------------------+ 11. | currval('MovieSeq') | 12. +---------------------+ 13. | 150 | 14. +---------------------+ 15. 1 row in set (0.00 sec) 17. mysql&gt; select nextval('MovieSeq'); 18. +---------------------+ 19. | nextval('MovieSeq') | 20. +---------------------+ 21. | 155 | 22. +---------------------+ 23. 1 row in set (0.00 sec) 三、MySQL 替代 Oracle 序列实例： 1、问题场景：一般使用序列 (Sequence) 来处理主键字段，在 MySQL中 是没有序列的，但是 MySQL有提供了自增长 (increment) 来实现类似的目的，但也只是自增，而不能设置步长、开始索引、是否循环等，最重要的是一张表只能由一个字段使用自增，但有的时候我们需要两个或两个以上的字段实现自增（单表多字段自增），MySQL本身是实现不了的，但我们可以用创建一个序列表，使用函数来获取序列的值。 – MySQL 给数据表某个字段创建序列。– 序列：自增（步长、开始索引、是否循环），暂不考虑是否循环自增（触发器可实现？）select * from PAN_WF_HISTORYNODE;– ORDER_NUMBER 字段创建序列 – 创建代替序列的数据表 12345678DROP TABLE IF EXISTS sequence; CREATE TABLE sequence ( name VARCHAR(50) NOT NULL, -- 序列 名称 50个字符最大值问题已够用，暂不考虑是否循环。current_value INT NOT NULL, -- 当前值increment INT NOT NULL DEFAULT 1, -- 步长PRIMARY KEY (name) ) ENGINE=InnoDB; INSERT INTO sequence VALUES ('seq_hisnode',0,1); – 处理 序列的 currval 函数 123456789101112131415161718Set global log_bin_trust_function_creators=1;-- 解决自定义函数报错：ERROR 1418-This function has none of DETERMINISTICDROP FUNCTION IF EXISTS currval; DELIMITER $ CREATE FUNCTION currval (seq_name VARCHAR(50)) RETURNS INTEGER CONTAINS SQL BEGIN DECLARE value INTEGER; SET value = 0; SELECT current_value INTO value FROM sequence WHERE name = seq_name; RETURN value; END$ DELIMITER ; SELECT currval('seq_hisnode');-- 测试 该函数的使用。 – 处理序列的 nextval 函数 123456789101112131415DROP FUNCTION IF EXISTS nextval; DELIMITER $ CREATE FUNCTION nextval (seq_name VARCHAR(50)) RETURNS INTEGER CONTAINS SQL BEGIN UPDATE sequence SET current_value = current_value + increment WHERE name = seq_name; RETURN currval(seq_name); END$ DELIMITER ;select nextval('seq_hisnode');INSERT into PAN_WF_HISTORYNODE values()]]></content>
      <categories>
        <category>MySQL 学习</category>
      </categories>
      <tags>
        <tag>MySQL 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-4--AOP]]></title>
    <url>%2F2019%2F03%2F25%2FSpring-4--AOP%2F</url>
    <content type="text"><![CDATA[[toc] 1、为什么需要 AOP？需求案例：需求1-日志：在程序执行期间追踪正在发生的活动。需求2-验证：希望计算器只能处理正数的运算。 1-1、不使用 AOP 时的代码实现。 1-2、使用动态代理解决问题分析代理设计模式的原理：使用一个代理将对象包装起来, 然后用该代理对象取代原始对象. 任何对原始对象的调用都要通过代理. 代理对象决定是否以及何时将方法调用转到原始对象上。 0、接口实现类 12345678910111213141516171819202122232425public class ArithmeticCalculatorImpl implements ArithmeticCalculator &#123; @Override public int add(int i, int j) &#123; int result = i + j; return result; &#125; @Override public int sub(int i, int j) &#123; int result = i - j; return result; &#125; @Override public int mul(int i, int j) &#123; int result = i * j; return result; &#125; @Override public int div(int i, int j) &#123; int result = i / j; return result; &#125; 1、新建处理日志的代理类 ArithmeticCalculatorLoggingProxy，将原始对象包装起来。（匿名内部类的方式实现） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class ArithmeticCalculatorLoggingProxy &#123; //要代理的对象 private ArithmeticCalculator target; public ArithmeticCalculatorLoggingProxy(ArithmeticCalculator target) &#123; super(); this.target = target; &#125; //返回代理对象 public ArithmeticCalculator getLoggingProxy()&#123; ArithmeticCalculator proxy = null; ClassLoader loader = target.getClass().getClassLoader(); Class [] interfaces = new Class[]&#123;ArithmeticCalculator.class&#125;; InvocationHandler h = new InvocationHandler() &#123; /** * proxy: 代理对象。 一般不使用该对象 * method: 正在被调用的方法 * args: 调用方法传入的参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); //打印日志 System.out.println("[before] The method " + methodName + " begins with " + Arrays.asList(args)); //调用目标方法 Object result = null; try &#123; //前置通知 result = method.invoke(target, args); //返回通知, 可以访问到方法的返回值 &#125; catch (NullPointerException e) &#123; e.printStackTrace(); //异常通知, 可以访问到方法出现的异常 &#125; //后置通知. 因为方法可以能会出异常, 所以访问不到方法的返回值 //打印日志 System.out.println("[after] The method ends with " + result); return result; &#125; &#125;; /** * loader: 代理对象使用的类加载器。 * interfaces: 指定代理对象的类型. 即代理代理对象中可以有哪些方法. * h: 当具体调用代理对象的方法时, 应该如何进行响应, 实际上就是调用 InvocationHandler 的 invoke 方法 */ proxy = (ArithmeticCalculator) Proxy.newProxyInstance(loader, interfaces, h); return proxy; &#125;&#125; （实现 InvocationHandler 接口的方式实现（推荐）） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 动态代理类的实现：InvocationHandler接口（invoke方法）+Proxy类（newProxyInstance方法） */public class ArithmeticCalculatorLoggingProxy implements InvocationHandler &#123; //要代理的对象 private ArithmeticCalculator target; public ArithmeticCalculatorLoggingProxy(ArithmeticCalculator target) &#123;// super(); this.target = target; &#125; //返回代理对象 public ArithmeticCalculator getLoggingProxy() &#123; ArithmeticCalculator proxy = null; ClassLoader loader = target.getClass().getClassLoader(); Class[] interfaces = new Class[]&#123;ArithmeticCalculator.class&#125;;// /** * Proxy 类： * loader: 代理对象使用的类加载器。 * interfaces: 指定被代理对象的一组接口. 即被代理对象实现了哪些接口。指定后该代理对象实例就会实现被代理对象接口的所有方法。 * h: 当具体调用代理对象的方法时, 应该如何进行响应, 实际上就是调用 InvocationHandler 的 invoke 方法 */ proxy = (ArithmeticCalculator) Proxy.newProxyInstance(loader, interfaces, new ArithmeticCalculatorLoggingProxy(target));//h:参数，该类实现了此接口有继承关系。System.out.println("代理对象实例："+proxy.getClass().getName());//代理对象实例 return proxy; &#125; /** * proxy: 代理对象。 一般不使用该对象 * method: 正在被调用的方法 * args: 调用方法传入的参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); //打印日志 System.out.println("[before] The method " + methodName + " begins with " + Arrays.asList(args)); //调用目标方法 Object result = null; try &#123; //前置通知 result = method.invoke(target, args);//返回通知, 可以访问到方法的返回值 &#125; catch (NullPointerException e) &#123; e.printStackTrace();//异常通知, 可以访问到方法出现的异常 &#125; //后置通知. 因为方法可以能会出异常, 所以访问不到方法的返回值 //打印日志 System.out.println("[after] The method ends with " + result); return result; &#125; 1-3、动态代理原理分析 1、Java 动态代理创建出来的动态代理类。上面我们利用Proxy类的newProxyInstance方法创建了一个动态代理对象，查看该方法的源码，发现它只是封装了创建动态代理类的步骤(红色标准部分)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * Look up or generate the designated proxy class. */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125; 其实，我们最应该关注的是 Class&lt;?&gt; cl = getProxyClass0(loader, intfs);这句，这里产生了代理类，后面代码中的构造器也是通过这里产生的类来获得，可以看出，这个类的产生就是整个动态代理的关键，由于是动态生成的类文件，我这里不具体进入分析如何产生的这个类文件，只需要知道这个类文件时缓存在java虚拟机中的，我们可以通过下面的方法将其打印到文件里面，一睹真容： 1234567891011private void generateProxyClass() &#123; byte[] classFile = ProxyGenerator.generateProxyClass("$Proxy4", ArithmeticCalculatorImpl.class.getInterfaces()); String path = "E:\\PersonWorkSpace\\JavaEESpace\\spring-2\\src\\com\\atguigu\\spring\\dynamicProxy\\ArithmeticCalculatorImpl.class"; try(FileOutputStream fos = new FileOutputStream(path)) &#123; fos.write(classFile); fos.flush(); System.out.println("代理类class文件写入成功"); &#125; catch (Exception e) &#123; System.out.println("写文件错误"); &#125; &#125; 对这个class文件进行反编译，我们看看jdk为我们生成了什么样的内容：生成的代理类 实现了被代理类的接口。代理类调用接口方法时，会利用反射转发到invoke 去调用方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public final class $Proxy4 extends Proxy implements ArithmeticCalculator &#123; private static Method m1; private static Method m2; private static Method m6; private static Method m3; private static Method m5; private static Method m4; private static Method m0; public $Proxy4(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int mul(int var1, int var2) throws &#123; try &#123; return (Integer)super.h.invoke(this, m6, new Object[]&#123;var1, var2&#125;); &#125; catch (RuntimeException | Error var4) &#123; throw var4; &#125; catch (Throwable var5) &#123; throw new UndeclaredThrowableException(var5); &#125; &#125; public final int add(int var1, int var2) throws &#123; try &#123; return (Integer)super.h.invoke(this, m3, new Object[]&#123;var1, var2&#125;);//该代理类调用方法时转发到 invoke 方法反射调用。 &#125; catch (RuntimeException | Error var4) &#123; throw var4; &#125; catch (Throwable var5) &#123; throw new UndeclaredThrowableException(var5); &#125; &#125; public final int sub(int var1, int var2) throws &#123; try &#123; return (Integer)super.h.invoke(this, m5, new Object[]&#123;var1, var2&#125;); &#125; catch (RuntimeException | Error var4) &#123; throw var4; &#125; catch (Throwable var5) &#123; throw new UndeclaredThrowableException(var5); &#125; &#125; public final int div(int var1, int var2) throws &#123; try &#123; return (Integer)super.h.invoke(this, m4, new Object[]&#123;var1, var2&#125;); &#125; catch (RuntimeException | Error var4) &#123; throw var4; &#125; catch (Throwable var5) &#123; throw new UndeclaredThrowableException(var5); &#125; &#125; public final int hashCode() throws &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object")); m2 = Class.forName("java.lang.Object").getMethod("toString"); m6 = Class.forName("com.atguigu.spring.dynamicProxy.ArithmeticCalculator").getMethod("mul", Integer.TYPE, Integer.TYPE); m3 = Class.forName("com.atguigu.spring.dynamicProxy.ArithmeticCalculator").getMethod("add", Integer.TYPE, Integer.TYPE); m5 = Class.forName("com.atguigu.spring.dynamicProxy.ArithmeticCalculator").getMethod("sub", Integer.TYPE, Integer.TYPE); m4 = Class.forName("com.atguigu.spring.dynamicProxy.ArithmeticCalculator").getMethod("div", Integer.TYPE, Integer.TYPE); m0 = Class.forName("java.lang.Object").getMethod("hashCode"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 参考博客：https://www.cnblogs.com/gonjan-blog/p/6685611.html。http://www.cnblogs.com/xiaoluo501395377/p/3383130.html。 1-4、总结生成的代理类：$Proxy0 extends Proxy implements Person，我们看到代理类继承了Proxy类，所以也就决定了java动态代理只能对接口进行代理，Java的继承机制注定了这些动态代理类们无法实现对class的动态代理。上面的动态代理的例子，其实就是AOP的一个简单实现了，在目标对象的方法执行之前和执行之后进行了处理，对方法耗时统计。Spring的AOP实现其实也是用了Proxy和InvocationHandler这两个东西的。 2、AOP 简介 1、AOP(Aspect-Oriented Programming, 面向切面编程)。 2、AOP 的主要编程对象是切面(aspect), 而切面模块化横切关注点。 3、在应用 AOP 编程时, 仍然需要定义公共功能, 但可以明确的定义这个功能在哪里, 以什么方式应用, 并且不必修改受影响的类. 这样一来横切关注点就被模块化到特殊的对象(切面)里。 4、AOP 的好处:每个事物逻辑位于一个位置, 代码不分散, 便于维护和升级业务模块更简洁, 只包含核心业务代码 3、AOP 术语3-1、切面(Aspect)切面就是横切面，代表的是一个普遍存在的共有功能。例如，日志、验证、统计成员方法运行时间。都可作为一个切面来处理。例：代理对象$proxy0 已经将日志切面与业务逻辑add 方法进行了合成。（先调invoke 打印日志，再反射调用 add 方法。） 3-2、通知 (Advice)切面要完成的工作，例如：日志切面要完成打印日志的任务，则通知即是打印日志。前置通知在 add 方法反射执行前打印日志，后置通知在 add 方法反射执行后打印通知。 五种类型的通知注解@Before: 前置通知, 在方法执行之前执行。@After: 后置通知, 在方法执行之后执行 。@AfterRunning: 返回通知, 在方法返回结果之后执行。@AfterThrowing: 异常通知, 在方法抛出异常之后。@Around: 环绕通知, 围绕着方法执行。 3-3、目标 (Target)3-4、代理 (Proxy)3-5、连接点（Joinpoint）程序执行的某个特定位置：如类某个方法调用前、调用后、方法抛出异常后等。例如 ArithmethicCalculator#add()方法。 3-6、切点（pointcut）每个类都拥有多个连接点：例如 ArithmethicCalculator 的所有方法实际上都是连接点。AOP 通过切点定位到特定的连接点。切点即指类和方法。AOP 使用类和方法作为连接点的查询条件。定位连接点。 4、在Spring 中启用 AspectJ AOP框架。 1、要在 Spring 应用中使用 AspectJ 注解, 必须在 classpath 下包含 AspectJ 类库: aopalliance.jar、aspectj.weaver.jar 和 spring-aspects.jar 2、将 aop Schema 添加到 根元素中. 3、要在 Spring IOC 容器中启用 AspectJ 注解支持, 只要在 Bean 配置文件中定义一个空的 XML 元素 &lt; aop:aspectj-autoproxy &gt; 4、当 Spring IOC 容器侦测到 Bean 配置文件中的 &lt; aop:aspectj-autoproxy&gt; 元素时, 会自动为与 AspectJ 切面匹配的 Bean 创建代理。 4-1、用 AspectJ 注解声明切面 1、要在 Spring 中声明 AspectJ 切面, 只需要在 IOC 容器中将切面声明为 Bean 实例. 当在 Spring IOC 容器中初始化 AspectJ 切面之后, Spring IOC 容器就会为那些与 AspectJ 切面相匹配的 Bean 创建代理.。 2、在 AspectJ 注解中, 切面只是一个带有 @Aspect 注解的 Java 类. 。 3、通知是标注有某种注解的简单的 Java 方法.。 4、AspectJ 支持 5 种类型的通知注解:@Before: 前置通知, 在方法执行之前执行。@After: 后置通知, 在方法执行之后执行 。@AfterRunning: 返回通知, 在方法返回结果之后执行。@AfterThrowing: 异常通知, 在方法抛出异常之后。@Around: 环绕通知, 围绕着方法执行。 4-2、前置通知利用方法签名编写 AspectJ 切入点表达式 方法签名：方法签名由方法名称和一个参数列表（方法的参数的顺序和类型）组成；注意，方法签名不包括方法的返回类型。不包括返回值和访问修饰符 切点表达式： 合并切点表达式 让通知访问当前连接点的细节 4-3、后置通知 4-4、返回通知 返回通知中访问连接点的返回值 4-5、异常通知 4-6、环绕通知 4-7、指定切面的优先级 4-8、重用切入点定义见 合并切入点 4-9、引入通知引入通知是一种特殊的通知类型. 它通过为接口提供实现类, 允许对象动态地实现接口, 就像对象已经在运行时扩展了实现类一样 4-10、用XML 声明切面、切点、通知（包括引入通知） 5、Spring 对JDBC 的支持5-1、Spring xml 中配置 JDBC 模板类和 c3p0 数据源org.springframework.jdbc.core.JdbcTemplate 12345678910111213141516171819202122&lt;context:component-scan base-package="com.atguigu.spring"&gt;&lt;/context:component-scan&gt; &lt;!-- 导入资源文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!-- 配置 C3P0 数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="initialPoolSize" value="$&#123;jdbc.initPoolSize&#125;"&gt;&lt;/property&gt; &lt;property name="maxPoolSize" value="$&#123;jdbc.maxPoolSize&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 Spirng 的 JdbcTemplate --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; 5-2、jdbcTemplate 模板方法测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class JDBCTest &#123; private ApplicationContext ctx = null; private JdbcTemplate jdbcTemplate; private EmployeeDao employeeDao; private DepartmentDao departmentDao; private NamedParameterJdbcTemplate namedParameterJdbcTemplate; &#123; ctx = new ClassPathXmlApplicationContext("applicationContext.xml"); jdbcTemplate = (JdbcTemplate) ctx.getBean("jdbcTemplate"); employeeDao = ctx.getBean(EmployeeDao.class); departmentDao = ctx.getBean(DepartmentDao.class); namedParameterJdbcTemplate = ctx.getBean(NamedParameterJdbcTemplate.class); &#125; /** * 获取单个列的值, 或做统计查询 * 使用 queryForObject(String sql, Class&lt;Long&gt; requiredType) */ @Test public void testQueryForObject2()&#123; String sql = "SELECT count(id) FROM employees"; long count = jdbcTemplate.queryForObject(sql, Long.class); System.out.println(count); &#125; /** * 查到实体类的集合 * 注意调用的不是 queryForList 方法 */ @Test public void testQueryForList()&#123; String sql = "SELECT id, last_name lastName, email FROM employees WHERE id &gt; ?"; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(Employee.class); List&lt;Employee&gt; employees = jdbcTemplate.query(sql, rowMapper,5); System.out.println(employees); &#125; /** * 从数据库中获取一条记录, 实际得到对应的一个对象 * 注意不是调用 queryForObject(String sql, Class&lt;Employee&gt; requiredType, Object... args) 方法! * 而需要调用 queryForObject(String sql, RowMapper&lt;Employee&gt; rowMapper, Object... args) * 1. 其中的 RowMapper 指定如何去映射结果集的行, 常用的实现类为 BeanPropertyRowMapper * 2. 使用 SQL 中列的别名完成列名和类的属性名的映射. 例如 last_name lastName * 3. 不支持级联属性. JdbcTemplate 到底是一个 JDBC 的小工具, 而不是 ORM 框架 */ @Test public void testQueryForObject()&#123; String sql = "SELECT id, last_name lastName, email, dept_id as \"department.id\" FROM employees WHERE id = ?"; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(Employee.class); Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, 1); System.out.println(employee); &#125; /** * 执行批量更新: 批量的 INSERT, UPDATE, DELETE * 最后一个参数是 Object[] 的 List 类型: 因为修改一条记录需要一个 Object 的数组, 那么多条不就需要多个 Object 的数组吗 */ @Test public void testBatchUpdate()&#123; String sql = "INSERT INTO employees(last_name, email, dept_id) VALUES(?,?,?)"; List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;(); batchArgs.add(new Object[]&#123;"AA", "aa@atguigu.com", 1&#125;); batchArgs.add(new Object[]&#123;"BB", "bb@atguigu.com", 2&#125;); batchArgs.add(new Object[]&#123;"CC", "cc@atguigu.com", 3&#125;); batchArgs.add(new Object[]&#123;"DD", "dd@atguigu.com", 3&#125;); batchArgs.add(new Object[]&#123;"EE", "ee@atguigu.com", 2&#125;); jdbcTemplate.batchUpdate(sql, batchArgs); &#125; /** * 执行 INSERT, UPDATE, DELETE */ @Test public void testUpdate()&#123; String sql = "UPDATE employees SET last_name = ? WHERE id = ?"; jdbcTemplate.update(sql, "Jack", 5); &#125; @Test public void testDataSource() throws SQLException &#123; DataSource dataSource = ctx.getBean(DataSource.class); System.out.println(dataSource.getConnection()); &#125; &#125; 5-3、NamedParameterJdbcTemplate 具名参数模板类。12345&lt;!-- 配置 NamedParameterJdbcTemplate, 该对象可以使用具名参数, 其没有无参数的构造器, 所以必须为其构造器指定参数 --&gt; &lt;bean id="namedParameterJdbcTemplate" class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate"&gt; &lt;constructor-arg ref="dataSource"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 测试 1234567891011121314151617181920212223242526272829303132333435/** * 使用具名参数时, 可以使用 update(String sql, SqlParameterSource paramSource) 方法进行更新操作 * 1. SQL 语句中的参数名和类的属性一致! * 2. 使用 SqlParameterSource 的 BeanPropertySqlParameterSource 实现类作为参数. */@Testpublic void testNamedParameterJdbcTemplate2()&#123; String sql = "INSERT INTO employees(last_name, email, dept_id) " + "VALUES(:lastName,:email,:dpetId)"; Employee employee = new Employee(); employee.setLastName("XYZ"); employee.setEmail("xyz@sina.com"); employee.setDpetId(3); SqlParameterSource paramSource = new BeanPropertySqlParameterSource(employee); namedParameterJdbcTemplate.update(sql, paramSource);&#125;/** * 可以为参数起名字. * 1. 好处: 若有多个参数, 则不用再去对应位置, 直接对应参数名, 便于维护 * 2. 缺点: 较为麻烦. */@Testpublic void testNamedParameterJdbcTemplate()&#123; String sql = "INSERT INTO employees(last_name, email, dept_id) VALUES(:ln,:email,:deptid)"; Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(); paramMap.put("ln", "FF"); paramMap.put("email", "ff@atguigu.com"); paramMap.put("deptid", 2); namedParameterJdbcTemplate.update(sql, paramMap);&#125; 6、Spring 对事务的管理6-1、声明式事务 1、编程式事务管理将事务管理代码嵌入到业务方法中来控制事务的提交和回滚。（正常方式） -2、声明式事务管理将事务管理代码从业务方法中分离出来, 以声明的方式来实现事务管理。Spring 通过 Spring AOP 框架支持声明式事务管理。通过使用注解+配置事务管理器。 6-2、事务的传播行为6-3、事务的隔离级别]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-3--IOC&DI]]></title>
    <url>%2F2019%2F03%2F25%2FSpring-3--IOC%26DI%2F</url>
    <content type="text"><![CDATA[[toc] 1、IOC&amp;DI 概述1-1、IOC-控制反转IOC(Inversion of Control)：其思想是反转资源获取的方向. 传统的资源查找方式要求组件向容器发起请求查找资源. 作为回应, 容器适时的返回资源. 而应用了 IOC 之后, 则是容器主动地将资源推送给它所管理的组件, 组件所要做的仅是选择一种合适的方式来接受资源. 这种行为也被称为查找的被动形式。 1-2、DI-依赖注入DI(Dependency Injection) — IOC 的另一种表述方式：即组件以一些预先定义好的方式(例如: setter 方法)接受来自如容器的资源注入. 相对于 IOC 而言，这种表述更直接。 1-3、在 Spring IOC 容器中配置 Bean 1、在 Spring IOC 容器读取 Bean 配置创建 Bean 实例之前, 必须对它进行实例化. 只有在容器实例化后, 才可以从 IOC 容器里获取 Bean 实例并使用。 2、Spring 提供了两种类型的 IOC 容器实现。 BeanFactory: IOC 容器的基本实现： ApplicationContext: 提供了更多的高级特性. 是 BeanFactory 的子接口。 2、配置 Bean2-1、配置形式 基于 XML 文件的配置方式 基于注解的方式（实际开发中主要使用该方式） 2-2、Bean 的配置方式 通过全类名（反射） 通过工厂方法（静态工厂方法&amp;实例工厂方法） FactoryBean 2-3、IOC 容器 BeanFactory &amp; ApplicationContext 概述 BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；ApplicationContext 面向使用 Spring 框架的开发者，几乎所有的应用场合都直接使用 ApplicationContext 而非底层的 BeanFactory ApplicationContext 接口 123456789ApplicationContext 的主要实现类： ClassPathXmlApplicationContext：从 类路径下加载配置文件 FileSystemXmlApplicationContext: 从文件系统中加载配置文件 ConfigurableApplicationContext 扩展于 ApplicationContext，新增加两个主要方法：refresh() 和 close()， 让 ApplicationContext 具有启动、刷新和关闭上下文的能力。ApplicationContext 在初始化上下文时就实例化所有单例的 Bean。WebApplicationContext 是专门为 WEB 应用而准备的，它允许从相对于 WEB 根目录的路径中完成初始化工作。 从容器中 获取 Bean 2-4、依赖注入的方式 属性注入（注入细节） 字面值 引用其他 Bean 内部Bean 注入参数：（null 值和级联属性） 集合属性&amp; utility scheme 定义集合 使用 P 命名空间 构造器注入 泛型依赖注入 1、Beanscom.atguigu.spring.helloworld.HelloWorldcom.atguigu.spring.ref.Daocom.atguigu.spring.ref.Service 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.atguigu.spring.helloworld;public class HelloWorld &#123; private String user; public HelloWorld() &#123; System.out.println("HelloWorld's constructor..."); &#125; public HelloWorld(String user) &#123; this.user = user; &#125; public void setUser(String user) &#123; System.out.println("setUser:" + user); this.user = user; &#125; public void hello()&#123; System.out.println("Hello: " + user); &#125; &#125;package com.atguigu.spring.ref;public class Dao &#123; private String dataSource = "dbcp"; public void setDataSource(String dataSource) &#123; this.dataSource = dataSource; &#125; public void save()&#123; System.out.println("save by " + dataSource); &#125; public Dao() &#123; System.out.println("Dao's Constructor..."); &#125; public String toString()&#123; return "[dataSource]:"+dataSource; &#125; &#125;package com.atguigu.spring.ref;public class Service &#123; private Dao dao; public void setDao(Dao dao) &#123; this.dao = dao; &#125; public Dao getDao() &#123; return dao; &#125; public void save()&#123; System.out.println("Service's save"); dao.save(); &#125; &#125; 2、Spring xml配置Beans 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 1、属性注入：配置一个 bean 通过 setter 方法 为属性赋值 --&gt; &lt;bean id="helloWorld1" class="com.atguigu.spring.helloworld.HelloWorld"&gt; &lt;property name="user" value="Jerry"/&gt;&lt;!-- 为属性赋值 --&gt; &lt;/bean&gt; &lt;!-- 2、构造器注入：通过构造器注入属性值 --&gt; &lt;bean id="helloWorld3" class="com.atguigu.spring.helloworld.HelloWorld"&gt; &lt;constructor-arg value="Mike"/&gt;&lt;!-- 要求: 在 Bean 中必须有对应的构造器. --&gt; &lt;/bean&gt; &lt;!-- 2-1、若一个 bean 有多个构造器, 如何通过构造器来为 bean 的属性赋值 --&gt; &lt;!-- 可以根据 index 和 value 进行更加精确的定位. (了解) --&gt; &lt;bean id="car" class="com.atguigu.spring.helloworld.Car"&gt; &lt;constructor-arg value="KUGA" index="1"/&gt; &lt;constructor-arg value="ChangAnFord" index="0"/&gt; &lt;constructor-arg value="250000" type="float"/&gt; &lt;/bean&gt; &lt;!--3、属性注入细节：字面值--&gt; &lt;bean id="car2" class="com.atguigu.spring.helloworld.Car"&gt; &lt;constructor-arg value="ChangAnMazda"/&gt; &lt;constructor-arg&gt; &lt;value&gt;&lt;![CDATA[&lt;ATARZA&gt;]]&gt;&lt;/value&gt;&lt;!-- 若字面值中包含特殊字符, 则可以使用 CDATA 来进行赋值. (了解) --&gt; &lt;/constructor-arg&gt; &lt;constructor-arg value="180" type="int"/&gt; &lt;/bean&gt; &lt;!-- 4、属性注入细节：引用其他 bean 配置 --&gt; &lt;bean id="dao5" class="com.atguigu.spring.ref.Dao"/&gt; &lt;bean id="service" class="com.atguigu.spring.ref.Service"&gt; &lt;property name="dao" ref="dao5"/&gt;&lt;!-- 通过 ref 属性值指定当前属性指向哪一个 bean! --&gt; &lt;/bean&gt; &lt;!-- 5、属性注入细节：声明使用内部 bean --&gt; &lt;bean id="service2" class="com.atguigu.spring.ref.Service"&gt; &lt;property name="dao"&gt; &lt;bean class="com.atguigu.spring.ref.Dao"&gt;&lt;!-- 内部 bean, 类似于匿名内部类对象. 不能被外部的 bean 来引用, 也没有必要设置 id 属性 --&gt; &lt;property name="dataSource" value="c3p0"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--6、属性注入细节：注入参数之级联属性--&gt; &lt;bean id="action" class="com.atguigu.spring.ref.Action"&gt; &lt;property name="service" ref="service2"/&gt; &lt;property name="service.dao.dataSource" value="DBCP2"/&gt;&lt;!-- 设置级联属性(了解) --&gt; &lt;/bean&gt; &lt;bean id="dao2" class="com.atguigu.spring.ref.Dao"&gt; &lt;property name="dataSource"&gt; &lt;null/&gt; &lt;/property&gt;&lt;!-- 为 Dao 的 dataSource 属性赋值为 null, 若某一个 bean 的属性值不是 null, 使用时需要为其设置为 null(了解) --&gt; &lt;/bean&gt; &lt;!-- 7、属性注入细节：装配集合属性 --&gt; &lt;bean id="user" class="com.atguigu.spring.helloworld.User"&gt; &lt;property name="userName" value="Jack"/&gt; &lt;property name="cars"&gt; &lt;list&gt;&lt;!-- 使用 list 元素来装配集合属性 --&gt; &lt;ref bean="car"/&gt; &lt;ref bean="car2"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 7-1、声明集合类型的 bean --&gt; &lt;util:list id="cars"&gt; &lt;ref bean="car"/&gt; &lt;ref bean="car2"/&gt; &lt;/util:list&gt; &lt;!--7-2、引用外部声明的集合--&gt; &lt;bean id="user2" class="com.atguigu.spring.helloworld.User"&gt; &lt;property name="userName" value="Rose"/&gt; &lt;property name="cars" ref="cars"/&gt;&lt;!-- 引用外部声明的 list --&gt; &lt;/bean&gt; &lt;!--8、属性注入细节：定义 P 命名空间--&gt; &lt;bean id="user3" class="com.atguigu.spring.helloworld.User" p:cars-ref="cars" p:userName="Titannic"/&gt; &lt;!-- bean 的配置能够继承吗 ? 使用 parent 来完成继承 --&gt; &lt;bean id="user4" parent="user" p:userName="Bob"/&gt; &lt;bean id="user6" parent="user" p:userName="维多利亚"/&gt; &lt;!-- 测试 depents-on --&gt; &lt;bean id="user5" parent="user" p:userName="Backham" depends-on="user6"/&gt;&lt;/beans&gt; 3、测试 Main 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.atguigu.spring.helloworld;import com.atguigu.spring.ref.*;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; /*测试未使用Spring 前对象的实例化操作*/ HelloWorld helloWorld = new HelloWorld(); helloWorld.setUser("Tom"); helloWorld.hello(); /* 测试使用 Spring 容器 后 对象实例化的操作*/ ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");//创建 Spring 的 IOC 容器 //1、测试 通过 setter 方法注入属性值 HelloWorld helloWorld1= (HelloWorld) ctx.getBean("helloWorld1"); helloWorld1.hello(); //根据类型来获取 bean 的实例: 要求在 IOC 容器中只有一个与之类型匹配的 bean, 若有多个则会抛出异常. // 一般情况下, 该方法可用, 因为一般情况下, 在一个 IOC 容器中一个类型对应的 bean 也只有一个. //HelloWorld helloWorld1 = ctx.getBean(HelloWorld.class); // 2、测试通过构造器为属性赋值 HelloWorld helloWorld3 = (HelloWorld)ctx.getBean("helloWorld3"); helloWorld3.hello(); /* 2-1、测试 bean 有多个构造器, 如何通过构造器来为 bean 的属性赋值*/ Car car = (Car) ctx.getBean("car"); System.out.println(car);//Car [company=ChangAnFord, brand=KUGA, maxSpeed=0, price=250000.0] /*3、属性注入细节：字面值*/ Car car2= (Car) ctx.getBean("car2"); System.out.println(car2);//Car [company=ChangAnMazda, brand=&lt;ATARZA&gt;, maxSpeed=180, price=0.0] //4. 属性注入细节：引用其他 Bean+级联属性设置 Service service2= (Service) ctx.getBean("service2"); System.out.print("service2:"+service2.getDao().toString());//由于级联属性的设置，输出结果为：[dataSource]:DBCP2 //7、属性注入细节：装配集合属性 &#125; &#125; 2-5、自动装配 XML 配置里的 Bean 自动装配。 XML 配置里的 Bean 自动装配的缺点。 123456789&lt;!-- 1、自动装配: 只声明 bean, 而把 bean 之间的关系交给 IOC 容器来完成 --&gt; &lt;!-- byType: 根据类型进行自动装配. 但要求 IOC 容器中只有一个类型对应的 bean, 若有多个则无法完成自动装配. byName: 若属性名和某一个 bean 的 id 名一致, 即可完成自动装配. 若没有 id 一致的, 则无法完成自动装配 --&gt; &lt;!-- 在使用 XML 配置时, 自动装配用的不多. 但在基于 注解 的配置时, 自动装配使用的较多. --&gt; &lt;bean id="dao" class="com.atguigu.spring.ref.Dao"&gt; &lt;property name="dataSource" value="C3P0"&gt;&lt;/property&gt; &lt;/bean&gt; 注：实际项目中很少使用xml方式的自动装配，在基于 注解 的配置时, 自动装配使用的较多，此处XML 配置方式的自动装配仅做了解。 2-6、Bean 之间的关系 继承 123456Spring 允许继承 bean 的配置, 被继承的 bean 称为父 bean. 继承这个父 Bean 的 Bean 称为子 Bean子 Bean 从父 Bean 中继承配置, 包括 Bean 的属性配置子 Bean 也可以覆盖从父 Bean 继承过来的配置父 Bean 可以作为配置模板, 也可以作为 Bean 实例. 若只想把父 Bean 作为模板, 可以设置 &lt;bean&gt; 的abstract 属性为 true, 这样 Spring 将不会实例化这个 Bean并不是 &lt;bean&gt; 元素里的所有属性都会被继承. 比如: autowire, abstract 等.也可以忽略父 Bean 的 class 属性, 让子 Bean 指定自己的类, 而共享相同的属性配置. 但此时 abstract 必须设为 true 依赖 12Spring 允许用户通过 depends-on 属性设定 Bean 前置依赖的Bean，前置依赖的 Bean 会在本 Bean 实例化之前创建好如果前置依赖于多个 Bean，则可以通过逗号，空格或的方式配置 Bean 的名称 2-7、Bean 的作用域在 Spring 中, 可以在 元素的 scope 属性里设置 Bean 的作用域。 singleton &amp; prototype beans-auto.xml123456789101112131415161718192021&lt;!-- 1、自动装配: 只声明 bean, 而把 bean 之间的关系交给 IOC 容器来完成 --&gt;&lt;!-- byType: 根据类型进行自动装配. 但要求 IOC 容器中只有一个类型对应的 bean, 若有多个则无法完成自动装配. byName: 若属性名和某一个 bean 的 id 名一致, 即可完成自动装配. 若没有 id 一致的, 则无法完成自动装配--&gt;&lt;!-- 在使用 XML 配置时, 自动装配用的不多. 但在基于 注解 的配置时, 自动装配使用的较多. --&gt;&lt;bean id="dao" class="com.atguigu.spring.ref.Dao"&gt; &lt;property name="dataSource" value="C3P0"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 2、默认情况下 bean 是单例的! 即为 singleton--&gt;&lt;!-- 但有的时候, bean 就不能使单例的. 例如: Struts2 的 Action 就不是单例的! 可以通过 scope 属性来指定 bean 的作用域 --&gt;&lt;!-- prototype: 原型的. 每次调用 getBean 方法都会返回一个新的 bean. 且在第一次调用 getBean 方法时才创建实例 singleton: 单例的. 每次调用 getBean 方法都会返回同一个 bean. 且在 IOC 容器初始化时即创建 bean 的实例. 默认值 --&gt;&lt;bean id="dao2" class="com.atguigu.spring.ref.Dao" scope="prototype"&gt;&lt;/bean&gt;&lt;bean id="service" class="com.atguigu.spring.ref.Service" autowire="byName"&gt;&lt;/bean&gt;&lt;bean id="action" class="com.atguigu.spring.ref.Action" autowire="byType"&gt;&lt;/bean&gt; 测试 Main 12345678ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("beans-auto.xml"); //测试 bean 的作用域Dao dao1 = (Dao) ctx.getBean("dao2");Dao dao2 = (Dao) ctx.getBean("dao2");System.out.println(dao1 == dao2);//false 非单例 Bean WEB 环境作用域 2-8、使用外部属性文件 在配置文件里配置 Bean 时, 有时需要在 Bean 的配置里混入系统部署的细节信息(例如: 文件路径, 数据源配置信息等). 而这些部署细节实际上需要和 Bean 配置相分离。 Spring 提供了一个 PropertyPlaceholderConfigurer 的 BeanFactory 后置处理器, 这个处理器允许用户将 Bean 配置的部分内容外移到属性文件中. 可以在 Bean 配置文件里使用形式为 ${var} 的变量, PropertyPlaceholderConfigurer 从属性文件里加载属性, 并使用这些属性来替换变量. Spring 还允许在属性文件中使用 ${propName}，以实现属性之间的相互引用。 Spring 2.5 之后不要再配置 PropertyPlaceholderConfigurer 类，简化为：123456789101112131415``` xml&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;&lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.jdbcUrl&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot; value=&quot;$&#123;jdbc.initPoolSize&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;$&#123;jdbc.maxPoolSize&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 测试 Main 12345ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("beans-auto.xml");//测试使用外部属性文件DataSource dataSource = (DataSource) ctx.getBean("dataSource");System.out.println(dataSource.getConnection()); 2-9、SpEL（Spring 表达式语言） SpEL 简介 Spring 表达式语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。 语法类似于 EL：SpEL 使用 #{…} 作为定界符，所有在大框号中的字符都将被认为是 SpEL。 SpEL 为 bean 的属性进行动态赋值提供了便利。 通过 SpEL 可以实现： 通过 bean 的 id 对 bean 进行引用。 调用方法以及引用对象中的属性。 计算表达式的值。 正则表达式的匹配。 SpEL：字面量 SpEL：引用 Bean、属性和方法 SpEL 支持的运算符号 动态赋值123456789&lt;!-- 4、测试 SpEL: 可以为属性进行动态的赋值(了解) --&gt; &lt;bean id="girl" class="com.atguigu.spring.helloworld.User"&gt; &lt;property name="userName" value="周迅"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="boy" class="com.atguigu.spring.helloworld.User" init-method="init" destroy-method="destroy"&gt;&lt;!--User 类中定义了init、destroy方法--&gt; &lt;property name="userName" value="高胜远"&gt;&lt;/property&gt; &lt;property name="wifeName" value="#&#123;girl.userName&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; 测试 main 1234ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("beans-auto.xml");//测试 spELUser boy = (User) ctx.getBean("boy");System.out.println(boy.getUserName() + ":" + boy.getWifeName()); 2-10、IOC 容器中 Bean 的生命周期 1、Spring 配置 Bean 的后置通知 12&lt;!-- 5、配置 bean 后置处理器: 不需要配置 id 属性, IOC 容器会识别到他是一个 bean 后置处理器, 并调用其方法 --&gt; &lt;bean class="com.atguigu.spring.ref.MyBeanPostProcessor"&gt;&lt;/bean&gt; Bean 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.spring.ref;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;import com.atguigu.spring.helloworld.User;public class MyBeanPostProcessor implements BeanPostProcessor &#123; //该方法在 init 方法之后被调用 @Override public Object postProcessAfterInitialization(Object arg0, String arg1) throws BeansException &#123; if(arg1.equals("boy"))&#123; System.out.println("postProcessAfterInitialization..." + arg0 + "," + arg1); User user = (User) arg0; user.setUserName("李大齐"); &#125; return arg0; &#125; //该方法在 init 方法之前被调用 //可以工作返回的对象来决定最终返回给 getBean 方法的对象是哪一个, 属性值是什么 /** * @param arg0: 实际要返回的对象 * @param arg1: bean 的 id 值 */ @Override public Object postProcessBeforeInitialization(Object arg0, String arg1) throws BeansException &#123; if(arg1.equals("boy")) System.out.println("postProcessBeforeInitialization..." + arg0 + "," + arg1); return arg0; &#125;&#125; 测试 Main1234ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("beans-auto.xml");//测试 spELUser boy = (User) ctx.getBean("boy");System.out.println(boy.getUserName() + ":" + boy.getWifeName()); 2、Spring IOC 容器对 Bean 的生命周期进行管理的过程: 1234567通过构造器或工厂方法创建 Bean 实例。为 Bean 的属性设置值和对其他 Bean 的引用。将 Bean 实例传递给 Bean 后置处理器的 postProcessBeforeInitialization 方法。调用 Bean 的初始化方法。将 Bean 实例传递给 Bean 后置处理器的 postProcessAfterInitialization方法。Bean 可以使用了。当容器关闭时, 调用 Bean 的销毁方法。 3、工厂方法&amp;FactroyBean 方式配置 Bean beans-auto.xml12345678910111213141516171819202122&lt;!-- 6、通过工厂方法的方式来配置 bean --&gt; &lt;!-- 6-1. 通过静态工厂方法: 一个类中有一个静态方法, 可以返回一个类的实例(了解) --&gt; &lt;!-- 在 class 中指定静态工厂方法的全类名, 在 factory-method 中指定静态工厂方法的方法名 --&gt; &lt;bean id="dateFormat" class="java.text.DateFormat" factory-method="getDateInstance"&gt; &lt;constructor-arg value="2"&gt;&lt;/constructor-arg&gt;&lt;!-- 可以通过 constructor-arg 子节点为静态工厂方法指定参数 --&gt; &lt;/bean&gt; &lt;!-- 6-2. 实例工厂方法: 先需要创建工厂对象, 再调用工厂的非静态方法返回实例(了解) --&gt; &lt;!-- ①. 创建工厂对应的 bean --&gt; &lt;bean id="simpleDateFormat" class="java.text.SimpleDateFormat"&gt; &lt;constructor-arg value="yyyy-MM-dd hh:mm:ss"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- ②. 有实例工厂方法来创建 bean 实例 --&gt; &lt;!-- factory-bean 指向工厂 bean, factory-method 指定工厂方法(了解) --&gt; &lt;bean id="datetime" factory-bean="simpleDateFormat" factory-method="parse"&gt; &lt;!-- 通过 constructor-arg 执行调用工厂方法需要传入的参数 --&gt; &lt;constructor-arg value="1990-12-12 12:12:12"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 7、配置通过 FactroyBean 的方式来创建 bean 的实例(了解) --&gt; &lt;bean id="user" class="com.atguigu.spring.ref.UserBean"&gt;&lt;/bean&gt; 测试 Main 1234567891011121314//测试工厂方法配置 Bean// DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.FULL);DateFormat dateFormat = (DateFormat) ctx.getBean("dateFormat");System.out.println(dateFormat.format(new Date()));Date date = (Date) ctx.getBean("datetime");System.out.println(date);//测试通过 FactroyBean 来配置 BeanUser user = (User) ctx.getBean("user");System.out.println(user);ctx.close(); 2-11、Spring4.x 新特性 泛型依赖注入 2-12、整合多个配置文件]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-2--开发环境搭建]]></title>
    <url>%2F2019%2F03%2F25%2FSpring-2--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[[toc] 1、Spring 框架的核心jar 包除此之外，还有其他一些 jar 包。 2、Spring 的 HelloWorld 1、引入jar 包 2、编写 com.ppjuice.helloworld.HelloWorld 类 123456789101112131415161718192021222324package com.ppjuice.helloworld;public class HelloWorld &#123; private String username; public void setUsername(String username) &#123; this.username = username; &#125; /** * 成员方法 */ public void hello() &#123; System.out.println("This is hello...."); &#125; /** * 空参构造器 */ public HelloWorld() &#123; // TODO Auto-generated constructor stub &#125;&#125; 3、配置 ApplicationContext .xml 文件]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-1--什么是Spring？]]></title>
    <url>%2F2019%2F03%2F25%2FSpring-1--%E4%BB%80%E4%B9%88%E6%98%AFSpring%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[[toc] 1、什么是 Spring？ Spring 是一个 IOC(DI) 和 AOP 容器框架，开源框架。 轻量级：Spring 是非侵入性的 - 基于 Spring 开发的应用中的对象可以不依赖于 Spring 的 API。 依赖注入(DI — dependency injection、IOC)。 面向切面编程(AOP — aspect oriented programming)。 容器: Spring 是一个容器, 因为它包含并且管理应用对象的生命周期。 框架: Spring 实现了使用简单的组件配置组合成一个复杂的应用. 在 Spring 中可以使用 XML 和 Java 注解组合这些对象。 一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库 （实际上 Spring 自身也提供了展现层的 SpringMVC 和 持久层的 Spring JDBC）。 2、如何学好 Spring？ Spring核心是IoC容器，所以一定要透彻理解什么是IoC容器，以及如何配置及使用容器，其他所有技术都是基于容器实现的； 理解好IoC后，接下来是面向切面编程，首先还是明确概念，基本配置，最后是实现原理。 接下来就是数据库事务管理，其实Spring管理事务是通过面向切面编程实现的，所以基础很重要，IoC容器和面向切面编程搞定后，其余都是基于这俩东西的实现。 3、Spring 基础3-1、Spring 架构图 3-2、各架构模块介绍 1、核心容器：包括Core、Beans、Context、EL模块。 Core模块：封装了框架依赖的最底层部分，包括资源访问、类型转换及一些常用工具类。 Beans模块：提供了框架的基础部分，包括反转控制和依赖注入。其中Bean Factory是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程；所有应用程序对象及对象间关系由框架管理，从而真正把你从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由BeanFactory来维护。 Context模块：以Core和Beans为基础，集成Beans模块功能并添加资源绑定、数据验证、国际化、Java EE支持、容器生命周期、事件传播等；核心接口是ApplicationContext。 EL模块：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从Spring 容器获取Bean，它也支持列表投影、选择和一般的列表聚合等。 2、AOP、Aspects模块 AOP模块：Spring AOP模块提供了符合 AOP Alliance规范的面向方面的编程（aspect-oriented programming）实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中；这样各专其职，降低业务逻辑和通用功能的耦合。 Aspects模块：提供了对AspectJ的集成，AspectJ提供了比Spring ASP更强大的功能。数据访问/集成模块：该模块包括了JDBC、ORM、OXM、JMS和事务管理。 3、data access/intergration 数据访问、数据整合模块 事务模块：该模块用于Spring管理事务，只要是Spring管理对象都能得到Spring管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事物管理。 JDBC模块：提供了一个JBDC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring管理事务的好处。 ORM模块：提供与流行的“对象-关系”映射框架的无缝集成，包括Hibernate、JPA、Ibatiss等。而且可以使用Spring事务管理，无需额外控制事务。 OXM模块：提供了一个对Object/XML映射实现，将java对象映射成XML数据，或者将XML数据映射成java对象，Object/XML映射实现包括JAXB、Castor、XMLBeans和XStream。 JMS模块：用于JMS(Java Messaging Service)，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用JMS，JMS用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 4、Web 模块 Web/Remoting模块：Web/Remoting模块包含了Web、Web-Servlet、Web-Struts、Web-Porlet模块。 Web模块：提供了基础的web功能。例如多文件上传、集成IoC容器、远程过程访问（RMI、Hessian、Burlap）以及Web Service支持，并提供一个RestTemplate类来提供方便的Restful services访问。 Web-Servlet模块：提供了一个Spring MVC Web框架实现。Spring MVC框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的JSP标签，完全无缝与Spring其他技术协作。 Web-Struts模块：提供了与Struts无缝集成，Struts1.x 和Struts2.x都支持。 Test模块： Spring支持Junit和TestNG测试框架，而且还额外提供了一些基于Spring的测试功能，比如在测试Web框架时，模拟Http请求的功能。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub page 搭建个人博客]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%2B%20github%20page%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、如何使用 github 搭建博客？参考链接： https://www.cnblogs.com/jackyroc/p/7681938.html 2、hexo 本地目录各文件以及文件夹的作用？ 主要看 _config.yml 文件。 3、假如自己有多台设备，如何同步管理博客？ 参考链接： https://juejin.im/post/5acf22e6f265da23994eeac9 4、hexo next 主题 Hexo-NexT配置超炫网页效果参考链接： https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html https://juejin.im/post/5bcd2d395188255c3b7dc1db#heading-0 5、hexo 如何发布文章？ https://www.jianshu.com/p/265b2c653e6f https://www.zengyilun.com/HexoEditor/ https://www.cnblogs.com/xingyunblog/p/8681205.html 6、个人定制？ 主题推荐： https://blog.csdn.net/qincidong/article/details/82415271 http://tengj.top/categories/hexo%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97/ https://www.titanjun.top/ https://www.haomwei.com/ 主题的配置文件修改后可热部署，Hexo 的配置文件不可。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章-线性表]]></title>
    <url>%2F2019%2F03%2F25%2F%E7%AC%AC3%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[toc] 1、线性表定义零个或多个数据元素的有限序列。 1、第一元素无前驱、最后一个元素无后继。2、每个元素有且仅有一个前驱、后继。3、相同数据元素。 2、线性表的抽象数据类型 3、线性表的顺序存储结构（数组实现）线性表的两种物理存储结构（顺序存储结构、链式存储结构） 1、顺序存储结构：指的是用一段地址连续的存储单元依次存储线性表的数据元素。 2、插入 3、删除 优点：可以快速存取表中的任意元素值。无需为表示表中元素之间的逻辑关系而增加额外的存储空间。 缺点：插入和删除操作需要移动大量元素；线性表长度发生变化时，难以确定存储长度。造成存储空间的碎片。 4、线性表的链式存储结构链式存储结构： 4-1、单链表 1、为什么使用单链表？数组实现的顺序存储在插入和删除操作时需要移动大量的元素，且存储空间的容量难以确定。 2、单链表的插入、删除、修改、查找实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212package dataStruct.singleLinkedList;/** * 线性表（链表）--节点 * * @Description: TODO: * @author pengguozhen * @date 2018年4月2日 上午11:41:56 */public class LinkedList&lt;T&gt; &#123; private Node head;// 指向链表头节点的引用变量 private Node tail;// 指向链表尾节点的引用变量 int size;// 链表中当前总节点数 public LinkedList() &#123;// 生成链表对象是一个空表 head = null; tail = null; &#125; public int length() &#123;// 返回链表的长度 return size; &#125; /** * @Description: TODO:查询--指定位置的元素 * @return T * @param index * @return */ public T getElement(int index) &#123;// 1、获取指定位置的元素 return findNodeByIndex(index).data; &#125; public Node findNodeByIndex(int index) &#123;// 查找 指定索引位置的节点 if (index &lt; 0 || index &gt; size - 1) &#123; throw new IndexOutOfBoundsException("线性表索引越界"); &#125; if (index == 0 &amp;&amp; head.next == null) &#123;// 如果要插入位置的前一个节点为头结点并且头结点的next 域为null，直接返回头结点。 return head; &#125; Node current = head;// 从头节点开始下移遍历 for (int i = 0; i &lt; size &amp; current.next != null; i++, current = current.next) &#123; if (i == index) &#123; return current; &#125; &#125; return null; &#125; /** * @Description: TODO:查询--指定元素的位置(查找数据域存放的是element的节点位置) * @return int * @param element * @return */ public int findIndexByElement(T element) &#123;// 2、查找 指定元素的位置(查找数据域存放的是element的节点位置) Node current = head;// 从第一个节点开始查找对比数据 for (int i = 0; i &lt; size &amp; current.next != null; i++, current = current.next) &#123; if (current.data.equals(element)) return i; &#125; return -1; &#125; /** * @Description: TODO:插入--在指定位置之前插入一个元素 * @return void * @param index * @param element * 在java中有这么一条规则，声明在方法中的变量在使用时必须要初始化;全局变量如果不赋值会有默认值。 * 例如：int size; 本例中 size 的初始值为 0 */ public void insert(int index, T element) &#123;// 插入 在指定索引位置插入一个元素 if (index &lt; 0 || index &gt; size) &#123; throw new IndexOutOfBoundsException("线性表索引越界"); &#125; if (head == null)// 如果链表为空，直接调用add方法 &#123; add(element); &#125; else // 链表不为空时 &#123; if (index == 0)// 在链表头插入 &#123; addAtHead(element); &#125; else &#123; Node prev = findNodeByIndex(index - 1);// 找到要插入位置的前一个节点 prev.next = new Node(element, prev.next);// 插入后prev的next指向新节点，新节点的next指向原来prev的下一个节点 size++; &#125; &#125; &#125; /* 尾插法 */ public void add(T element) &#123;// 插入 尾插法在每次在链表尾添加新节点 if (head == null) &#123; head = new Node(element, null); tail = head; &#125; else &#123; Node newNode = new Node(element, null); tail.next = newNode; tail = newNode; &#125; size++; &#125; /* 头插法 */ public void addAtHead(T element) &#123; // 插入 头插法在链表头部加入新节点 // 在头部插入新节点，就是让新节点的next指向原来的head,让新节点作为链表的头节点 head = new Node(element, head); // newNode.next = head; // head = newNode; // 如果插入之前是空链表 if (tail == null) &#123; tail = head; &#125; size++; &#125; /** * @Description: TODO:删除--指定位置的节点 并返回删除节点中的元素值 * @return T * @param index * @return */ public T delete(int index) &#123; Node deleteNode = null; if (index &lt; 0 || index &gt; size - 1) &#123; throw new IndexOutOfBoundsException("线性表索引越界"); &#125; if (index == 0)// 删除头节点 &#123; deleteNode = head; head = head.next; &#125; else &#123; Node prev = findNodeByIndex(index - 1);// 获取要删除的节点的前一个节点 deleteNode = prev.next;// 要删除的节点就是prev的next指向的节点 prev.next = deleteNode.next;// 删除以后prev的next指向被删除节点之前所指向的next deleteNode.next = null; &#125; return deleteNode.data; &#125; /** * @Description: TODO:删除--链表中最后一个元素 * @return T * @return */ public T removeLast() &#123; return delete(size - 1); &#125; /** * @Description: TODO:清除链表中所有的元素 * @return void */ public void clear() &#123; head = null; tail = null; size = 0; &#125; /** * 链表的输出 重写toString方法 */ public String toString() &#123; if (isEmpty()) &#123; return "[]"; &#125; else &#123; StringBuilder sb = new StringBuilder("[");// 使用StringBuilder类 for (Node current = head; current != null; current = current.next)// 从head开始遍历 &#123; sb.append(current.data.toString() + ",");// 把节点的数据拼接起来 &#125; int len = sb.length(); return sb.delete(len - 1, len).append("]").toString();// 把最后一个元素的，删除然后加上] &#125; &#125; /** * * @Description: TODO:判断链表是否为空 * @return boolean * @return */ public boolean isEmpty() &#123; return size == 0; &#125; /** * @Description: TODO:内部节点类 * @author pengguozhen * @date 2018年4月2日 下午12:10:44 */ private class Node// 节点类 &#123; private T data;// 数据项 private Node next;// 引用 public Node() &#123;// 空参构造器 &#125; public Node(T data, Node next) &#123;// 初始化节点信息 this.data = data; this.next = next; &#125; &#125;&#125; 测试 12345678910111213141516171819package dataStruct.singleLinkedList;import static org.junit.Assert.*;import org.junit.Test;public class LinkedListTest &#123; LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;(); @Test public void testInsert() &#123; list.add("aa");// 链表头插入 list.addAtHead("cc");// 链表尾插入 list.insert(2, "bb");// 在指定任意位置插入 System.out.println(list.toString()); &#125; &#125; 4-2、静态链表 1、为什么使用静态链表？为没有指针（引用）的编程语言提供链式存储结构实现的思想。 4-3、循环链表4-4、双向链表]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章-算法]]></title>
    <url>%2F2019%2F03%2F25%2F%E7%AC%AC2%E7%AB%A0-%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[toc] 摘自大话数据结构 1、算法和数据结构的关系 重要的数据结构就那么几种、只有配合上算法才能学习到数据结构的用处。 算法：解决特定问题的步骤描述，在计算机中表现为指令的有限序列，每个指令代表一种操作。 2、算法的特性 输入、输出算法具有零个或多个输入、至少有一个输出。算法一定有输出、如果没有输出。算法没有意义，便不需要算法。输出形式可以是打印，也可以是返回一个或多个值。 有穷性指算法不会无穷循环，而没有结果。 确定性执行的每一步都必须确定，相同的输入只能有唯一的输出结果。 可行性每一步都是可以执行的。 3、算法设计的要求好的算法： 正确性 可读性 健壮性 高效率和低存储量 4、算法效率的度量时间复杂度（大O表示法）–渐进时间复杂度 时间复杂度：O（f（n））表示随问题规模n 的增长速度。是一个增长率。即时间复杂度表示随着输入大小 n 的增长，算法时间的增长速度（程序执行次数函数的增长率）； 一般情况下 ，随着 n 的增大 O（n）增长最慢的为最优算法。 5、渐进时间复杂度的计算5-1、由执行次数T(n) 推导 大O(T(n) )推导方法： 1、计算出算法执行次数的函数T(n)。 2、常数项不影响函数的增长速度，c 代表常数。 T(n)=c 时，T(n)&gt;&gt;O(n)=O(1)， T(n) !=c 时，将常数项省略。 12第一个 Hello, World 的例子中 T(n) = 2，所以我们说那个函数(算法)的时间复杂度为 O(1)。T(n) = n + 29，此时时间复杂度为 O(n)。 3、函数高次项对于函数的增长速度影像是最大的，n3的增长速度是远超 n2 的，同时 n2 的增长速度是远超 n 的。 同时因为要求的精度不高，所以我们直接忽略低此项。 12比如T(n) = n^3 + n^2 + 29，此时时间复杂度为 O(n^3)。 4、因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。 12比如T(n) = 3n^3，此时时间复杂度为 O(n^3)。 综合起来：如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。为了方便描述，下文称此为 大O推导法。 5-2、由算法分析出执行次数 T(n)由执行次数推导出 大O 并不困难，困难的是如何从算法中分析出 执行次数 T（n）。基本策略：由内到外、从最深层分析。如果遇到函数调用，要深入函数进行分析。四个便利法则： 1、对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个循环的时间复杂度为 O(n×m)。 12345void aFunc(int n) &#123; for(int i = 0; i &lt; n; i++) &#123; // 循环次数为 n printf("Hello, World!\n"); // 循环体时间复杂度为 O(1) &#125;&#125; 2、对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c…，则这个循环的时间复杂度为 O(n×a×b×c…)。分析的时候应该由里向外分析这些循环。 1234567void aFunc(int n) &#123; for(int i = 0; i &lt; n; i++) &#123; // 循环次数为 n for(int j = 0; j &lt; n; j++) &#123; // 循环次数为 n printf("Hello, World!\n"); // 循环体时间复杂度为 O(1) &#125; &#125;&#125; 3、对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。 123456789101112void aFunc(int n) &#123; // 第一部分时间复杂度为 O(n^2) for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; printf("Hello, World!\n"); &#125; &#125; // 第二部分时间复杂度为 O(n) for(int j = 0; j &lt; n; j++) &#123; printf("Hello, World!\n"); &#125;&#125; 4、对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。 123456789101112131415void aFunc(int n) &#123; if (n &gt;= 0) &#123; // 第一条路径时间复杂度为 O(n^2) for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; printf("输入数据大于等于零\n"); &#125; &#125; &#125; else &#123; // 第二条路径时间复杂度为 O(n) for(int j = 0; j &lt; n; j++) &#123; printf("输入数据小于零\n"); &#125; &#125;&#125; 5-3、常见的 大O 时间复杂度。 1、常数阶O（1） 2、线性阶O（n） 3、对数阶O（logn） 4、平方阶O（n2） 6、最坏时间与平均情况 1、最坏时间：最坏情况运行时间的一种保证，我们提到的时间都是最坏情况的运行时间。 2、平均情况：平均运行时间是最有意义的，它是期望的运行时间。（很难通过分析得到，一般通过数据实验后估算出来。） 总结：对算法的分析：1、根据运行计算平均运行时间。2、分析最坏时间。一般算法分析时指的是最坏运行时间。 7、算法空间复杂度使用存储空间来换取运行时间 8、时间复杂度计算–练习 1、基础题求该方法的时间复杂度1234567void aFunc(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = i; j &lt; n; j++) &#123; printf("Hello World\n"); &#125; &#125;&#125; 参考答案： 1234567当 i = 0 时，内循环执行 n 次运算，当 i = 1 时，内循环执行 n - 1 次运算……当 i = n - 1 时，内循环执行 1 次运算。所以，执行次数 T(n) = n + (n - 1) + (n - 2)……+ 1 = n(n + 1) / 2 = n^2 / 2 + n / 2。根据上文说的 大O推导法 可以知道，此时时间复杂度为 O(n^2)。等差数列 通项公式：an=a1+(n-1)*d。 求和公式：Sn=a1*n+[n*(n-1)*d]/2。 2、进阶题求该方法的时间复杂度 123456void aFunc(int n) &#123; for (int i = 2; i &lt; n; i++) &#123; i *= 2; printf("%i\n", i); &#125;&#125; 参考答案： 12假设循环次数为 t，则循环条件满足 2^t &lt; n。可以得出，执行次数t = log(2)(n)，即 T(n) = log(2)(n)，可见时间复杂度为 O(log(2)(n))，即 O(log n)。 3、再次进阶求该方法的时间复杂度 1234567long aFunc(int n) &#123; if (n &lt;= 1) &#123; return 1; &#125; else &#123; return aFunc(n - 1) + aFunc(n - 2); &#125;&#125; 参考答案： 1234显然运行次数，T(0) = T(1) = 1，同时 T(n) = T(n - 1) + T(n - 2) + 1，这里的 1 是其中的加法算一次执行。显然 T(n) = T(n - 1) + T(n - 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n &gt;= 1 时 T(n) &lt; (5/3)^n，同时当 n &gt; 4 时 T(n) &gt;= (3/2)^n。所以该方法的时间复杂度可以表示为 O((5/3)^n)，简化后为 O(2^n)。可见这个方法所需的运行时间是以指数的速度增长的。如果大家感兴趣，可以试下分别用 1，10，100 的输入大小来测试下算法的运行时间，相信大家会感受到时间复杂度的无穷魅力。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章-数据结构绪论]]></title>
    <url>%2F2019%2F03%2F25%2F%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[[toc]该笔记摘抄于 《大话数据结构》工作中所需要的栈、队列、链表、散列表等结构；查找、排序等算法在开发语言的工具包中都有完美实现，为什么还要学习数据结构弄懂其算法实现的原理？ 1、数据结构起源 从计算机是用来进行数据计算的到现实中的问题需要一些科学有效的手段（表、树、图等数据结构）才能处理。 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。注：这句话应该意思是，数据结构不是研究数值和数值计算的，而是研究对象（对象不止是数值，也可能是类对象或者其他），研究这些对象之间的关系（比如有什么共同点，比如顺序如何），以及操作（比如排序，插入等）。 程序设计的实质是对确定的问题选择一种好的结构、加上设计一种好的算法。即程序设计=数据结构+算法。 2、基本概念和术语123456789101112131415161718192021222324252627282930313233343536373839//数据结构基本概念#include&lt;iostream&gt;using namespace std;/*数据 – 程序的操作对象，用于描述客观事物数据的特点：可以输入到计算机可以被计算机程序处理数据是一个抽象的概念，将其进行分类后得到程序设计语言中的类型。如：int，float，char等等数据项：一个数据元素由若干数据项组成数据元素：组成数据对象的基本单位数据对象：性质相同的数据元素的集合（类似于数组一般）数据元素之间不是独立的，存在特定的关系，这些关系即结构数据结构指数据对象中数据元素之间的关系*///声明一个结构体类型struct Teacher //一种数据类型&#123; char name[32];//数据项 char tile[32];//数据项 int age;//数据项 char addr[128];//数据项&#125;;int main()&#123; struct Teacher t1; //数据元素 struct Teacher tArray[30]; //数据对象 memset(&amp;t1, 0, sizeof(t1)); strcpy(t1.name, "name"); //数据项 strcpy(t1.addr, "addr"); //数据项 strcpy(t1.tile, "addr"); //数据项 t1.age = 1;&#125; 3、逻辑结构与物理结构数据结构分为逻辑结构与物理结构 3-1、逻辑结构是指数据对象中数据元素之间的关系。分为四种。 - 集合结构 - 线性结构 - 树 - 图 3-2、物理结构（存储结构）数据的逻辑结构在计算机中的存储形式。实际上是指如何把数据元素存储到计算机存储器中的 数据元素的存储结构形式有两种： 顺序存储结构：如数组 链式存储结构：如链表，是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以不是连续的。 注：逻辑结构是面向问题的、物理结构是面向计算机的，基本的目标就是将数据及其逻辑关系存储到计算机的内存中。 4、抽象数据类型4-1、数据类型计算机需要对数据进行分类，就分出来很多数据的类型。比如 int，float 等。 4-2、抽象数据类型 1、为什么需要抽象数据类型？无论什么计算机、什么语言都会面临类似的整数运算，我们可以考虑将其抽象出来。抽象是抽取出事物具有的普遍性本质，是对事物的一个概括，是一种思考问题的方式。 2、定义抽象数据类型（ADT）是指一个数学模型及定义在该模型上的一组操作。它仅取决于其逻辑特征，而与计算机内部如何表示和实现无关。比如刚才说得整型，各个计算机，不管大型机、小型机、PC、平板电脑甚至智能手机，都有“整型”类型，也需要整形运算，那么整型其实就是一个抽象数据类型。 Java 中 接本数据类型、引用类型]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2019%2F02%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
