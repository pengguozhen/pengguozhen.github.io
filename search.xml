<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring-3--IOC&DI]]></title>
    <url>%2F2019%2F03%2F25%2FSpring-3--IOC%26DI%2F</url>
    <content type="text"><![CDATA[[toc] 1、IOC&amp;DI 概述1-1、IOC-控制反转IOC(Inversion of Control)：其思想是反转资源获取的方向. 传统的资源查找方式要求组件向容器发起请求查找资源. 作为回应, 容器适时的返回资源. 而应用了 IOC 之后, 则是容器主动地将资源推送给它所管理的组件, 组件所要做的仅是选择一种合适的方式来接受资源. 这种行为也被称为查找的被动形式。 1-2、DI-依赖注入DI(Dependency Injection) — IOC 的另一种表述方式：即组件以一些预先定义好的方式(例如: setter 方法)接受来自如容器的资源注入. 相对于 IOC 而言，这种表述更直接。 1-3、在 Spring IOC 容器中配置 Bean 1、在 Spring IOC 容器读取 Bean 配置创建 Bean 实例之前, 必须对它进行实例化. 只有在容器实例化后, 才可以从 IOC 容器里获取 Bean 实例并使用。 2、Spring 提供了两种类型的 IOC 容器实现。 BeanFactory: IOC 容器的基本实现： ApplicationContext: 提供了更多的高级特性. 是 BeanFactory 的子接口。 2、配置 Bean2-1、配置形式 基于 XML 文件的配置方式 基于注解的方式（实际开发中主要使用该方式） 2-2、Bean 的配置方式 通过全类名（反射） 通过工厂方法（静态工厂方法&amp;实例工厂方法） FactoryBean 2-3、IOC 容器 BeanFactory &amp; ApplicationContext 概述 BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；ApplicationContext 面向使用 Spring 框架的开发者，几乎所有的应用场合都直接使用 ApplicationContext 而非底层的 BeanFactory ApplicationContext 接口 123456789ApplicationContext 的主要实现类： ClassPathXmlApplicationContext：从 类路径下加载配置文件 FileSystemXmlApplicationContext: 从文件系统中加载配置文件 ConfigurableApplicationContext 扩展于 ApplicationContext，新增加两个主要方法：refresh() 和 close()， 让 ApplicationContext 具有启动、刷新和关闭上下文的能力。ApplicationContext 在初始化上下文时就实例化所有单例的 Bean。WebApplicationContext 是专门为 WEB 应用而准备的，它允许从相对于 WEB 根目录的路径中完成初始化工作。 从容器中 获取 Bean 2-4、依赖注入的方式 属性注入（注入细节） 字面值 引用其他 Bean 内部Bean 注入参数：（null 值和级联属性） 集合属性&amp; utility scheme 定义集合 使用 P 命名空间 构造器注入 泛型依赖注入 1、Beanscom.atguigu.spring.helloworld.HelloWorldcom.atguigu.spring.ref.Daocom.atguigu.spring.ref.Service 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.atguigu.spring.helloworld;public class HelloWorld &#123; private String user; public HelloWorld() &#123; System.out.println("HelloWorld's constructor..."); &#125; public HelloWorld(String user) &#123; this.user = user; &#125; public void setUser(String user) &#123; System.out.println("setUser:" + user); this.user = user; &#125; public void hello()&#123; System.out.println("Hello: " + user); &#125; &#125;package com.atguigu.spring.ref;public class Dao &#123; private String dataSource = "dbcp"; public void setDataSource(String dataSource) &#123; this.dataSource = dataSource; &#125; public void save()&#123; System.out.println("save by " + dataSource); &#125; public Dao() &#123; System.out.println("Dao's Constructor..."); &#125; public String toString()&#123; return "[dataSource]:"+dataSource; &#125; &#125;package com.atguigu.spring.ref;public class Service &#123; private Dao dao; public void setDao(Dao dao) &#123; this.dao = dao; &#125; public Dao getDao() &#123; return dao; &#125; public void save()&#123; System.out.println("Service's save"); dao.save(); &#125; &#125; 2、Spring xml配置Beans 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 1、属性注入：配置一个 bean 通过 setter 方法 为属性赋值 --&gt; &lt;bean id="helloWorld1" class="com.atguigu.spring.helloworld.HelloWorld"&gt; &lt;property name="user" value="Jerry"/&gt;&lt;!-- 为属性赋值 --&gt; &lt;/bean&gt; &lt;!-- 2、构造器注入：通过构造器注入属性值 --&gt; &lt;bean id="helloWorld3" class="com.atguigu.spring.helloworld.HelloWorld"&gt; &lt;constructor-arg value="Mike"/&gt;&lt;!-- 要求: 在 Bean 中必须有对应的构造器. --&gt; &lt;/bean&gt; &lt;!-- 2-1、若一个 bean 有多个构造器, 如何通过构造器来为 bean 的属性赋值 --&gt; &lt;!-- 可以根据 index 和 value 进行更加精确的定位. (了解) --&gt; &lt;bean id="car" class="com.atguigu.spring.helloworld.Car"&gt; &lt;constructor-arg value="KUGA" index="1"/&gt; &lt;constructor-arg value="ChangAnFord" index="0"/&gt; &lt;constructor-arg value="250000" type="float"/&gt; &lt;/bean&gt; &lt;!--3、属性注入细节：字面值--&gt; &lt;bean id="car2" class="com.atguigu.spring.helloworld.Car"&gt; &lt;constructor-arg value="ChangAnMazda"/&gt; &lt;constructor-arg&gt; &lt;value&gt;&lt;![CDATA[&lt;ATARZA&gt;]]&gt;&lt;/value&gt;&lt;!-- 若字面值中包含特殊字符, 则可以使用 CDATA 来进行赋值. (了解) --&gt; &lt;/constructor-arg&gt; &lt;constructor-arg value="180" type="int"/&gt; &lt;/bean&gt; &lt;!-- 4、属性注入细节：引用其他 bean 配置 --&gt; &lt;bean id="dao5" class="com.atguigu.spring.ref.Dao"/&gt; &lt;bean id="service" class="com.atguigu.spring.ref.Service"&gt; &lt;property name="dao" ref="dao5"/&gt;&lt;!-- 通过 ref 属性值指定当前属性指向哪一个 bean! --&gt; &lt;/bean&gt; &lt;!-- 5、属性注入细节：声明使用内部 bean --&gt; &lt;bean id="service2" class="com.atguigu.spring.ref.Service"&gt; &lt;property name="dao"&gt; &lt;bean class="com.atguigu.spring.ref.Dao"&gt;&lt;!-- 内部 bean, 类似于匿名内部类对象. 不能被外部的 bean 来引用, 也没有必要设置 id 属性 --&gt; &lt;property name="dataSource" value="c3p0"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--6、属性注入细节：注入参数之级联属性--&gt; &lt;bean id="action" class="com.atguigu.spring.ref.Action"&gt; &lt;property name="service" ref="service2"/&gt; &lt;property name="service.dao.dataSource" value="DBCP2"/&gt;&lt;!-- 设置级联属性(了解) --&gt; &lt;/bean&gt; &lt;bean id="dao2" class="com.atguigu.spring.ref.Dao"&gt; &lt;property name="dataSource"&gt; &lt;null/&gt; &lt;/property&gt;&lt;!-- 为 Dao 的 dataSource 属性赋值为 null, 若某一个 bean 的属性值不是 null, 使用时需要为其设置为 null(了解) --&gt; &lt;/bean&gt; &lt;!-- 7、属性注入细节：装配集合属性 --&gt; &lt;bean id="user" class="com.atguigu.spring.helloworld.User"&gt; &lt;property name="userName" value="Jack"/&gt; &lt;property name="cars"&gt; &lt;list&gt;&lt;!-- 使用 list 元素来装配集合属性 --&gt; &lt;ref bean="car"/&gt; &lt;ref bean="car2"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 7-1、声明集合类型的 bean --&gt; &lt;util:list id="cars"&gt; &lt;ref bean="car"/&gt; &lt;ref bean="car2"/&gt; &lt;/util:list&gt; &lt;!--7-2、引用外部声明的集合--&gt; &lt;bean id="user2" class="com.atguigu.spring.helloworld.User"&gt; &lt;property name="userName" value="Rose"/&gt; &lt;property name="cars" ref="cars"/&gt;&lt;!-- 引用外部声明的 list --&gt; &lt;/bean&gt; &lt;!--8、属性注入细节：定义 P 命名空间--&gt; &lt;bean id="user3" class="com.atguigu.spring.helloworld.User" p:cars-ref="cars" p:userName="Titannic"/&gt; &lt;!-- bean 的配置能够继承吗 ? 使用 parent 来完成继承 --&gt; &lt;bean id="user4" parent="user" p:userName="Bob"/&gt; &lt;bean id="user6" parent="user" p:userName="维多利亚"/&gt; &lt;!-- 测试 depents-on --&gt; &lt;bean id="user5" parent="user" p:userName="Backham" depends-on="user6"/&gt;&lt;/beans&gt; 3、测试 Main 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.atguigu.spring.helloworld;import com.atguigu.spring.ref.*;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; /*测试未使用Spring 前对象的实例化操作*/ HelloWorld helloWorld = new HelloWorld(); helloWorld.setUser("Tom"); helloWorld.hello(); /* 测试使用 Spring 容器 后 对象实例化的操作*/ ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");//创建 Spring 的 IOC 容器 //1、测试 通过 setter 方法注入属性值 HelloWorld helloWorld1= (HelloWorld) ctx.getBean("helloWorld1"); helloWorld1.hello(); //根据类型来获取 bean 的实例: 要求在 IOC 容器中只有一个与之类型匹配的 bean, 若有多个则会抛出异常. // 一般情况下, 该方法可用, 因为一般情况下, 在一个 IOC 容器中一个类型对应的 bean 也只有一个. //HelloWorld helloWorld1 = ctx.getBean(HelloWorld.class); // 2、测试通过构造器为属性赋值 HelloWorld helloWorld3 = (HelloWorld)ctx.getBean("helloWorld3"); helloWorld3.hello(); /* 2-1、测试 bean 有多个构造器, 如何通过构造器来为 bean 的属性赋值*/ Car car = (Car) ctx.getBean("car"); System.out.println(car);//Car [company=ChangAnFord, brand=KUGA, maxSpeed=0, price=250000.0] /*3、属性注入细节：字面值*/ Car car2= (Car) ctx.getBean("car2"); System.out.println(car2);//Car [company=ChangAnMazda, brand=&lt;ATARZA&gt;, maxSpeed=180, price=0.0] //4. 属性注入细节：引用其他 Bean+级联属性设置 Service service2= (Service) ctx.getBean("service2"); System.out.print("service2:"+service2.getDao().toString());//由于级联属性的设置，输出结果为：[dataSource]:DBCP2 //7、属性注入细节：装配集合属性 &#125; &#125; 2-5、自动装配 XML 配置里的 Bean 自动装配。 XML 配置里的 Bean 自动装配的缺点。 123456789&lt;!-- 1、自动装配: 只声明 bean, 而把 bean 之间的关系交给 IOC 容器来完成 --&gt; &lt;!-- byType: 根据类型进行自动装配. 但要求 IOC 容器中只有一个类型对应的 bean, 若有多个则无法完成自动装配. byName: 若属性名和某一个 bean 的 id 名一致, 即可完成自动装配. 若没有 id 一致的, 则无法完成自动装配 --&gt; &lt;!-- 在使用 XML 配置时, 自动装配用的不多. 但在基于 注解 的配置时, 自动装配使用的较多. --&gt; &lt;bean id="dao" class="com.atguigu.spring.ref.Dao"&gt; &lt;property name="dataSource" value="C3P0"&gt;&lt;/property&gt; &lt;/bean&gt; 注：实际项目中很少使用xml方式的自动装配，在基于 注解 的配置时, 自动装配使用的较多，此处XML 配置方式的自动装配仅做了解。 2-6、Bean 之间的关系 继承 123456Spring 允许继承 bean 的配置, 被继承的 bean 称为父 bean. 继承这个父 Bean 的 Bean 称为子 Bean子 Bean 从父 Bean 中继承配置, 包括 Bean 的属性配置子 Bean 也可以覆盖从父 Bean 继承过来的配置父 Bean 可以作为配置模板, 也可以作为 Bean 实例. 若只想把父 Bean 作为模板, 可以设置 &lt;bean&gt; 的abstract 属性为 true, 这样 Spring 将不会实例化这个 Bean并不是 &lt;bean&gt; 元素里的所有属性都会被继承. 比如: autowire, abstract 等.也可以忽略父 Bean 的 class 属性, 让子 Bean 指定自己的类, 而共享相同的属性配置. 但此时 abstract 必须设为 true 依赖 12Spring 允许用户通过 depends-on 属性设定 Bean 前置依赖的Bean，前置依赖的 Bean 会在本 Bean 实例化之前创建好如果前置依赖于多个 Bean，则可以通过逗号，空格或的方式配置 Bean 的名称 2-7、Bean 的作用域在 Spring 中, 可以在 元素的 scope 属性里设置 Bean 的作用域。 singleton &amp; prototype beans-auto.xml123456789101112131415161718192021&lt;!-- 1、自动装配: 只声明 bean, 而把 bean 之间的关系交给 IOC 容器来完成 --&gt;&lt;!-- byType: 根据类型进行自动装配. 但要求 IOC 容器中只有一个类型对应的 bean, 若有多个则无法完成自动装配. byName: 若属性名和某一个 bean 的 id 名一致, 即可完成自动装配. 若没有 id 一致的, 则无法完成自动装配--&gt;&lt;!-- 在使用 XML 配置时, 自动装配用的不多. 但在基于 注解 的配置时, 自动装配使用的较多. --&gt;&lt;bean id="dao" class="com.atguigu.spring.ref.Dao"&gt; &lt;property name="dataSource" value="C3P0"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 2、默认情况下 bean 是单例的! 即为 singleton--&gt;&lt;!-- 但有的时候, bean 就不能使单例的. 例如: Struts2 的 Action 就不是单例的! 可以通过 scope 属性来指定 bean 的作用域 --&gt;&lt;!-- prototype: 原型的. 每次调用 getBean 方法都会返回一个新的 bean. 且在第一次调用 getBean 方法时才创建实例 singleton: 单例的. 每次调用 getBean 方法都会返回同一个 bean. 且在 IOC 容器初始化时即创建 bean 的实例. 默认值 --&gt;&lt;bean id="dao2" class="com.atguigu.spring.ref.Dao" scope="prototype"&gt;&lt;/bean&gt;&lt;bean id="service" class="com.atguigu.spring.ref.Service" autowire="byName"&gt;&lt;/bean&gt;&lt;bean id="action" class="com.atguigu.spring.ref.Action" autowire="byType"&gt;&lt;/bean&gt; 测试 Main 12345678ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("beans-auto.xml"); //测试 bean 的作用域Dao dao1 = (Dao) ctx.getBean("dao2");Dao dao2 = (Dao) ctx.getBean("dao2");System.out.println(dao1 == dao2);//false 非单例 Bean WEB 环境作用域 2-8、使用外部属性文件 在配置文件里配置 Bean 时, 有时需要在 Bean 的配置里混入系统部署的细节信息(例如: 文件路径, 数据源配置信息等). 而这些部署细节实际上需要和 Bean 配置相分离。 Spring 提供了一个 PropertyPlaceholderConfigurer 的 BeanFactory 后置处理器, 这个处理器允许用户将 Bean 配置的部分内容外移到属性文件中. 可以在 Bean 配置文件里使用形式为 ${var} 的变量, PropertyPlaceholderConfigurer 从属性文件里加载属性, 并使用这些属性来替换变量. Spring 还允许在属性文件中使用 ${propName}，以实现属性之间的相互引用。 Spring 2.5 之后不要再配置 PropertyPlaceholderConfigurer 类，简化为：123456789101112131415``` xml&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;&lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.jdbcUrl&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot; value=&quot;$&#123;jdbc.initPoolSize&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;$&#123;jdbc.maxPoolSize&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 测试 Main 12345ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("beans-auto.xml");//测试使用外部属性文件DataSource dataSource = (DataSource) ctx.getBean("dataSource");System.out.println(dataSource.getConnection()); 2-9、SpEL（Spring 表达式语言） SpEL 简介 Spring 表达式语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。 语法类似于 EL：SpEL 使用 #{…} 作为定界符，所有在大框号中的字符都将被认为是 SpEL。 SpEL 为 bean 的属性进行动态赋值提供了便利。 通过 SpEL 可以实现： 通过 bean 的 id 对 bean 进行引用。 调用方法以及引用对象中的属性。 计算表达式的值。 正则表达式的匹配。 SpEL：字面量 SpEL：引用 Bean、属性和方法 SpEL 支持的运算符号 动态赋值123456789&lt;!-- 4、测试 SpEL: 可以为属性进行动态的赋值(了解) --&gt; &lt;bean id="girl" class="com.atguigu.spring.helloworld.User"&gt; &lt;property name="userName" value="周迅"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="boy" class="com.atguigu.spring.helloworld.User" init-method="init" destroy-method="destroy"&gt;&lt;!--User 类中定义了init、destroy方法--&gt; &lt;property name="userName" value="高胜远"&gt;&lt;/property&gt; &lt;property name="wifeName" value="#&#123;girl.userName&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; 测试 main 1234ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("beans-auto.xml");//测试 spELUser boy = (User) ctx.getBean("boy");System.out.println(boy.getUserName() + ":" + boy.getWifeName()); 2-10、IOC 容器中 Bean 的生命周期 1、Spring 配置 Bean 的后置通知 12&lt;!-- 5、配置 bean 后置处理器: 不需要配置 id 属性, IOC 容器会识别到他是一个 bean 后置处理器, 并调用其方法 --&gt; &lt;bean class="com.atguigu.spring.ref.MyBeanPostProcessor"&gt;&lt;/bean&gt; Bean 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.spring.ref;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;import com.atguigu.spring.helloworld.User;public class MyBeanPostProcessor implements BeanPostProcessor &#123; //该方法在 init 方法之后被调用 @Override public Object postProcessAfterInitialization(Object arg0, String arg1) throws BeansException &#123; if(arg1.equals("boy"))&#123; System.out.println("postProcessAfterInitialization..." + arg0 + "," + arg1); User user = (User) arg0; user.setUserName("李大齐"); &#125; return arg0; &#125; //该方法在 init 方法之前被调用 //可以工作返回的对象来决定最终返回给 getBean 方法的对象是哪一个, 属性值是什么 /** * @param arg0: 实际要返回的对象 * @param arg1: bean 的 id 值 */ @Override public Object postProcessBeforeInitialization(Object arg0, String arg1) throws BeansException &#123; if(arg1.equals("boy")) System.out.println("postProcessBeforeInitialization..." + arg0 + "," + arg1); return arg0; &#125;&#125; 测试 Main1234ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("beans-auto.xml");//测试 spELUser boy = (User) ctx.getBean("boy");System.out.println(boy.getUserName() + ":" + boy.getWifeName()); 2、Spring IOC 容器对 Bean 的生命周期进行管理的过程: 1234567通过构造器或工厂方法创建 Bean 实例。为 Bean 的属性设置值和对其他 Bean 的引用。将 Bean 实例传递给 Bean 后置处理器的 postProcessBeforeInitialization 方法。调用 Bean 的初始化方法。将 Bean 实例传递给 Bean 后置处理器的 postProcessAfterInitialization方法。Bean 可以使用了。当容器关闭时, 调用 Bean 的销毁方法。 3、工厂方法&amp;FactroyBean 方式配置 Bean beans-auto.xml12345678910111213141516171819202122&lt;!-- 6、通过工厂方法的方式来配置 bean --&gt; &lt;!-- 6-1. 通过静态工厂方法: 一个类中有一个静态方法, 可以返回一个类的实例(了解) --&gt; &lt;!-- 在 class 中指定静态工厂方法的全类名, 在 factory-method 中指定静态工厂方法的方法名 --&gt; &lt;bean id="dateFormat" class="java.text.DateFormat" factory-method="getDateInstance"&gt; &lt;constructor-arg value="2"&gt;&lt;/constructor-arg&gt;&lt;!-- 可以通过 constructor-arg 子节点为静态工厂方法指定参数 --&gt; &lt;/bean&gt; &lt;!-- 6-2. 实例工厂方法: 先需要创建工厂对象, 再调用工厂的非静态方法返回实例(了解) --&gt; &lt;!-- ①. 创建工厂对应的 bean --&gt; &lt;bean id="simpleDateFormat" class="java.text.SimpleDateFormat"&gt; &lt;constructor-arg value="yyyy-MM-dd hh:mm:ss"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- ②. 有实例工厂方法来创建 bean 实例 --&gt; &lt;!-- factory-bean 指向工厂 bean, factory-method 指定工厂方法(了解) --&gt; &lt;bean id="datetime" factory-bean="simpleDateFormat" factory-method="parse"&gt; &lt;!-- 通过 constructor-arg 执行调用工厂方法需要传入的参数 --&gt; &lt;constructor-arg value="1990-12-12 12:12:12"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 7、配置通过 FactroyBean 的方式来创建 bean 的实例(了解) --&gt; &lt;bean id="user" class="com.atguigu.spring.ref.UserBean"&gt;&lt;/bean&gt; 测试 Main 1234567891011121314//测试工厂方法配置 Bean// DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.FULL);DateFormat dateFormat = (DateFormat) ctx.getBean("dateFormat");System.out.println(dateFormat.format(new Date()));Date date = (Date) ctx.getBean("datetime");System.out.println(date);//测试通过 FactroyBean 来配置 BeanUser user = (User) ctx.getBean("user");System.out.println(user);ctx.close(); 2-11、Spring4.x 新特性 泛型依赖注入 2-12、整合多个配置文件]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-2--开发环境搭建]]></title>
    <url>%2F2019%2F03%2F25%2FSpring-2--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[[toc] 1、Spring 框架的核心jar 包除此之外，还有其他一些 jar 包。 2、Spring 的 HelloWorld 1、引入jar 包 2、编写 com.ppjuice.helloworld.HelloWorld 类 123456789101112131415161718192021222324package com.ppjuice.helloworld;public class HelloWorld &#123; private String username; public void setUsername(String username) &#123; this.username = username; &#125; /** * 成员方法 */ public void hello() &#123; System.out.println("This is hello...."); &#125; /** * 空参构造器 */ public HelloWorld() &#123; // TODO Auto-generated constructor stub &#125;&#125; 3、配置 ApplicationContext .xml 文件]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-1--什么是Spring？]]></title>
    <url>%2F2019%2F03%2F25%2FSpring-1--%E4%BB%80%E4%B9%88%E6%98%AFSpring%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[[toc] 1、什么是 Spring？ Spring 是一个 IOC(DI) 和 AOP 容器框架，开源框架。 轻量级：Spring 是非侵入性的 - 基于 Spring 开发的应用中的对象可以不依赖于 Spring 的 API。 依赖注入(DI — dependency injection、IOC)。 面向切面编程(AOP — aspect oriented programming)。 容器: Spring 是一个容器, 因为它包含并且管理应用对象的生命周期。 框架: Spring 实现了使用简单的组件配置组合成一个复杂的应用. 在 Spring 中可以使用 XML 和 Java 注解组合这些对象。 一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库 （实际上 Spring 自身也提供了展现层的 SpringMVC 和 持久层的 Spring JDBC）。 2、如何学好 Spring？ Spring核心是IoC容器，所以一定要透彻理解什么是IoC容器，以及如何配置及使用容器，其他所有技术都是基于容器实现的； 理解好IoC后，接下来是面向切面编程，首先还是明确概念，基本配置，最后是实现原理。 接下来就是数据库事务管理，其实Spring管理事务是通过面向切面编程实现的，所以基础很重要，IoC容器和面向切面编程搞定后，其余都是基于这俩东西的实现。 3、Spring 基础3-1、Spring 架构图 3-2、各架构模块介绍 1、核心容器：包括Core、Beans、Context、EL模块。 Core模块：封装了框架依赖的最底层部分，包括资源访问、类型转换及一些常用工具类。 Beans模块：提供了框架的基础部分，包括反转控制和依赖注入。其中Bean Factory是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程；所有应用程序对象及对象间关系由框架管理，从而真正把你从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由BeanFactory来维护。 Context模块：以Core和Beans为基础，集成Beans模块功能并添加资源绑定、数据验证、国际化、Java EE支持、容器生命周期、事件传播等；核心接口是ApplicationContext。 EL模块：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从Spring 容器获取Bean，它也支持列表投影、选择和一般的列表聚合等。 2、AOP、Aspects模块 AOP模块：Spring AOP模块提供了符合 AOP Alliance规范的面向方面的编程（aspect-oriented programming）实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中；这样各专其职，降低业务逻辑和通用功能的耦合。 Aspects模块：提供了对AspectJ的集成，AspectJ提供了比Spring ASP更强大的功能。数据访问/集成模块：该模块包括了JDBC、ORM、OXM、JMS和事务管理。 3、data access/intergration 数据访问、数据整合模块 事务模块：该模块用于Spring管理事务，只要是Spring管理对象都能得到Spring管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事物管理。 JDBC模块：提供了一个JBDC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring管理事务的好处。 ORM模块：提供与流行的“对象-关系”映射框架的无缝集成，包括Hibernate、JPA、Ibatiss等。而且可以使用Spring事务管理，无需额外控制事务。 OXM模块：提供了一个对Object/XML映射实现，将java对象映射成XML数据，或者将XML数据映射成java对象，Object/XML映射实现包括JAXB、Castor、XMLBeans和XStream。 JMS模块：用于JMS(Java Messaging Service)，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用JMS，JMS用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 4、Web 模块 Web/Remoting模块：Web/Remoting模块包含了Web、Web-Servlet、Web-Struts、Web-Porlet模块。 Web模块：提供了基础的web功能。例如多文件上传、集成IoC容器、远程过程访问（RMI、Hessian、Burlap）以及Web Service支持，并提供一个RestTemplate类来提供方便的Restful services访问。 Web-Servlet模块：提供了一个Spring MVC Web框架实现。Spring MVC框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的JSP标签，完全无缝与Spring其他技术协作。 Web-Struts模块：提供了与Struts无缝集成，Struts1.x 和Struts2.x都支持。 Test模块： Spring支持Junit和TestNG测试框架，而且还额外提供了一些基于Spring的测试功能，比如在测试Web框架时，模拟Http请求的功能。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-4--AOP]]></title>
    <url>%2F2019%2F03%2F25%2FSpring-4--AOP%2F</url>
    <content type="text"><![CDATA[[toc] 1、为什么需要 AOP？需求案例：需求1-日志：在程序执行期间追踪正在发生的活动。需求2-验证：希望计算器只能处理正数的运算。 1-1、不使用 AOP 时的代码实现。 1-2、使用动态代理解决问题分析代理设计模式的原理：使用一个代理将对象包装起来, 然后用该代理对象取代原始对象. 任何对原始对象的调用都要通过代理. 代理对象决定是否以及何时将方法调用转到原始对象上。 0、接口实现类 12345678910111213141516171819202122232425public class ArithmeticCalculatorImpl implements ArithmeticCalculator &#123; @Override public int add(int i, int j) &#123; int result = i + j; return result; &#125; @Override public int sub(int i, int j) &#123; int result = i - j; return result; &#125; @Override public int mul(int i, int j) &#123; int result = i * j; return result; &#125; @Override public int div(int i, int j) &#123; int result = i / j; return result; &#125; 1、新建处理日志的代理类 ArithmeticCalculatorLoggingProxy，将原始对象包装起来。（匿名内部类的方式实现） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class ArithmeticCalculatorLoggingProxy &#123; //要代理的对象 private ArithmeticCalculator target; public ArithmeticCalculatorLoggingProxy(ArithmeticCalculator target) &#123; super(); this.target = target; &#125; //返回代理对象 public ArithmeticCalculator getLoggingProxy()&#123; ArithmeticCalculator proxy = null; ClassLoader loader = target.getClass().getClassLoader(); Class [] interfaces = new Class[]&#123;ArithmeticCalculator.class&#125;; InvocationHandler h = new InvocationHandler() &#123; /** * proxy: 代理对象。 一般不使用该对象 * method: 正在被调用的方法 * args: 调用方法传入的参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); //打印日志 System.out.println("[before] The method " + methodName + " begins with " + Arrays.asList(args)); //调用目标方法 Object result = null; try &#123; //前置通知 result = method.invoke(target, args); //返回通知, 可以访问到方法的返回值 &#125; catch (NullPointerException e) &#123; e.printStackTrace(); //异常通知, 可以访问到方法出现的异常 &#125; //后置通知. 因为方法可以能会出异常, 所以访问不到方法的返回值 //打印日志 System.out.println("[after] The method ends with " + result); return result; &#125; &#125;; /** * loader: 代理对象使用的类加载器。 * interfaces: 指定代理对象的类型. 即代理代理对象中可以有哪些方法. * h: 当具体调用代理对象的方法时, 应该如何进行响应, 实际上就是调用 InvocationHandler 的 invoke 方法 */ proxy = (ArithmeticCalculator) Proxy.newProxyInstance(loader, interfaces, h); return proxy; &#125;&#125; （实现 InvocationHandler 接口的方式实现（推荐）） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 动态代理类的实现：InvocationHandler接口（invoke方法）+Proxy类（newProxyInstance方法） */public class ArithmeticCalculatorLoggingProxy implements InvocationHandler &#123; //要代理的对象 private ArithmeticCalculator target; public ArithmeticCalculatorLoggingProxy(ArithmeticCalculator target) &#123;// super(); this.target = target; &#125; //返回代理对象 public ArithmeticCalculator getLoggingProxy() &#123; ArithmeticCalculator proxy = null; ClassLoader loader = target.getClass().getClassLoader(); Class[] interfaces = new Class[]&#123;ArithmeticCalculator.class&#125;;// /** * Proxy 类： * loader: 代理对象使用的类加载器。 * interfaces: 指定被代理对象的一组接口. 即被代理对象实现了哪些接口。指定后该代理对象实例就会实现被代理对象接口的所有方法。 * h: 当具体调用代理对象的方法时, 应该如何进行响应, 实际上就是调用 InvocationHandler 的 invoke 方法 */ proxy = (ArithmeticCalculator) Proxy.newProxyInstance(loader, interfaces, new ArithmeticCalculatorLoggingProxy(target));//h:参数，该类实现了此接口有继承关系。System.out.println("代理对象实例："+proxy.getClass().getName());//代理对象实例 return proxy; &#125; /** * proxy: 代理对象。 一般不使用该对象 * method: 正在被调用的方法 * args: 调用方法传入的参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); //打印日志 System.out.println("[before] The method " + methodName + " begins with " + Arrays.asList(args)); //调用目标方法 Object result = null; try &#123; //前置通知 result = method.invoke(target, args);//返回通知, 可以访问到方法的返回值 &#125; catch (NullPointerException e) &#123; e.printStackTrace();//异常通知, 可以访问到方法出现的异常 &#125; //后置通知. 因为方法可以能会出异常, 所以访问不到方法的返回值 //打印日志 System.out.println("[after] The method ends with " + result); return result; &#125; 1-3、动态代理原理分析 1、Java 动态代理创建出来的动态代理类。上面我们利用Proxy类的newProxyInstance方法创建了一个动态代理对象，查看该方法的源码，发现它只是封装了创建动态代理类的步骤(红色标准部分)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * Look up or generate the designated proxy class. */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125; 其实，我们最应该关注的是 Class&lt;?&gt; cl = getProxyClass0(loader, intfs);这句，这里产生了代理类，后面代码中的构造器也是通过这里产生的类来获得，可以看出，这个类的产生就是整个动态代理的关键，由于是动态生成的类文件，我这里不具体进入分析如何产生的这个类文件，只需要知道这个类文件时缓存在java虚拟机中的，我们可以通过下面的方法将其打印到文件里面，一睹真容： 1234567891011private void generateProxyClass() &#123; byte[] classFile = ProxyGenerator.generateProxyClass("$Proxy4", ArithmeticCalculatorImpl.class.getInterfaces()); String path = "E:\\PersonWorkSpace\\JavaEESpace\\spring-2\\src\\com\\atguigu\\spring\\dynamicProxy\\ArithmeticCalculatorImpl.class"; try(FileOutputStream fos = new FileOutputStream(path)) &#123; fos.write(classFile); fos.flush(); System.out.println("代理类class文件写入成功"); &#125; catch (Exception e) &#123; System.out.println("写文件错误"); &#125; &#125; 对这个class文件进行反编译，我们看看jdk为我们生成了什么样的内容：生成的代理类 实现了被代理类的接口。代理类调用接口方法时，会利用反射转发到invoke 去调用方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public final class $Proxy4 extends Proxy implements ArithmeticCalculator &#123; private static Method m1; private static Method m2; private static Method m6; private static Method m3; private static Method m5; private static Method m4; private static Method m0; public $Proxy4(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int mul(int var1, int var2) throws &#123; try &#123; return (Integer)super.h.invoke(this, m6, new Object[]&#123;var1, var2&#125;); &#125; catch (RuntimeException | Error var4) &#123; throw var4; &#125; catch (Throwable var5) &#123; throw new UndeclaredThrowableException(var5); &#125; &#125; public final int add(int var1, int var2) throws &#123; try &#123; return (Integer)super.h.invoke(this, m3, new Object[]&#123;var1, var2&#125;);//该代理类调用方法时转发到 invoke 方法反射调用。 &#125; catch (RuntimeException | Error var4) &#123; throw var4; &#125; catch (Throwable var5) &#123; throw new UndeclaredThrowableException(var5); &#125; &#125; public final int sub(int var1, int var2) throws &#123; try &#123; return (Integer)super.h.invoke(this, m5, new Object[]&#123;var1, var2&#125;); &#125; catch (RuntimeException | Error var4) &#123; throw var4; &#125; catch (Throwable var5) &#123; throw new UndeclaredThrowableException(var5); &#125; &#125; public final int div(int var1, int var2) throws &#123; try &#123; return (Integer)super.h.invoke(this, m4, new Object[]&#123;var1, var2&#125;); &#125; catch (RuntimeException | Error var4) &#123; throw var4; &#125; catch (Throwable var5) &#123; throw new UndeclaredThrowableException(var5); &#125; &#125; public final int hashCode() throws &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object")); m2 = Class.forName("java.lang.Object").getMethod("toString"); m6 = Class.forName("com.atguigu.spring.dynamicProxy.ArithmeticCalculator").getMethod("mul", Integer.TYPE, Integer.TYPE); m3 = Class.forName("com.atguigu.spring.dynamicProxy.ArithmeticCalculator").getMethod("add", Integer.TYPE, Integer.TYPE); m5 = Class.forName("com.atguigu.spring.dynamicProxy.ArithmeticCalculator").getMethod("sub", Integer.TYPE, Integer.TYPE); m4 = Class.forName("com.atguigu.spring.dynamicProxy.ArithmeticCalculator").getMethod("div", Integer.TYPE, Integer.TYPE); m0 = Class.forName("java.lang.Object").getMethod("hashCode"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 参考博客：https://www.cnblogs.com/gonjan-blog/p/6685611.html。http://www.cnblogs.com/xiaoluo501395377/p/3383130.html。 1-4、总结生成的代理类：$Proxy0 extends Proxy implements Person，我们看到代理类继承了Proxy类，所以也就决定了java动态代理只能对接口进行代理，Java的继承机制注定了这些动态代理类们无法实现对class的动态代理。上面的动态代理的例子，其实就是AOP的一个简单实现了，在目标对象的方法执行之前和执行之后进行了处理，对方法耗时统计。Spring的AOP实现其实也是用了Proxy和InvocationHandler这两个东西的。 2、AOP 简介 1、AOP(Aspect-Oriented Programming, 面向切面编程)。 2、AOP 的主要编程对象是切面(aspect), 而切面模块化横切关注点。 3、在应用 AOP 编程时, 仍然需要定义公共功能, 但可以明确的定义这个功能在哪里, 以什么方式应用, 并且不必修改受影响的类. 这样一来横切关注点就被模块化到特殊的对象(切面)里。 4、AOP 的好处:每个事物逻辑位于一个位置, 代码不分散, 便于维护和升级业务模块更简洁, 只包含核心业务代码 3、AOP 术语3-1、切面(Aspect)切面就是横切面，代表的是一个普遍存在的共有功能。例如，日志、验证、统计成员方法运行时间。都可作为一个切面来处理。例：代理对象$proxy0 已经将日志切面与业务逻辑add 方法进行了合成。（先调invoke 打印日志，再反射调用 add 方法。） 3-2、通知 (Advice)切面要完成的工作，例如：日志切面要完成打印日志的任务，则通知即是打印日志。前置通知在 add 方法反射执行前打印日志，后置通知在 add 方法反射执行后打印通知。 五种类型的通知注解@Before: 前置通知, 在方法执行之前执行。@After: 后置通知, 在方法执行之后执行 。@AfterRunning: 返回通知, 在方法返回结果之后执行。@AfterThrowing: 异常通知, 在方法抛出异常之后。@Around: 环绕通知, 围绕着方法执行。 3-3、目标 (Target)3-4、代理 (Proxy)3-5、连接点（Joinpoint）程序执行的某个特定位置：如类某个方法调用前、调用后、方法抛出异常后等。例如 ArithmethicCalculator#add()方法。 3-6、切点（pointcut）每个类都拥有多个连接点：例如 ArithmethicCalculator 的所有方法实际上都是连接点。AOP 通过切点定位到特定的连接点。切点即指类和方法。AOP 使用类和方法作为连接点的查询条件。定位连接点。 4、在Spring 中启用 AspectJ AOP框架。 1、要在 Spring 应用中使用 AspectJ 注解, 必须在 classpath 下包含 AspectJ 类库: aopalliance.jar、aspectj.weaver.jar 和 spring-aspects.jar 2、将 aop Schema 添加到 根元素中. 3、要在 Spring IOC 容器中启用 AspectJ 注解支持, 只要在 Bean 配置文件中定义一个空的 XML 元素 &lt; aop:aspectj-autoproxy &gt; 4、当 Spring IOC 容器侦测到 Bean 配置文件中的 &lt; aop:aspectj-autoproxy&gt; 元素时, 会自动为与 AspectJ 切面匹配的 Bean 创建代理。 4-1、用 AspectJ 注解声明切面 1、要在 Spring 中声明 AspectJ 切面, 只需要在 IOC 容器中将切面声明为 Bean 实例. 当在 Spring IOC 容器中初始化 AspectJ 切面之后, Spring IOC 容器就会为那些与 AspectJ 切面相匹配的 Bean 创建代理.。 2、在 AspectJ 注解中, 切面只是一个带有 @Aspect 注解的 Java 类. 。 3、通知是标注有某种注解的简单的 Java 方法.。 4、AspectJ 支持 5 种类型的通知注解:@Before: 前置通知, 在方法执行之前执行。@After: 后置通知, 在方法执行之后执行 。@AfterRunning: 返回通知, 在方法返回结果之后执行。@AfterThrowing: 异常通知, 在方法抛出异常之后。@Around: 环绕通知, 围绕着方法执行。 4-2、前置通知利用方法签名编写 AspectJ 切入点表达式 方法签名：方法签名由方法名称和一个参数列表（方法的参数的顺序和类型）组成；注意，方法签名不包括方法的返回类型。不包括返回值和访问修饰符 切点表达式： 合并切点表达式 让通知访问当前连接点的细节 4-3、后置通知 4-4、返回通知 返回通知中访问连接点的返回值 4-5、异常通知 4-6、环绕通知 4-7、指定切面的优先级 4-8、重用切入点定义见 合并切入点 4-9、引入通知引入通知是一种特殊的通知类型. 它通过为接口提供实现类, 允许对象动态地实现接口, 就像对象已经在运行时扩展了实现类一样 4-10、用XML 声明切面、切点、通知（包括引入通知） 5、Spring 对JDBC 的支持5-1、Spring xml 中配置 JDBC 模板类和 c3p0 数据源org.springframework.jdbc.core.JdbcTemplate 12345678910111213141516171819202122&lt;context:component-scan base-package="com.atguigu.spring"&gt;&lt;/context:component-scan&gt; &lt;!-- 导入资源文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!-- 配置 C3P0 数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="initialPoolSize" value="$&#123;jdbc.initPoolSize&#125;"&gt;&lt;/property&gt; &lt;property name="maxPoolSize" value="$&#123;jdbc.maxPoolSize&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 Spirng 的 JdbcTemplate --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; 5-2、jdbcTemplate 模板方法测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class JDBCTest &#123; private ApplicationContext ctx = null; private JdbcTemplate jdbcTemplate; private EmployeeDao employeeDao; private DepartmentDao departmentDao; private NamedParameterJdbcTemplate namedParameterJdbcTemplate; &#123; ctx = new ClassPathXmlApplicationContext("applicationContext.xml"); jdbcTemplate = (JdbcTemplate) ctx.getBean("jdbcTemplate"); employeeDao = ctx.getBean(EmployeeDao.class); departmentDao = ctx.getBean(DepartmentDao.class); namedParameterJdbcTemplate = ctx.getBean(NamedParameterJdbcTemplate.class); &#125; /** * 获取单个列的值, 或做统计查询 * 使用 queryForObject(String sql, Class&lt;Long&gt; requiredType) */ @Test public void testQueryForObject2()&#123; String sql = "SELECT count(id) FROM employees"; long count = jdbcTemplate.queryForObject(sql, Long.class); System.out.println(count); &#125; /** * 查到实体类的集合 * 注意调用的不是 queryForList 方法 */ @Test public void testQueryForList()&#123; String sql = "SELECT id, last_name lastName, email FROM employees WHERE id &gt; ?"; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(Employee.class); List&lt;Employee&gt; employees = jdbcTemplate.query(sql, rowMapper,5); System.out.println(employees); &#125; /** * 从数据库中获取一条记录, 实际得到对应的一个对象 * 注意不是调用 queryForObject(String sql, Class&lt;Employee&gt; requiredType, Object... args) 方法! * 而需要调用 queryForObject(String sql, RowMapper&lt;Employee&gt; rowMapper, Object... args) * 1. 其中的 RowMapper 指定如何去映射结果集的行, 常用的实现类为 BeanPropertyRowMapper * 2. 使用 SQL 中列的别名完成列名和类的属性名的映射. 例如 last_name lastName * 3. 不支持级联属性. JdbcTemplate 到底是一个 JDBC 的小工具, 而不是 ORM 框架 */ @Test public void testQueryForObject()&#123; String sql = "SELECT id, last_name lastName, email, dept_id as \"department.id\" FROM employees WHERE id = ?"; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(Employee.class); Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, 1); System.out.println(employee); &#125; /** * 执行批量更新: 批量的 INSERT, UPDATE, DELETE * 最后一个参数是 Object[] 的 List 类型: 因为修改一条记录需要一个 Object 的数组, 那么多条不就需要多个 Object 的数组吗 */ @Test public void testBatchUpdate()&#123; String sql = "INSERT INTO employees(last_name, email, dept_id) VALUES(?,?,?)"; List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;(); batchArgs.add(new Object[]&#123;"AA", "aa@atguigu.com", 1&#125;); batchArgs.add(new Object[]&#123;"BB", "bb@atguigu.com", 2&#125;); batchArgs.add(new Object[]&#123;"CC", "cc@atguigu.com", 3&#125;); batchArgs.add(new Object[]&#123;"DD", "dd@atguigu.com", 3&#125;); batchArgs.add(new Object[]&#123;"EE", "ee@atguigu.com", 2&#125;); jdbcTemplate.batchUpdate(sql, batchArgs); &#125; /** * 执行 INSERT, UPDATE, DELETE */ @Test public void testUpdate()&#123; String sql = "UPDATE employees SET last_name = ? WHERE id = ?"; jdbcTemplate.update(sql, "Jack", 5); &#125; @Test public void testDataSource() throws SQLException &#123; DataSource dataSource = ctx.getBean(DataSource.class); System.out.println(dataSource.getConnection()); &#125; &#125; 5-3、NamedParameterJdbcTemplate 具名参数模板类。12345&lt;!-- 配置 NamedParameterJdbcTemplate, 该对象可以使用具名参数, 其没有无参数的构造器, 所以必须为其构造器指定参数 --&gt; &lt;bean id="namedParameterJdbcTemplate" class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate"&gt; &lt;constructor-arg ref="dataSource"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 测试 1234567891011121314151617181920212223242526272829303132333435/** * 使用具名参数时, 可以使用 update(String sql, SqlParameterSource paramSource) 方法进行更新操作 * 1. SQL 语句中的参数名和类的属性一致! * 2. 使用 SqlParameterSource 的 BeanPropertySqlParameterSource 实现类作为参数. */@Testpublic void testNamedParameterJdbcTemplate2()&#123; String sql = "INSERT INTO employees(last_name, email, dept_id) " + "VALUES(:lastName,:email,:dpetId)"; Employee employee = new Employee(); employee.setLastName("XYZ"); employee.setEmail("xyz@sina.com"); employee.setDpetId(3); SqlParameterSource paramSource = new BeanPropertySqlParameterSource(employee); namedParameterJdbcTemplate.update(sql, paramSource);&#125;/** * 可以为参数起名字. * 1. 好处: 若有多个参数, 则不用再去对应位置, 直接对应参数名, 便于维护 * 2. 缺点: 较为麻烦. */@Testpublic void testNamedParameterJdbcTemplate()&#123; String sql = "INSERT INTO employees(last_name, email, dept_id) VALUES(:ln,:email,:deptid)"; Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(); paramMap.put("ln", "FF"); paramMap.put("email", "ff@atguigu.com"); paramMap.put("deptid", 2); namedParameterJdbcTemplate.update(sql, paramMap);&#125; 6、Spring 对事务的管理6-1、声明式事务 1、编程式事务管理将事务管理代码嵌入到业务方法中来控制事务的提交和回滚。（正常方式） -2、声明式事务管理将事务管理代码从业务方法中分离出来, 以声明的方式来实现事务管理。Spring 通过 Spring AOP 框架支持声明式事务管理。通过使用注解+配置事务管理器。 6-2、事务的传播行为6-3、事务的隔离级别]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub page 搭建个人博客]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%2B%20github%20page%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、如何使用 github 搭建博客？参考链接： https://www.cnblogs.com/jackyroc/p/7681938.html 2、hexo 本地目录各文件以及文件夹的作用？ 主要看 _config.yml 文件。 3、假如自己有多台设备，如何同步管理博客？ 参考链接： https://juejin.im/post/5acf22e6f265da23994eeac9 4、hexo next 主题 Hexo-NexT配置超炫网页效果参考链接： https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html https://juejin.im/post/5bcd2d395188255c3b7dc1db#heading-0 5、hexo 如何发布文章？ https://www.jianshu.com/p/265b2c653e6f https://www.zengyilun.com/HexoEditor/ https://www.cnblogs.com/xingyunblog/p/8681205.html 6、个人定制？ 主题推荐： https://blog.csdn.net/qincidong/article/details/82415271 http://tengj.top/categories/hexo%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97/ https://www.titanjun.top/ https://www.haomwei.com/ 主题的配置文件修改后可热部署，Hexo 的配置文件不可。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章-线性表]]></title>
    <url>%2F2019%2F03%2F25%2F%E7%AC%AC3%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[toc] 1、线性表定义零个或多个数据元素的有限序列。 1、第一元素无前驱、最后一个元素无后继。2、每个元素有且仅有一个前驱、后继。3、相同数据元素。 2、线性表的抽象数据类型 3、线性表的顺序存储结构（数组实现）线性表的两种物理存储结构（顺序存储结构、链式存储结构） 1、顺序存储结构：指的是用一段地址连续的存储单元依次存储线性表的数据元素。 2、插入 3、删除 优点：可以快速存取表中的任意元素值。无需为表示表中元素之间的逻辑关系而增加额外的存储空间。 缺点：插入和删除操作需要移动大量元素；线性表长度发生变化时，难以确定存储长度。造成存储空间的碎片。 4、线性表的链式存储结构链式存储结构： 4-1、单链表 1、为什么使用单链表？数组实现的顺序存储在插入和删除操作时需要移动大量的元素，且存储空间的容量难以确定。 2、单链表的插入、删除、修改、查找实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212package dataStruct.singleLinkedList;/** * 线性表（链表）--节点 * * @Description: TODO: * @author pengguozhen * @date 2018年4月2日 上午11:41:56 */public class LinkedList&lt;T&gt; &#123; private Node head;// 指向链表头节点的引用变量 private Node tail;// 指向链表尾节点的引用变量 int size;// 链表中当前总节点数 public LinkedList() &#123;// 生成链表对象是一个空表 head = null; tail = null; &#125; public int length() &#123;// 返回链表的长度 return size; &#125; /** * @Description: TODO:查询--指定位置的元素 * @return T * @param index * @return */ public T getElement(int index) &#123;// 1、获取指定位置的元素 return findNodeByIndex(index).data; &#125; public Node findNodeByIndex(int index) &#123;// 查找 指定索引位置的节点 if (index &lt; 0 || index &gt; size - 1) &#123; throw new IndexOutOfBoundsException("线性表索引越界"); &#125; if (index == 0 &amp;&amp; head.next == null) &#123;// 如果要插入位置的前一个节点为头结点并且头结点的next 域为null，直接返回头结点。 return head; &#125; Node current = head;// 从头节点开始下移遍历 for (int i = 0; i &lt; size &amp; current.next != null; i++, current = current.next) &#123; if (i == index) &#123; return current; &#125; &#125; return null; &#125; /** * @Description: TODO:查询--指定元素的位置(查找数据域存放的是element的节点位置) * @return int * @param element * @return */ public int findIndexByElement(T element) &#123;// 2、查找 指定元素的位置(查找数据域存放的是element的节点位置) Node current = head;// 从第一个节点开始查找对比数据 for (int i = 0; i &lt; size &amp; current.next != null; i++, current = current.next) &#123; if (current.data.equals(element)) return i; &#125; return -1; &#125; /** * @Description: TODO:插入--在指定位置之前插入一个元素 * @return void * @param index * @param element * 在java中有这么一条规则，声明在方法中的变量在使用时必须要初始化;全局变量如果不赋值会有默认值。 * 例如：int size; 本例中 size 的初始值为 0 */ public void insert(int index, T element) &#123;// 插入 在指定索引位置插入一个元素 if (index &lt; 0 || index &gt; size) &#123; throw new IndexOutOfBoundsException("线性表索引越界"); &#125; if (head == null)// 如果链表为空，直接调用add方法 &#123; add(element); &#125; else // 链表不为空时 &#123; if (index == 0)// 在链表头插入 &#123; addAtHead(element); &#125; else &#123; Node prev = findNodeByIndex(index - 1);// 找到要插入位置的前一个节点 prev.next = new Node(element, prev.next);// 插入后prev的next指向新节点，新节点的next指向原来prev的下一个节点 size++; &#125; &#125; &#125; /* 尾插法 */ public void add(T element) &#123;// 插入 尾插法在每次在链表尾添加新节点 if (head == null) &#123; head = new Node(element, null); tail = head; &#125; else &#123; Node newNode = new Node(element, null); tail.next = newNode; tail = newNode; &#125; size++; &#125; /* 头插法 */ public void addAtHead(T element) &#123; // 插入 头插法在链表头部加入新节点 // 在头部插入新节点，就是让新节点的next指向原来的head,让新节点作为链表的头节点 head = new Node(element, head); // newNode.next = head; // head = newNode; // 如果插入之前是空链表 if (tail == null) &#123; tail = head; &#125; size++; &#125; /** * @Description: TODO:删除--指定位置的节点 并返回删除节点中的元素值 * @return T * @param index * @return */ public T delete(int index) &#123; Node deleteNode = null; if (index &lt; 0 || index &gt; size - 1) &#123; throw new IndexOutOfBoundsException("线性表索引越界"); &#125; if (index == 0)// 删除头节点 &#123; deleteNode = head; head = head.next; &#125; else &#123; Node prev = findNodeByIndex(index - 1);// 获取要删除的节点的前一个节点 deleteNode = prev.next;// 要删除的节点就是prev的next指向的节点 prev.next = deleteNode.next;// 删除以后prev的next指向被删除节点之前所指向的next deleteNode.next = null; &#125; return deleteNode.data; &#125; /** * @Description: TODO:删除--链表中最后一个元素 * @return T * @return */ public T removeLast() &#123; return delete(size - 1); &#125; /** * @Description: TODO:清除链表中所有的元素 * @return void */ public void clear() &#123; head = null; tail = null; size = 0; &#125; /** * 链表的输出 重写toString方法 */ public String toString() &#123; if (isEmpty()) &#123; return "[]"; &#125; else &#123; StringBuilder sb = new StringBuilder("[");// 使用StringBuilder类 for (Node current = head; current != null; current = current.next)// 从head开始遍历 &#123; sb.append(current.data.toString() + ",");// 把节点的数据拼接起来 &#125; int len = sb.length(); return sb.delete(len - 1, len).append("]").toString();// 把最后一个元素的，删除然后加上] &#125; &#125; /** * * @Description: TODO:判断链表是否为空 * @return boolean * @return */ public boolean isEmpty() &#123; return size == 0; &#125; /** * @Description: TODO:内部节点类 * @author pengguozhen * @date 2018年4月2日 下午12:10:44 */ private class Node// 节点类 &#123; private T data;// 数据项 private Node next;// 引用 public Node() &#123;// 空参构造器 &#125; public Node(T data, Node next) &#123;// 初始化节点信息 this.data = data; this.next = next; &#125; &#125;&#125; 测试 12345678910111213141516171819package dataStruct.singleLinkedList;import static org.junit.Assert.*;import org.junit.Test;public class LinkedListTest &#123; LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;(); @Test public void testInsert() &#123; list.add("aa");// 链表头插入 list.addAtHead("cc");// 链表尾插入 list.insert(2, "bb");// 在指定任意位置插入 System.out.println(list.toString()); &#125; &#125; 4-2、静态链表 1、为什么使用静态链表？为没有指针（引用）的编程语言提供链式存储结构实现的思想。 4-3、循环链表4-4、双向链表]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章-算法]]></title>
    <url>%2F2019%2F03%2F25%2F%E7%AC%AC2%E7%AB%A0-%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[toc] 摘自大话数据结构 1、算法和数据结构的关系 重要的数据结构就那么几种、只有配合上算法才能学习到数据结构的用处。 算法：解决特定问题的步骤描述，在计算机中表现为指令的有限序列，每个指令代表一种操作。 2、算法的特性 输入、输出算法具有零个或多个输入、至少有一个输出。算法一定有输出、如果没有输出。算法没有意义，便不需要算法。输出形式可以是打印，也可以是返回一个或多个值。 有穷性指算法不会无穷循环，而没有结果。 确定性执行的每一步都必须确定，相同的输入只能有唯一的输出结果。 可行性每一步都是可以执行的。 3、算法设计的要求好的算法： 正确性 可读性 健壮性 高效率和低存储量 4、算法效率的度量时间复杂度（大O表示法）–渐进时间复杂度 时间复杂度：O（f（n））表示随问题规模n 的增长速度。是一个增长率。即时间复杂度表示随着输入大小 n 的增长，算法时间的增长速度（程序执行次数函数的增长率）； 一般情况下 ，随着 n 的增大 O（n）增长最慢的为最优算法。 5、渐进时间复杂度的计算5-1、由执行次数T(n) 推导 大O(T(n) )推导方法： 1、计算出算法执行次数的函数T(n)。 2、常数项不影响函数的增长速度，c 代表常数。 T(n)=c 时，T(n)&gt;&gt;O(n)=O(1)， T(n) !=c 时，将常数项省略。 12第一个 Hello, World 的例子中 T(n) = 2，所以我们说那个函数(算法)的时间复杂度为 O(1)。T(n) = n + 29，此时时间复杂度为 O(n)。 3、函数高次项对于函数的增长速度影像是最大的，n3的增长速度是远超 n2 的，同时 n2 的增长速度是远超 n 的。 同时因为要求的精度不高，所以我们直接忽略低此项。 12比如T(n) = n^3 + n^2 + 29，此时时间复杂度为 O(n^3)。 4、因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。 12比如T(n) = 3n^3，此时时间复杂度为 O(n^3)。 综合起来：如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。为了方便描述，下文称此为 大O推导法。 5-2、由算法分析出执行次数 T(n)由执行次数推导出 大O 并不困难，困难的是如何从算法中分析出 执行次数 T（n）。基本策略：由内到外、从最深层分析。如果遇到函数调用，要深入函数进行分析。四个便利法则： 1、对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个循环的时间复杂度为 O(n×m)。 12345void aFunc(int n) &#123; for(int i = 0; i &lt; n; i++) &#123; // 循环次数为 n printf("Hello, World!\n"); // 循环体时间复杂度为 O(1) &#125;&#125; 2、对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c…，则这个循环的时间复杂度为 O(n×a×b×c…)。分析的时候应该由里向外分析这些循环。 1234567void aFunc(int n) &#123; for(int i = 0; i &lt; n; i++) &#123; // 循环次数为 n for(int j = 0; j &lt; n; j++) &#123; // 循环次数为 n printf("Hello, World!\n"); // 循环体时间复杂度为 O(1) &#125; &#125;&#125; 3、对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。 123456789101112void aFunc(int n) &#123; // 第一部分时间复杂度为 O(n^2) for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; printf("Hello, World!\n"); &#125; &#125; // 第二部分时间复杂度为 O(n) for(int j = 0; j &lt; n; j++) &#123; printf("Hello, World!\n"); &#125;&#125; 4、对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。 123456789101112131415void aFunc(int n) &#123; if (n &gt;= 0) &#123; // 第一条路径时间复杂度为 O(n^2) for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; printf("输入数据大于等于零\n"); &#125; &#125; &#125; else &#123; // 第二条路径时间复杂度为 O(n) for(int j = 0; j &lt; n; j++) &#123; printf("输入数据小于零\n"); &#125; &#125;&#125; 5-3、常见的 大O 时间复杂度。 1、常数阶O（1） 2、线性阶O（n） 3、对数阶O（logn） 4、平方阶O（n2） 6、最坏时间与平均情况 1、最坏时间：最坏情况运行时间的一种保证，我们提到的时间都是最坏情况的运行时间。 2、平均情况：平均运行时间是最有意义的，它是期望的运行时间。（很难通过分析得到，一般通过数据实验后估算出来。） 总结：对算法的分析：1、根据运行计算平均运行时间。2、分析最坏时间。一般算法分析时指的是最坏运行时间。 7、算法空间复杂度使用存储空间来换取运行时间 8、时间复杂度计算–练习 1、基础题求该方法的时间复杂度1234567void aFunc(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = i; j &lt; n; j++) &#123; printf("Hello World\n"); &#125; &#125;&#125; 参考答案： 1234567当 i = 0 时，内循环执行 n 次运算，当 i = 1 时，内循环执行 n - 1 次运算……当 i = n - 1 时，内循环执行 1 次运算。所以，执行次数 T(n) = n + (n - 1) + (n - 2)……+ 1 = n(n + 1) / 2 = n^2 / 2 + n / 2。根据上文说的 大O推导法 可以知道，此时时间复杂度为 O(n^2)。等差数列 通项公式：an=a1+(n-1)*d。 求和公式：Sn=a1*n+[n*(n-1)*d]/2。 2、进阶题求该方法的时间复杂度 123456void aFunc(int n) &#123; for (int i = 2; i &lt; n; i++) &#123; i *= 2; printf("%i\n", i); &#125;&#125; 参考答案： 12假设循环次数为 t，则循环条件满足 2^t &lt; n。可以得出，执行次数t = log(2)(n)，即 T(n) = log(2)(n)，可见时间复杂度为 O(log(2)(n))，即 O(log n)。 3、再次进阶求该方法的时间复杂度 1234567long aFunc(int n) &#123; if (n &lt;= 1) &#123; return 1; &#125; else &#123; return aFunc(n - 1) + aFunc(n - 2); &#125;&#125; 参考答案： 1234显然运行次数，T(0) = T(1) = 1，同时 T(n) = T(n - 1) + T(n - 2) + 1，这里的 1 是其中的加法算一次执行。显然 T(n) = T(n - 1) + T(n - 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n &gt;= 1 时 T(n) &lt; (5/3)^n，同时当 n &gt; 4 时 T(n) &gt;= (3/2)^n。所以该方法的时间复杂度可以表示为 O((5/3)^n)，简化后为 O(2^n)。可见这个方法所需的运行时间是以指数的速度增长的。如果大家感兴趣，可以试下分别用 1，10，100 的输入大小来测试下算法的运行时间，相信大家会感受到时间复杂度的无穷魅力。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章-数据结构绪论]]></title>
    <url>%2F2019%2F03%2F25%2F%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[[toc]该笔记摘抄于 《大话数据结构》工作中所需要的栈、队列、链表、散列表等结构；查找、排序等算法在开发语言的工具包中都有完美实现，为什么还要学习数据结构弄懂其算法实现的原理？ 1、数据结构起源 从计算机是用来进行数据计算的到现实中的问题需要一些科学有效的手段（表、树、图等数据结构）才能处理。 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。注：这句话应该意思是，数据结构不是研究数值和数值计算的，而是研究对象（对象不止是数值，也可能是类对象或者其他），研究这些对象之间的关系（比如有什么共同点，比如顺序如何），以及操作（比如排序，插入等）。 程序设计的实质是对确定的问题选择一种好的结构、加上设计一种好的算法。即程序设计=数据结构+算法。 2、基本概念和术语123456789101112131415161718192021222324252627282930313233343536373839//数据结构基本概念#include&lt;iostream&gt;using namespace std;/*数据 – 程序的操作对象，用于描述客观事物数据的特点：可以输入到计算机可以被计算机程序处理数据是一个抽象的概念，将其进行分类后得到程序设计语言中的类型。如：int，float，char等等数据项：一个数据元素由若干数据项组成数据元素：组成数据对象的基本单位数据对象：性质相同的数据元素的集合（类似于数组一般）数据元素之间不是独立的，存在特定的关系，这些关系即结构数据结构指数据对象中数据元素之间的关系*///声明一个结构体类型struct Teacher //一种数据类型&#123; char name[32];//数据项 char tile[32];//数据项 int age;//数据项 char addr[128];//数据项&#125;;int main()&#123; struct Teacher t1; //数据元素 struct Teacher tArray[30]; //数据对象 memset(&amp;t1, 0, sizeof(t1)); strcpy(t1.name, "name"); //数据项 strcpy(t1.addr, "addr"); //数据项 strcpy(t1.tile, "addr"); //数据项 t1.age = 1;&#125; 3、逻辑结构与物理结构数据结构分为逻辑结构与物理结构 3-1、逻辑结构是指数据对象中数据元素之间的关系。分为四种。 - 集合结构 - 线性结构 - 树 - 图 3-2、物理结构（存储结构）数据的逻辑结构在计算机中的存储形式。实际上是指如何把数据元素存储到计算机存储器中的 数据元素的存储结构形式有两种： 顺序存储结构：如数组 链式存储结构：如链表，是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以不是连续的。 注：逻辑结构是面向问题的、物理结构是面向计算机的，基本的目标就是将数据及其逻辑关系存储到计算机的内存中。 4、抽象数据类型4-1、数据类型计算机需要对数据进行分类，就分出来很多数据的类型。比如 int，float 等。 4-2、抽象数据类型 1、为什么需要抽象数据类型？无论什么计算机、什么语言都会面临类似的整数运算，我们可以考虑将其抽象出来。抽象是抽取出事物具有的普遍性本质，是对事物的一个概括，是一种思考问题的方式。 2、定义抽象数据类型（ADT）是指一个数学模型及定义在该模型上的一组操作。它仅取决于其逻辑特征，而与计算机内部如何表示和实现无关。比如刚才说得整型，各个计算机，不管大型机、小型机、PC、平板电脑甚至智能手机，都有“整型”类型，也需要整形运算，那么整型其实就是一个抽象数据类型。 Java 中 接本数据类型、引用类型]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2019%2F02%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
