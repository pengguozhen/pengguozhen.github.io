<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第3章-线性表]]></title>
    <url>%2F2019%2F03%2F25%2F%E7%AC%AC3%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[toc] 1、线性表定义零个或多个数据元素的有限序列。 1、第一元素无前驱、最后一个元素无后继。2、每个元素有且仅有一个前驱、后继。3、相同数据元素。 2、线性表的抽象数据类型 3、线性表的顺序存储结构（数组实现）线性表的两种物理存储结构（顺序存储结构、链式存储结构） 1、顺序存储结构：指的是用一段地址连续的存储单元依次存储线性表的数据元素。 2、插入 3、删除 优点：可以快速存取表中的任意元素值。无需为表示表中元素之间的逻辑关系而增加额外的存储空间。 缺点：插入和删除操作需要移动大量元素；线性表长度发生变化时，难以确定存储长度。造成存储空间的碎片。 4、线性表的链式存储结构链式存储结构： 4-1、单链表 1、为什么使用单链表？数组实现的顺序存储在插入和删除操作时需要移动大量的元素，且存储空间的容量难以确定。 2、单链表的插入、删除、修改、查找实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212package dataStruct.singleLinkedList;/** * 线性表（链表）--节点 * * @Description: TODO: * @author pengguozhen * @date 2018年4月2日 上午11:41:56 */public class LinkedList&lt;T&gt; &#123; private Node head;// 指向链表头节点的引用变量 private Node tail;// 指向链表尾节点的引用变量 int size;// 链表中当前总节点数 public LinkedList() &#123;// 生成链表对象是一个空表 head = null; tail = null; &#125; public int length() &#123;// 返回链表的长度 return size; &#125; /** * @Description: TODO:查询--指定位置的元素 * @return T * @param index * @return */ public T getElement(int index) &#123;// 1、获取指定位置的元素 return findNodeByIndex(index).data; &#125; public Node findNodeByIndex(int index) &#123;// 查找 指定索引位置的节点 if (index &lt; 0 || index &gt; size - 1) &#123; throw new IndexOutOfBoundsException("线性表索引越界"); &#125; if (index == 0 &amp;&amp; head.next == null) &#123;// 如果要插入位置的前一个节点为头结点并且头结点的next 域为null，直接返回头结点。 return head; &#125; Node current = head;// 从头节点开始下移遍历 for (int i = 0; i &lt; size &amp; current.next != null; i++, current = current.next) &#123; if (i == index) &#123; return current; &#125; &#125; return null; &#125; /** * @Description: TODO:查询--指定元素的位置(查找数据域存放的是element的节点位置) * @return int * @param element * @return */ public int findIndexByElement(T element) &#123;// 2、查找 指定元素的位置(查找数据域存放的是element的节点位置) Node current = head;// 从第一个节点开始查找对比数据 for (int i = 0; i &lt; size &amp; current.next != null; i++, current = current.next) &#123; if (current.data.equals(element)) return i; &#125; return -1; &#125; /** * @Description: TODO:插入--在指定位置之前插入一个元素 * @return void * @param index * @param element * 在java中有这么一条规则，声明在方法中的变量在使用时必须要初始化;全局变量如果不赋值会有默认值。 * 例如：int size; 本例中 size 的初始值为 0 */ public void insert(int index, T element) &#123;// 插入 在指定索引位置插入一个元素 if (index &lt; 0 || index &gt; size) &#123; throw new IndexOutOfBoundsException("线性表索引越界"); &#125; if (head == null)// 如果链表为空，直接调用add方法 &#123; add(element); &#125; else // 链表不为空时 &#123; if (index == 0)// 在链表头插入 &#123; addAtHead(element); &#125; else &#123; Node prev = findNodeByIndex(index - 1);// 找到要插入位置的前一个节点 prev.next = new Node(element, prev.next);// 插入后prev的next指向新节点，新节点的next指向原来prev的下一个节点 size++; &#125; &#125; &#125; /* 尾插法 */ public void add(T element) &#123;// 插入 尾插法在每次在链表尾添加新节点 if (head == null) &#123; head = new Node(element, null); tail = head; &#125; else &#123; Node newNode = new Node(element, null); tail.next = newNode; tail = newNode; &#125; size++; &#125; /* 头插法 */ public void addAtHead(T element) &#123; // 插入 头插法在链表头部加入新节点 // 在头部插入新节点，就是让新节点的next指向原来的head,让新节点作为链表的头节点 head = new Node(element, head); // newNode.next = head; // head = newNode; // 如果插入之前是空链表 if (tail == null) &#123; tail = head; &#125; size++; &#125; /** * @Description: TODO:删除--指定位置的节点 并返回删除节点中的元素值 * @return T * @param index * @return */ public T delete(int index) &#123; Node deleteNode = null; if (index &lt; 0 || index &gt; size - 1) &#123; throw new IndexOutOfBoundsException("线性表索引越界"); &#125; if (index == 0)// 删除头节点 &#123; deleteNode = head; head = head.next; &#125; else &#123; Node prev = findNodeByIndex(index - 1);// 获取要删除的节点的前一个节点 deleteNode = prev.next;// 要删除的节点就是prev的next指向的节点 prev.next = deleteNode.next;// 删除以后prev的next指向被删除节点之前所指向的next deleteNode.next = null; &#125; return deleteNode.data; &#125; /** * @Description: TODO:删除--链表中最后一个元素 * @return T * @return */ public T removeLast() &#123; return delete(size - 1); &#125; /** * @Description: TODO:清除链表中所有的元素 * @return void */ public void clear() &#123; head = null; tail = null; size = 0; &#125; /** * 链表的输出 重写toString方法 */ public String toString() &#123; if (isEmpty()) &#123; return "[]"; &#125; else &#123; StringBuilder sb = new StringBuilder("[");// 使用StringBuilder类 for (Node current = head; current != null; current = current.next)// 从head开始遍历 &#123; sb.append(current.data.toString() + ",");// 把节点的数据拼接起来 &#125; int len = sb.length(); return sb.delete(len - 1, len).append("]").toString();// 把最后一个元素的，删除然后加上] &#125; &#125; /** * * @Description: TODO:判断链表是否为空 * @return boolean * @return */ public boolean isEmpty() &#123; return size == 0; &#125; /** * @Description: TODO:内部节点类 * @author pengguozhen * @date 2018年4月2日 下午12:10:44 */ private class Node// 节点类 &#123; private T data;// 数据项 private Node next;// 引用 public Node() &#123;// 空参构造器 &#125; public Node(T data, Node next) &#123;// 初始化节点信息 this.data = data; this.next = next; &#125; &#125;&#125; 测试 12345678910111213141516171819package dataStruct.singleLinkedList;import static org.junit.Assert.*;import org.junit.Test;public class LinkedListTest &#123; LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;(); @Test public void testInsert() &#123; list.add("aa");// 链表头插入 list.addAtHead("cc");// 链表尾插入 list.insert(2, "bb");// 在指定任意位置插入 System.out.println(list.toString()); &#125; &#125; 4-2、静态链表 1、为什么使用静态链表？为没有指针（引用）的编程语言提供链式存储结构实现的思想。 4-3、循环链表4-4、双向链表]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章-算法]]></title>
    <url>%2F2019%2F03%2F25%2F%E7%AC%AC2%E7%AB%A0-%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[toc] 摘自大话数据结构 1、算法和数据结构的关系 重要的数据结构就那么几种、只有配合上算法才能学习到数据结构的用处。 算法：解决特定问题的步骤描述，在计算机中表现为指令的有限序列，每个指令代表一种操作。 2、算法的特性 输入、输出算法具有零个或多个输入、至少有一个输出。算法一定有输出、如果没有输出。算法没有意义，便不需要算法。输出形式可以是打印，也可以是返回一个或多个值。 有穷性指算法不会无穷循环，而没有结果。 确定性执行的每一步都必须确定，相同的输入只能有唯一的输出结果。 可行性每一步都是可以执行的。 3、算法设计的要求好的算法： 正确性 可读性 健壮性 高效率和低存储量 4、算法效率的度量时间复杂度（大O表示法）–渐进时间复杂度 时间复杂度：O（f（n））表示随问题规模n 的增长速度。是一个增长率。即时间复杂度表示随着输入大小 n 的增长，算法时间的增长速度（程序执行次数函数的增长率）； 一般情况下 ，随着 n 的增大 O（n）增长最慢的为最优算法。 5、渐进时间复杂度的计算5-1、由执行次数T(n) 推导 大O(T(n) )推导方法： 1、计算出算法执行次数的函数T(n)。 2、常数项不影响函数的增长速度，c 代表常数。 T(n)=c 时，T(n)&gt;&gt;O(n)=O(1)， T(n) !=c 时，将常数项省略。 12第一个 Hello, World 的例子中 T(n) = 2，所以我们说那个函数(算法)的时间复杂度为 O(1)。T(n) = n + 29，此时时间复杂度为 O(n)。 3、函数高次项对于函数的增长速度影像是最大的，n3的增长速度是远超 n2 的，同时 n2 的增长速度是远超 n 的。 同时因为要求的精度不高，所以我们直接忽略低此项。 12比如T(n) = n^3 + n^2 + 29，此时时间复杂度为 O(n^3)。 4、因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。 12比如T(n) = 3n^3，此时时间复杂度为 O(n^3)。 综合起来：如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。为了方便描述，下文称此为 大O推导法。 5-2、由算法分析出执行次数 T(n)由执行次数推导出 大O 并不困难，困难的是如何从算法中分析出 执行次数 T（n）。基本策略：由内到外、从最深层分析。如果遇到函数调用，要深入函数进行分析。四个便利法则： 1、对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个循环的时间复杂度为 O(n×m)。 12345void aFunc(int n) &#123; for(int i = 0; i &lt; n; i++) &#123; // 循环次数为 n printf("Hello, World!\n"); // 循环体时间复杂度为 O(1) &#125;&#125; 2、对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c…，则这个循环的时间复杂度为 O(n×a×b×c…)。分析的时候应该由里向外分析这些循环。 1234567void aFunc(int n) &#123; for(int i = 0; i &lt; n; i++) &#123; // 循环次数为 n for(int j = 0; j &lt; n; j++) &#123; // 循环次数为 n printf("Hello, World!\n"); // 循环体时间复杂度为 O(1) &#125; &#125;&#125; 3、对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。 123456789101112void aFunc(int n) &#123; // 第一部分时间复杂度为 O(n^2) for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; printf("Hello, World!\n"); &#125; &#125; // 第二部分时间复杂度为 O(n) for(int j = 0; j &lt; n; j++) &#123; printf("Hello, World!\n"); &#125;&#125; 4、对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。 123456789101112131415void aFunc(int n) &#123; if (n &gt;= 0) &#123; // 第一条路径时间复杂度为 O(n^2) for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; printf("输入数据大于等于零\n"); &#125; &#125; &#125; else &#123; // 第二条路径时间复杂度为 O(n) for(int j = 0; j &lt; n; j++) &#123; printf("输入数据小于零\n"); &#125; &#125;&#125; 5-3、常见的 大O 时间复杂度。 1、常数阶O（1） 2、线性阶O（n） 3、对数阶O（logn） 4、平方阶O（n2） 6、最坏时间与平均情况 1、最坏时间：最坏情况运行时间的一种保证，我们提到的时间都是最坏情况的运行时间。 2、平均情况：平均运行时间是最有意义的，它是期望的运行时间。（很难通过分析得到，一般通过数据实验后估算出来。） 总结：对算法的分析：1、根据运行计算平均运行时间。2、分析最坏时间。一般算法分析时指的是最坏运行时间。 7、算法空间复杂度使用存储空间来换取运行时间 8、时间复杂度计算–练习 1、基础题求该方法的时间复杂度1234567void aFunc(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = i; j &lt; n; j++) &#123; printf("Hello World\n"); &#125; &#125;&#125; 参考答案： 1234567当 i = 0 时，内循环执行 n 次运算，当 i = 1 时，内循环执行 n - 1 次运算……当 i = n - 1 时，内循环执行 1 次运算。所以，执行次数 T(n) = n + (n - 1) + (n - 2)……+ 1 = n(n + 1) / 2 = n^2 / 2 + n / 2。根据上文说的 大O推导法 可以知道，此时时间复杂度为 O(n^2)。等差数列 通项公式：an=a1+(n-1)*d。 求和公式：Sn=a1*n+[n*(n-1)*d]/2。 2、进阶题求该方法的时间复杂度 123456void aFunc(int n) &#123; for (int i = 2; i &lt; n; i++) &#123; i *= 2; printf("%i\n", i); &#125;&#125; 参考答案： 12假设循环次数为 t，则循环条件满足 2^t &lt; n。可以得出，执行次数t = log(2)(n)，即 T(n) = log(2)(n)，可见时间复杂度为 O(log(2)(n))，即 O(log n)。 3、再次进阶求该方法的时间复杂度 1234567long aFunc(int n) &#123; if (n &lt;= 1) &#123; return 1; &#125; else &#123; return aFunc(n - 1) + aFunc(n - 2); &#125;&#125; 参考答案： 1234显然运行次数，T(0) = T(1) = 1，同时 T(n) = T(n - 1) + T(n - 2) + 1，这里的 1 是其中的加法算一次执行。显然 T(n) = T(n - 1) + T(n - 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n &gt;= 1 时 T(n) &lt; (5/3)^n，同时当 n &gt; 4 时 T(n) &gt;= (3/2)^n。所以该方法的时间复杂度可以表示为 O((5/3)^n)，简化后为 O(2^n)。可见这个方法所需的运行时间是以指数的速度增长的。如果大家感兴趣，可以试下分别用 1，10，100 的输入大小来测试下算法的运行时间，相信大家会感受到时间复杂度的无穷魅力。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章-数据结构绪论]]></title>
    <url>%2F2019%2F03%2F25%2F%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[[toc]该笔记摘抄于 《大话数据结构》工作中所需要的栈、队列、链表、散列表等结构；查找、排序等算法在开发语言的工具包中都有完美实现，为什么还要学习数据结构弄懂其算法实现的原理？ 1、数据结构起源 从计算机是用来进行数据计算的到现实中的问题需要一些科学有效的手段（表、树、图等数据结构）才能处理。 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。注：这句话应该意思是，数据结构不是研究数值和数值计算的，而是研究对象（对象不止是数值，也可能是类对象或者其他），研究这些对象之间的关系（比如有什么共同点，比如顺序如何），以及操作（比如排序，插入等）。 程序设计的实质是对确定的问题选择一种好的结构、加上设计一种好的算法。即程序设计=数据结构+算法。 2、基本概念和术语123456789101112131415161718192021222324252627282930313233343536373839//数据结构基本概念#include&lt;iostream&gt;using namespace std;/*数据 – 程序的操作对象，用于描述客观事物数据的特点：可以输入到计算机可以被计算机程序处理数据是一个抽象的概念，将其进行分类后得到程序设计语言中的类型。如：int，float，char等等数据项：一个数据元素由若干数据项组成数据元素：组成数据对象的基本单位数据对象：性质相同的数据元素的集合（类似于数组一般）数据元素之间不是独立的，存在特定的关系，这些关系即结构数据结构指数据对象中数据元素之间的关系*///声明一个结构体类型struct Teacher //一种数据类型&#123; char name[32];//数据项 char tile[32];//数据项 int age;//数据项 char addr[128];//数据项&#125;;int main()&#123; struct Teacher t1; //数据元素 struct Teacher tArray[30]; //数据对象 memset(&amp;t1, 0, sizeof(t1)); strcpy(t1.name, "name"); //数据项 strcpy(t1.addr, "addr"); //数据项 strcpy(t1.tile, "addr"); //数据项 t1.age = 1;&#125; 3、逻辑结构与物理结构数据结构分为逻辑结构与物理结构 3-1、逻辑结构是指数据对象中数据元素之间的关系。分为四种。 - 集合结构 - 线性结构 - 树 - 图 3-2、物理结构（存储结构）数据的逻辑结构在计算机中的存储形式。实际上是指如何把数据元素存储到计算机存储器中的 数据元素的存储结构形式有两种： 顺序存储结构：如数组 链式存储结构：如链表，是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以不是连续的。 注：逻辑结构是面向问题的、物理结构是面向计算机的，基本的目标就是将数据及其逻辑关系存储到计算机的内存中。 4、抽象数据类型4-1、数据类型计算机需要对数据进行分类，就分出来很多数据的类型。比如 int，float 等。 4-2、抽象数据类型 1、为什么需要抽象数据类型？无论什么计算机、什么语言都会面临类似的整数运算，我们可以考虑将其抽象出来。抽象是抽取出事物具有的普遍性本质，是对事物的一个概括，是一种思考问题的方式。 2、定义抽象数据类型（ADT）是指一个数学模型及定义在该模型上的一组操作。它仅取决于其逻辑特征，而与计算机内部如何表示和实现无关。比如刚才说得整型，各个计算机，不管大型机、小型机、PC、平板电脑甚至智能手机，都有“整型”类型，也需要整形运算，那么整型其实就是一个抽象数据类型。 Java 中 接本数据类型、引用类型]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
