---
title: 第2章-算法
Author: pengguozhen
CreateTime: 2018-3-20
categories:
- 数据结构
tags:
- 数据结构
---
[toc]

摘自大话数据结构

### 1、算法和数据结构的关系
- 重要的数据结构就那么几种、只有配合上算法才能学习到数据结构的用处。
- 算法：解决特定问题的步骤描述，在计算机中表现为指令的有限序列，每个指令代表一种操作。


----------


### 2、算法的特性
- 输入、输出
算法具有零个或多个输入、至少有一个输出。算法一定有输出、如果没有输出。算法没有意义，便不需要算法。输出形式可以是打印，也可以是返回一个或多个值。

- 有穷性
指算法不会无穷循环，而没有结果。
- 确定性
执行的每一步都必须确定，相同的输入只能有唯一的输出结果。
- 可行性
每一步都是可以执行的。


----------


### 3、算法设计的要求

好的算法：
- 正确性
- 可读性
- 健壮性
- 高效率和低存储量


----------


### 4、算法效率的度量
时间复杂度（大O表示法）--渐进时间复杂度

时间复杂度：O（f（n））表示随问题规模n 的增长速度。是一个增长率。即时间复杂度表示随着输入大小 n 的增长，算法时间的增长速度（程序执行次数函数的增长率）；

一般情况下 ，随着 n 的增大 O（n）增长最慢的为最优算法。


----------


### 5、渐进时间复杂度的计算

#### 5-1、由执行次数T(n) 推导 大O(T(n) )

推导方法：
- 1、计算出算法执行次数的函数T(n)。
- 2、常数项不影响函数的增长速度，c 代表常数。
	T(n)=c 时，T(n)>>O(n)=O(1)，
	T(n) !=c 时，将常数项省略。
``` java
第一个 Hello, World 的例子中 T(n) = 2，所以我们说那个函数(算法)的时间复杂度为 O(1)。
T(n) = n + 29，此时时间复杂度为 O(n)。
```

- 3、函数高次项对于函数的增长速度影像是最大的，n<sup>3</sup>的增长速度是远超 n<sup>2</sup> 的，同时 n<sup>2</sup> 的增长速度是远超 n 的。 同时因为要求的精度不高，所以我们直接忽略低此项。

``` java
比如
T(n) = n^3 + n^2 + 29，此时时间复杂度为 O(n^3)。
```

- 4、因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。

``` java
比如
T(n) = 3n^3，此时时间复杂度为 O(n^3)。
```
**综合起来：如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。为了方便描述，下文称此为 大O推导法。**

#### 5-2、由算法分析出执行次数 T(n)

**由执行次数推导出 大O 并不困难，困难的是如何从算法中分析出 执行次数 T（n）。**
**基本策略：由内到外、从最深层分析。如果遇到函数调用，要深入函数进行分析。**
四个便利法则：
- 1、对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个循环的时间复杂度为 O(n×m)。

``` java
void aFunc(int n) {
    for(int i = 0; i < n; i++) {         // 循环次数为 n
        printf("Hello, World!\n");      // 循环体时间复杂度为 O(1)
    }
}
```

- 2、对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c...，则这个循环的时间复杂度为 O(n×a×b×c...)。分析的时候应该由里向外分析这些循环。

``` java
void aFunc(int n) {
    for(int i = 0; i < n; i++) {         // 循环次数为 n
        for(int j = 0; j < n; j++) {       // 循环次数为 n
            printf("Hello, World!\n");      // 循环体时间复杂度为 O(1)
        }
    }
}
```

- 3、对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。

``` java
void aFunc(int n) {
    // 第一部分时间复杂度为 O(n^2)
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            printf("Hello, World!\n");
        }
    }
    // 第二部分时间复杂度为 O(n)
    for(int j = 0; j < n; j++) {
        printf("Hello, World!\n");
    }
}
```


- 4、对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。

``` java
void aFunc(int n) {
    if (n >= 0) {
        // 第一条路径时间复杂度为 O(n^2)
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                printf("输入数据大于等于零\n");
            }
        }
    } else {
        // 第二条路径时间复杂度为 O(n)
        for(int j = 0; j < n; j++) {
            printf("输入数据小于零\n");
        }
    }
}
```


#### 5-3、常见的 大O 时间复杂度。

- 1、常数阶
O（1）
- 2、线性阶
O（n）
- 3、对数阶
O（logn）
- 4、平方阶
O（n<sup>2</sup>）


----------


### 6、最坏时间与平均情况

- 1、最坏时间：最坏情况运行时间的一种保证，我们提到的时间都是最坏情况的运行时间。
- 2、平均情况：平均运行时间是最有意义的，它是期望的运行时间。（很难通过分析得到，一般通过数据实验后估算出来。）

总结：对算法的分析：1、根据运行计算平均运行时间。2、分析最坏时间。
一般算法分析时指的是最坏运行时间。


----------


### 7、算法空间复杂度
使用存储空间来换取运行时间


----------

### 8、时间复杂度计算--练习
- 1、基础题
求该方法的时间复杂度
``` java
void aFunc(int n) {
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            printf("Hello World\n");
        }
    }
}
```
参考答案：

``` xml
当 i = 0 时，内循环执行 n 次运算，当 i = 1 时，内循环执行 n - 1 次运算……当 i = n - 1 时，内循环执行 1 次运算。
所以，执行次数 T(n) = n + (n - 1) + (n - 2)……+ 1 = n(n + 1) / 2 = n^2 / 2 + n / 2。
根据上文说的 大O推导法 可以知道，此时时间复杂度为 O(n^2)。

等差数列 
	通项公式：an=a1+(n-1)*d。
	求和公式：Sn=a1*n+[n*(n-1)*d]/2。
```

- 2、进阶题
求该方法的时间复杂度

``` java
void aFunc(int n) {
    for (int i = 2; i < n; i++) {
        i *= 2;
        printf("%i\n", i);
    }
}
```
参考答案：

``` xml
假设循环次数为 t，则循环条件满足 2^t < n。
可以得出，执行次数t = log(2)(n)，即 T(n) = log(2)(n)，可见时间复杂度为 O(log(2)(n))，即 O(log n)。
```

- 3、再次进阶
求该方法的时间复杂度

``` java
long aFunc(int n) {
    if (n <= 1) {
        return 1;
    } else {
        return aFunc(n - 1) + aFunc(n - 2);
    }
}
```
参考答案：

``` xml
显然运行次数，T(0) = T(1) = 1，同时 T(n) = T(n - 1) + T(n - 2) + 1，这里的 1 是其中的加法算一次执行。
显然 T(n) = T(n - 1) + T(n - 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n >= 1 时 T(n) < (5/3)^n，同时当 n > 4 时 T(n) >= (3/2)^n。
所以该方法的时间复杂度可以表示为 O((5/3)^n)，简化后为 O(2^n)。
可见这个方法所需的运行时间是以指数的速度增长的。如果大家感兴趣，可以试下分别用 1，10，100 的输入大小来测试下算法的运行时间，相信大家会感受到时间复杂度的无穷魅力。
```


