<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ta的笑很甜</title>
  
  <subtitle>你好</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-25T01:02:58.879Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ta 的笑很甜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二、VMware 中 Linux 网络配置及环境初始化</title>
    <link href="http://yoursite.com/2019/09/25/%E4%BA%8C%E3%80%81VMware%20%E4%B8%AD%20Linux%20%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2019/09/25/二、VMware 中 Linux 网络配置及环境初始化/</id>
    <published>2019-09-25T01:02:58.879Z</published>
    <updated>2019-09-25T01:02:58.879Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h5 id="1、linux-网络连接问题"><a href="#1、linux-网络连接问题" class="headerlink" title="1、linux 网络连接问题"></a>1、linux 网络连接问题</h5><p>弹出界面eth0：错误：激活连接失败：Device not managed by NetworkManager or unavailable</p><p>参考：<a href="https://my.oschina.net/u/2324318/blog/1814002" target="_blank" rel="noopener">https://my.oschina.net/u/2324318/blog/1814002</a></p><h5 id="2、linux-配置静态ip，方便-xshell-远程"><a href="#2、linux-配置静态ip，方便-xshell-远程" class="headerlink" title="2、linux 配置静态ip，方便 xshell 远程"></a>2、linux 配置静态ip，方便 xshell 远程</h5><h6 id="2-1、修改网络配置文件"><a href="#2-1、修改网络配置文件" class="headerlink" title="2-1、修改网络配置文件"></a>2-1、修改网络配置文件</h6><p><a href="https://blog.csdn.net/attend_/article/details/79025172" target="_blank" rel="noopener">https://blog.csdn.net/attend_/article/details/79025172</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">EVICE=eth0</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">UUID=d3349997-0d0c-48c4-be1c-189f960ebfdd</span><br><span class="line">ONBOOT=yes</span><br><span class="line">NM_CONTROLLED=yes</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=192.168.2.129</span><br><span class="line">GATEWAY=192.168.2.1</span><br><span class="line">DNS1=222.168.160.70</span><br><span class="line">DNS2=114.114.114.114</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=yes</span><br><span class="line">IPV6INIT=no</span><br><span class="line">NAME="System eth0"</span><br><span class="line">HWADDR=00:0c:29:b3:31:cd</span><br><span class="line">LAST_CONNECT=1556613678</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">USERCTL=no</span><br><span class="line">PEERDNS=yes</span><br></pre></td></tr></table></figure><h6 id="2-2、静态ip-配置好后，重启网络服务-service-network-restart"><a href="#2-2、静态ip-配置好后，重启网络服务-service-network-restart" class="headerlink" title="2-2、静态ip 配置好后，重启网络服务 service network restart"></a>2-2、静态ip 配置好后，重启网络服务 service network restart</h6><h6 id="2-3、关闭防火墙-service-iptables-stop"><a href="#2-3、关闭防火墙-service-iptables-stop" class="headerlink" title="2-3、关闭防火墙 service iptables stop"></a>2-3、关闭防火墙 service iptables stop</h6><h6 id="2-4、编辑-虚拟网络编辑器内-NAT-设置子网ip-和网关"><a href="#2-4、编辑-虚拟网络编辑器内-NAT-设置子网ip-和网关" class="headerlink" title="2-4、编辑-虚拟网络编辑器内 NAT 设置子网ip 和网关"></a>2-4、编辑-虚拟网络编辑器内 NAT 设置子网ip 和网关</h6><p>(网关为windows ipv4 默认网关例如 192.168.2.1，子网ip 192.168.2.0 必须和网关在同一网段，2 为网段)。</p><h6 id="2-5、虚拟机无法ping-通主机ip，但是可以ping-通网关https-blog-csdn-net-sinat-25306771-article-details-52761926"><a href="#2-5、虚拟机无法ping-通主机ip，但是可以ping-通网关https-blog-csdn-net-sinat-25306771-article-details-52761926" class="headerlink" title="2-5、虚拟机无法ping 通主机ip，但是可以ping 通网关https://blog.csdn.net/sinat_25306771/article/details/52761926"></a>2-5、虚拟机无法ping 通主机ip，但是可以ping 通网关<a href="https://blog.csdn.net/sinat_25306771/article/details/52761926" target="_blank" rel="noopener">https://blog.csdn.net/sinat_25306771/article/details/52761926</a></h6><h6 id="2-6、网络已通，ssh无法连接服务器-？"><a href="#2-6、网络已通，ssh无法连接服务器-？" class="headerlink" title="2-6、网络已通，ssh无法连接服务器 ？"></a>2-6、网络已通，ssh无法连接服务器 ？</h6><p>vmnet8 使用动态分配的ip 与虚拟机ip 不在同一网段导致ssh 不能连接。<br>参考：<a href="https://www.jianshu.com/p/ee44f0cd7743" target="_blank" rel="noopener">https://www.jianshu.com/p/ee44f0cd7743</a></p><h5 id="4、如何为linux-换镜像仓库，yum安装找不到镜像仓库？-设置镜像仓库"><a href="#4、如何为linux-换镜像仓库，yum安装找不到镜像仓库？-设置镜像仓库" class="headerlink" title="4、如何为linux 换镜像仓库，yum安装找不到镜像仓库？ 设置镜像仓库"></a>4、如何为linux 换镜像仓库，yum安装找不到镜像仓库？ 设置镜像仓库</h5><p>参考：<a href="https://blog.csdn.net/inslow/article/details/54177191" target="_blank" rel="noopener">https://blog.csdn.net/inslow/article/details/54177191</a></p><h5 id="5、yum-安装mysql-不成功镜像仓库导致。。建议官网下载压缩包解压安装。"><a href="#5、yum-安装mysql-不成功镜像仓库导致。。建议官网下载压缩包解压安装。" class="headerlink" title="5、yum 安装mysql 不成功镜像仓库导致。。建议官网下载压缩包解压安装。"></a>5、yum 安装mysql 不成功镜像仓库导致。。建议官网下载压缩包解压安装。</h5><p>参考：<a href="http://orchome.com/238" target="_blank" rel="noopener">http://orchome.com/238</a><br><a href="https://blog.csdn.net/pengzhenjie36/article/details/75053059" target="_blank" rel="noopener">https://blog.csdn.net/pengzhenjie36/article/details/75053059</a></p><h5 id="6、RPM-包安装方式的MySQL卸载"><a href="#6、RPM-包安装方式的MySQL卸载" class="headerlink" title="6、RPM 包安装方式的MySQL卸载"></a>6、RPM 包安装方式的MySQL卸载</h5><p>参考：<a href="https://www.jianshu.com/p/7b8c4dea6829" target="_blank" rel="noopener">https://www.jianshu.com/p/7b8c4dea6829</a></p><h5 id="7、更新yum-源（使用yum-下载安装软件，yum-仓库使用源一定要配置好）"><a href="#7、更新yum-源（使用yum-下载安装软件，yum-仓库使用源一定要配置好）" class="headerlink" title="7、更新yum 源（使用yum 下载安装软件，yum 仓库使用源一定要配置好）"></a>7、更新yum 源（使用yum 下载安装软件，yum 仓库使用源一定要配置好）</h5><p>参考：<a href="https://blog.csdn.net/u013850277/article/details/79240695" target="_blank" rel="noopener">https://blog.csdn.net/u013850277/article/details/79240695</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h5 id=&quot;1、linux-网络连接问题&quot;&gt;&lt;a href=&quot;#1、linux-网络连接问题&quot; class=&quot;headerlink&quot; title=&quot;1、linux 网络连接问题&quot;&gt;&lt;/a&gt;1、linux 网络连接问题&lt;/h5&gt;&lt;p&gt;弹出界面eth0：
      
    
    </summary>
    
      <category term="Linux 学习" scheme="http://yoursite.com/categories/Linux-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux 学习" scheme="http://yoursite.com/tags/Linux-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>一、Linux操作手册</title>
    <link href="http://yoursite.com/2019/09/25/%E4%B8%80%E3%80%81Linux%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2019/09/25/一、Linux操作手册/</id>
    <published>2019-09-25T01:02:24.265Z</published>
    <updated>2019-09-25T01:02:24.266Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h5 id="一、Linux-简介"><a href="#一、Linux-简介" class="headerlink" title="一、Linux 简介"></a>一、Linux 简介</h5><hr><h5 id="二、关于操作系统的选型"><a href="#二、关于操作系统的选型" class="headerlink" title="二、关于操作系统的选型"></a>二、关于操作系统的选型</h5><hr><h5 id="三、Linux-安装-Ubuntu-Server-16-04-X64"><a href="#三、Linux-安装-Ubuntu-Server-16-04-X64" class="headerlink" title="三、Linux-安装 Ubuntu Server 16.04 X64"></a>三、Linux-安装 Ubuntu Server 16.04 X64</h5><hr><h5 id="四、服务器远程控制及网络配置。"><a href="#四、服务器远程控制及网络配置。" class="headerlink" title="四、服务器远程控制及网络配置。"></a>四、服务器远程控制及网络配置。</h5><h6 id="4-1、配置网络"><a href="#4-1、配置网络" class="headerlink" title="4-1、配置网络"></a>4-1、配置网络</h6><p>参考：<a href="https://app.yinxiang.com/shard/s68/nl/15711850/0d438b05-6250-4e78-966b-d14063c11486" target="_blank" rel="noopener">VMware 中 Linux 网络配置及环境初始化</a></p><blockquote><p>安装 ssh</p></blockquote><hr><h5 id="五、目录结构说明"><a href="#五、目录结构说明" class="headerlink" title="五、目录结构说明"></a>五、目录结构说明</h5><p><img src="https://i.loli.net/2019/08/27/ypsn5DcH9G7uI2F.png" alt="目录结构"></p><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>bin</td><td>存放二进制可执行文件(ls,cat,mkdir等)</td></tr><tr><td>boot</td><td>存放用于系统引导时使用的各种文件</td></tr><tr><td>dev</td><td>用于存放设备文件</td></tr><tr><td>etc</td><td>存放系统配置文件</td></tr><tr><td>home</td><td>存放所有用户文件的根目录</td></tr><tr><td>lib</td><td>存放跟文件系统中的程序运行所需要的共享库及内核模块</td></tr><tr><td>mnt</td><td>系统管理员安装临时文件系统的安装点</td></tr><tr><td>opt</td><td>额外安装的可选应用程序包所放置的位置</td></tr><tr><td>proc</td><td>虚拟文件系统，存放当前内存的映射</td></tr><tr><td>root</td><td>超级用户目录</td></tr><tr><td>sbin</td><td>存放二进制可执行文件，只有root才能访问</td></tr><tr><td>tmp</td><td>用于存放各种临时文件</td></tr><tr><td>usr</td><td>用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录</td></tr><tr><td>var</td><td>用于存放运行时需要改变数据的文件</td></tr></tbody></table><hr><h5 id="六、操作文件目录命令"><a href="#六、操作文件目录命令" class="headerlink" title="六、操作文件目录命令"></a>六、操作文件目录命令</h5><table><thead><tr><th>命令</th><th>说明</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>ls</td><td>显示文件和目录列表</td><td>ls [-alrtAFR] [name…]</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-l</td><td>列出文件的详细信息</td></tr><tr><td></td><td></td><td></td><td>-a</td><td>列出当前目录所有文件，包含隐藏文件</td></tr><tr><td>mkdir</td><td>创建目录</td><td>mkdir [-p] dirName</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-p</td><td>父目录不存在情况下先生成父目录</td></tr><tr><td>cd</td><td>切换目录</td><td>cd [dirName]</td><td></td><td></td></tr><tr><td>touch</td><td>生成一个空文件</td><td></td><td></td><td></td></tr><tr><td>echo</td><td>生成一个带内容文件</td><td>echo abcd &gt; 1.txt，echo 1234 &gt;&gt; 1.txt</td><td></td><td></td></tr><tr><td>cat</td><td>显示文本文件内容</td><td>cat [-AbeEnstTuv] [–help] [–version] fileName</td><td></td><td></td></tr><tr><td>cp</td><td>复制文件或目录</td><td>cp [options] source dest</td><td></td><td></td></tr><tr><td>rm</td><td>删除文件</td><td>rm [options] name…</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-f</td><td>强制删除文件或目录</td></tr><tr><td></td><td></td><td></td><td>-r</td><td>同时删除该目录下的所有文件</td></tr><tr><td>mv</td><td>移动文件或目录</td><td>mv [options] source dest</td><td></td><td></td></tr><tr><td>find</td><td>在文件系统中查找指定的文件</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-name</td><td>文件名</td></tr><tr><td>grep</td><td>在指定的文本文件中查找指定的字符串</td><td></td><td></td><td></td></tr><tr><td>tree</td><td>用于以树状图列出目录的内容</td><td></td><td></td><td></td></tr><tr><td>pwd</td><td>显示当前工作目录</td><td></td><td></td><td></td></tr><tr><td>ln</td><td>建立软链接</td><td></td><td></td><td></td></tr><tr><td>more</td><td>分页显示文本文件内容</td><td></td><td></td><td></td></tr><tr><td>head</td><td>显示文件开头内容</td><td></td><td></td><td></td></tr><tr><td>tail</td><td>显示文件结尾内容</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-f</td><td>跟踪输出</td></tr></tbody></table><hr><h5 id="七、系统管理命令"><a href="#七、系统管理命令" class="headerlink" title="七、系统管理命令"></a>七、系统管理命令</h5><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>stat</td><td>显示指定文件的相关信息,比ls命令显示内容更多</td></tr><tr><td>who</td><td>显示在线登录用户</td></tr><tr><td>hostname</td><td>显示主机名称</td></tr><tr><td>uname</td><td>显示系统信息</td></tr><tr><td>top</td><td>显示当前系统中耗费资源最多的进程</td></tr><tr><td>ps</td><td>显示瞬间的进程状态</td></tr><tr><td>du</td><td>显示指定的文件（目录）已使用的磁盘空间的总量</td></tr><tr><td>df</td><td>显示文件系统磁盘空间的使用情况</td></tr><tr><td>free</td><td>显示当前内存和交换空间的使用情况</td></tr><tr><td>ifconfig</td><td>显示网络接口信息</td></tr><tr><td>ping</td><td>测试网络的连通性</td></tr><tr><td>netstat</td><td>显示网络状态信息</td></tr><tr><td>clear</td><td>清屏</td></tr><tr><td>kill</td><td>杀死一个进程</td></tr></tbody></table><hr><h5 id="八、重启与压缩命令"><a href="#八、重启与压缩命令" class="headerlink" title="八、重启与压缩命令"></a>八、重启与压缩命令</h5><h6 id="重启命令"><a href="#重启命令" class="headerlink" title="重启命令"></a>重启命令</h6><blockquote><p>shutdown 命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。</p></blockquote><table><thead><tr><th>命令</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>shutdown</td><td>shutdown [-t seconds] [-rkhncfF] time [message]</td><td></td><td></td></tr><tr><td></td><td></td><td>-t seconds</td><td>设定在几秒钟之后进行关机程序</td></tr><tr><td></td><td></td><td>-k</td><td>并不会真的关机，只是将警告讯息传送给所有只用者</td></tr><tr><td></td><td></td><td>-r</td><td>关机后重新开机（重启）</td></tr><tr><td></td><td></td><td>-h</td><td>关机后停机</td></tr><tr><td></td><td></td><td>-n</td><td>不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机</td></tr><tr><td></td><td></td><td>-c</td><td>取消目前已经进行中的关机动作</td></tr><tr><td></td><td></td><td>-f</td><td>关机时，不做 fcsk 动作(检查 Linux 档系统)</td></tr><tr><td></td><td></td><td>-F</td><td>关机时，强迫进行 fsck 动作</td></tr><tr><td></td><td></td><td>time</td><td>设定关机的时间</td></tr><tr><td></td><td></td><td>message</td><td>传送给所有使用者的警告讯息</td></tr></tbody></table><h6 id="解压缩命令"><a href="#解压缩命令" class="headerlink" title="解压缩命令"></a>解压缩命令</h6><table><thead><tr><th>命令</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>tar</td><td>tar [-cxzjvf] 压缩打包文档的名称 欲打包目录</td><td></td><td></td></tr><tr><td></td><td></td><td>-c</td><td>建立一个归档文件的参数指令</td></tr><tr><td></td><td></td><td>-x</td><td>解开一个归档文件的参数指令</td></tr><tr><td></td><td></td><td>-z</td><td>是否需要用 gzip 压缩</td></tr><tr><td></td><td></td><td>-j</td><td>是否需要用 bzip2 压缩</td></tr><tr><td></td><td></td><td>-v</td><td>压缩的过程中显示文件</td></tr><tr><td></td><td></td><td>-f</td><td>使用档名，在 f 之后要立即接档名</td></tr><tr><td></td><td></td><td>-tf</td><td>查看归档文件里面的文件</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">实例：</span><br><span class="line">1、tar 命令打包</span><br><span class="line">tar -cvf 打包名 欲打包目录 </span><br><span class="line">tar -cvf xxx.tar filename</span><br><span class="line"></span><br><span class="line">2、tar 命令解包</span><br><span class="line">tar -xvf xxx.tar</span><br></pre></td></tr></table></figure><hr><h5 id="九、Linux-编辑器"><a href="#九、Linux-编辑器" class="headerlink" title="九、Linux 编辑器"></a>九、Linux 编辑器</h5><h6 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h6><blockquote><p>运行模式<br>编辑模式：等待编辑命令输入。<br>插入模式：编辑模式下，输入 i 进入插入模式，插入文本信息。<br>命令模式：在编辑模式下，输入 : 进行命令模式。</p></blockquote><blockquote><p>:命令<br>q 直接退出vi<br>:wq 保存后退出vi ，并可以新建文件<br>:q! 强制退出<br>:w file 将当前内容保存成某个文件<br>:set number 在编辑文件显示行号<br>:set nonumber    在编辑文件不显示行号</p></blockquote><hr><h5 id="十、Linux-软件包管理"><a href="#十、Linux-软件包管理" class="headerlink" title="十、Linux 软件包管理"></a>十、Linux 软件包管理</h5><h6 id="10-1、使用-Root-用户"><a href="#10-1、使用-Root-用户" class="headerlink" title="10-1、使用 Root 用户"></a>10-1、使用 Root 用户</h6><blockquote><p>在实际生产操作中，我们基本上都是使用超级管理员账户操作 Linux 系统，也就是 Root 用户，Linux 系统默认是关闭 Root 账户的，我们需要为 Root 用户设置一个初始密码以方便我们使用。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1、设置 Root 账户密码</span><br><span class="line">sudo passwd root</span><br><span class="line"></span><br><span class="line">2、切换到 Root</span><br><span class="line">su root</span><br><span class="line"></span><br><span class="line">3、设置远程允许远程登录 Root</span><br><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Authentication:</span></span><br><span class="line">LoginGraceTime 120</span><br><span class="line"><span class="meta">#</span><span class="bash">PermitRootLogin without-password     //注释此行</span></span><br><span class="line">PermitRootLogin yes                             //加入此行</span><br><span class="line">StrictModes yes</span><br><span class="line"></span><br><span class="line">重启服务</span><br><span class="line">service ssh restart</span><br></pre></td></tr></table></figure><h6 id="10-2、用户账户说明"><a href="#10-2、用户账户说明" class="headerlink" title="10-2、用户账户说明"></a>10-2、用户账户说明</h6><blockquote><p>普通用户：<br>普通用户在系统上的任务是进行普通操作。</p></blockquote><blockquote><p>超级管理员：<br>管理员在系统上的任务是对普通用户和整个系统进行管理。对系统具有绝对的控制权，能够对系统进行一切操作。用 root 表示，root 用户在系统中拥有最高权限，默认下 Ubuntu 用户的 root 用户是不能登录的。</p></blockquote><blockquote><p>安装时创建的系统用户：<br>此用户创建时被添加到 admin 组中，在 Ubuntu 中，admin 组中的用户默认是可以使用 sudo 命令来执行只有管理员才能执行的命令的。如果不使用 sudo 就是一个普通用户。</p></blockquote><h6 id="10-3、组账户说明"><a href="#10-3、组账户说明" class="headerlink" title="10-3、组账户说明"></a>10-3、组账户说明</h6><blockquote><p>私有组：<br>当创建一个用户时没有指定属于哪个组，Linux 就会建立一个与用户同名的私有组，此私有组只含有该用户。<br>标准组：<br>当创建一个用户时可以选定一个标准组，如果一个用户同时属于多个组时，登录后所属的组为主组，其他的为附加组。</p></blockquote><h6 id="10-4、账户系统文件说明"><a href="#10-4、账户系统文件说明" class="headerlink" title="10-4、账户系统文件说明"></a>10-4、账户系统文件说明</h6><blockquote><p>1、/etc/passwd<br>每一行代表一个账号，众多账号是系统正常运行所必须的，例如 bin，nobody 每行定义一个用户账户，此文件对所有用户可读。<br>每行账户包含如下信息：<br>root:x:0:0:root:/root:/bin/bash</p></blockquote><ul><li>用户名： 就是账号，用来对应 UID，root UID 是 0。</li><li>口令： 密码，早期 UNIX 系统密码存在此字段，由于此文件所有用户都可以读取，密码容易泄露，后来这个字段数据就存放到 /etc/shadow 中，这里只能看到 X。</li><li>用户标示号（UID）： 系统内唯一，root 用户的 UID 为 0，普通用户从 1000 开始，1-999 是系统的标准账户，500-65536 是可登陆账号。</li><li>组标示号（GID）： 与 /etc/group 相关用来规定组名和 GID 相对应。</li><li>注释： 注释账号</li><li>宿主目录（主文件夹）： 用户登录系统后所进入的目录 root 在 /root/itcast</li><li>命令解释器（shell）： 指定该用户使用的 shell ，默认的是 /bin/bash</li></ul><blockquote><p>2、/etc/shadow<br>为了增加系统的安全性，用户口令通常用 shadow passwords 保护。只有 root 可读。每行包含如下信息：<br>root:$6$Reu571.V$Ci/kd.OTzaSGU.TagZ5KjYx2MLzQv2IkZ24E1.yeTT3Pp4o/yniTjus/rRaJ92Z18MVy6suf1W5uxxurqssel.:17465:0:99999:7:::</p></blockquote><ul><li>账号名称： 需要和 /etc/passwd 一致。</li><li>密码： 经过加密，虽然加密，但不表示不会被破解，该文件默认权限如下：<ul><li>-rw——- 1 root root 1560 Oct 26 17:20 passwd-</li><li>只有root能都读写</li></ul></li><li>最近修改密码日期： 从1970-1-1起，到用户最后一次更改口令的天数。</li><li>密码最小时间间隔： 从1970-1-1起，到用户可以更改口令的天数。</li><li>密码最大时间间隔： 从1970-1-1起，必须更改的口令天数。</li><li>密码到期警告时间： 在口令过期之前几天通知。</li><li>密码到期后账号宽限时间。</li><li>密码到期禁用账户时间： 在用户口令过期后到禁用账户的天数。</li><li>保留。</li></ul><blockquote><p>3、/etc/group<br>用户组的配置文件 ：root:x:0:</p></blockquote><ul><li>用户组名称</li><li>用户组密码： 给用户组管理员使用，通常不用。</li><li>GID： 用户组的ID。</li><li>此用户支持的账号名称： 一个账号可以加入多个用户组，例如想要 itcast 加入 root 这个用户组，将该账号填入该字段即可 root❌0:root, icast 将用户进行分组是 Linux 对用户进行管理及控制访问权限的一种手段。一个中可以有多个用户，一个用户可以同时属于多个组。该文件对所有用户可读。</li></ul><blockquote><p>4、/etc/gshadow<br>该文件用户定义用户组口令，组管理员等信息只有root用户可读。<br>root:*::</p></blockquote><ul><li>用户组名。</li><li>密码列。</li><li>用户组管理员的账号。</li><li>用户组所属账号。</li></ul><h6 id="10-5、账户管理常用命令"><a href="#10-5、账户管理常用命令" class="headerlink" title="10-5、账户管理常用命令"></a>10-5、账户管理常用命令</h6><blockquote><p>1、增加用户<br>2、修改用户<br>3、删除用户<br>4、组账户维护<br>5、口令维护<br>6、用户和组状态</p></blockquote><hr><h5 id="十一、Linux-用户和组管理"><a href="#十一、Linux-用户和组管理" class="headerlink" title="十一、Linux 用户和组管理"></a>十一、Linux 用户和组管理</h5><h5 id="十二、Linux-文件权限管理"><a href="#十二、Linux-文件权限管理" class="headerlink" title="十二、Linux 文件权限管理"></a>十二、Linux 文件权限管理</h5><h5 id="十三、Linux-安装-Java"><a href="#十三、Linux-安装-Java" class="headerlink" title="十三、Linux 安装 Java"></a>十三、Linux 安装 Java</h5><h5 id="十四、Linux-安装-Tomcat"><a href="#十四、Linux-安装-Tomcat" class="headerlink" title="十四、Linux 安装 Tomcat"></a>十四、Linux 安装 Tomcat</h5><h5 id="十五、Linux-安装-MySQL"><a href="#十五、Linux-安装-MySQL" class="headerlink" title="十五、Linux 安装 MySQL"></a>十五、Linux 安装 MySQL</h5><h5 id="十六、部署应用到生产环境"><a href="#十六、部署应用到生产环境" class="headerlink" title="十六、部署应用到生产环境"></a>十六、部署应用到生产环境</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h5 id=&quot;一、Linux-简介&quot;&gt;&lt;a href=&quot;#一、Linux-简介&quot; class=&quot;headerlink&quot; title=&quot;一、Linux 简介&quot;&gt;&lt;/a&gt;一、Linux 简介&lt;/h5&gt;&lt;hr&gt;
&lt;h5 id=&quot;二、关于操作系统的选型&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="Linux 学习" scheme="http://yoursite.com/categories/Linux-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux 学习" scheme="http://yoursite.com/tags/Linux-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Maven使用手册</title>
    <link href="http://yoursite.com/2019/05/16/Maven%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2019/05/16/Maven使用手册/</id>
    <published>2019-05-16T08:01:46.212Z</published>
    <updated>2019-05-16T08:01:46.212Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]<br><strong>Maven</strong> </p><p><strong>导言：生产环境下开发不再是一个项目一个工程，而是每一个模块创建一个工程，而多个模块整合在一起就需要使用到像 Maven 这样的构建工具。</strong> </p><hr><h5 id="一、为什么使用Maven-（Why）"><a href="#一、为什么使用Maven-（Why）" class="headerlink" title="一、为什么使用Maven?（Why）"></a>一、为什么使用Maven?（Why）</h5><h6 id="1-1、真的需要吗？"><a href="#1-1、真的需要吗？" class="headerlink" title="1.1、真的需要吗？"></a>1.1、真的需要吗？</h6><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Maven</span> 是干什么用的？这是很多同学在刚开始接触 Maven 时最大的问题。之所以会提出这个问题，是因为即使不使用 Maven 我们仍然可以进行 B/S 结构项目的开发。从表述层、业务逻辑层到持久化层再到数据库都有成熟的解决方案——不使用 Maven 我们一样可以开发项目啊？</span><br></pre></td></tr></table></figure><p> <img src="https://i.loli.net/2019/05/16/5cdd0f529ad3d24829.jpg" alt="分层"><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里给大家纠正一个误区，Maven 并不是直接用来辅助编码的，它战斗的岗位并不是以上各层。所以我们有必要通过企业开发中的实际需求来看一看哪些方面是我们现有技术的不足。</span><br></pre></td></tr></table></figure></p><h6 id="1-2、究竟为什么？"><a href="#1-2、究竟为什么？" class="headerlink" title="1.2、究竟为什么？"></a>1.2、究竟为什么？</h6><p>为什么要使用 Maven？它能帮助我们解决什么问题？ </p><ul><li><strong>①、添加第三方 jar 包</strong> </li></ul><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在今天的 JavaEE 开发领域，有大量的第三方框架和工具可以供我们使用。要使用这些 jar 包最简单的方法就是复制粘贴到 WEB-INF/<span class="class"><span class="keyword">lib</span> 目录下。但是这会导致每次创建一个新的工程就需要将 <span class="title">jar</span> 包重复复制到 <span class="title">lib</span> 目录下，从而造成工作区中存在大量重复的文件，让我们的工程显得很臃肿。 </span></span><br><span class="line">而使用 Maven 后每个 jar 包本身只在本地仓库中保存一份，需要 jar 包的工程只需要以坐标的方式简单的引用一下就可以了。不仅极大的节约了存储空间，让项目更轻巧，更避免了重复文件太多而造成的混乱。</span><br></pre></td></tr></table></figure><ul><li><strong>②、jar 包之间的依赖关系</strong> </li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jar </span>包往往不是孤立存在的，很多 <span class="keyword">jar </span>包都需要在其他 <span class="keyword">jar </span>包的支持下才能够正常工作，我们称之为 <span class="keyword">jar </span>包之间的依赖关系。最典型的例子是：commons-fileupload-1.<span class="number">3</span>.<span class="keyword">jar </span>依赖于 commons-io-2.<span class="number">0</span>.<span class="number">1</span>.<span class="keyword">jar，如果没有 </span>IO 包，FileUpload 包就不能正常工作。 </span><br><span class="line">那么问题来了，你知道你所使用的所有 <span class="keyword">jar </span>包的依赖关系吗？当你拿到一个新的从未使用过的 <span class="keyword">jar </span>包，你如何得知他需要哪些 <span class="keyword">jar </span>包的支持呢？如果不了解这个情况，导入的 <span class="keyword">jar </span>包不够，那么现有的程序将不能正常工作。再进一步，当你的项目中需要用到上百个 <span class="keyword">jar </span>包时，你还会人为的，手工的逐一确认它们依赖的其他 <span class="keyword">jar </span>包吗？这简直是不可想象的。 </span><br><span class="line">而引入 Maven 后，Maven 就可以替我们自动的将当前 <span class="keyword">jar </span>包所依赖的其他所有 <span class="keyword">jar </span>包全部导入进来，无需人工参与，节约了我们大量的时间和精力。用实际例子来说明就是：通过 Maven 导入 commons-fileupload-1.<span class="number">3</span>.<span class="keyword">jar </span>后，commons-io-2.<span class="number">0</span>.<span class="number">1</span>.<span class="keyword">jar </span>会被自动导入，程序员不必了解这个依赖关系。</span><br></pre></td></tr></table></figure><ul><li><strong>③、获取第三方 jar 包</strong> </li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">JavaEE </span>开发中需要使用到的 <span class="keyword">jar </span>包种类繁多，几乎每个 <span class="keyword">jar </span>包在其本身的官网上的获取方式都不尽相同。为了查找一个 <span class="keyword">jar </span>包找遍互联网，身心俱疲，没有经历过的人或许体会不到这种折磨。不仅如此，费劲心血找的 <span class="keyword">jar </span>包里有的时候并没有你需要的那个类，又或者又同名的类没有你要的方法——以不规范的方式获取的 <span class="keyword">jar </span>包也往往是不规范的。 </span><br><span class="line">使用 Maven 我们可以享受到一个完全统一规范的 <span class="keyword">jar </span>包管理体系。你只需要在你的项目中以坐标的方式依赖一个 <span class="keyword">jar </span>包，Maven 就会自动从中央仓库进行下载，并同时下载这个 <span class="keyword">jar </span>包所依赖的其他 <span class="keyword">jar </span>包 ——规范、完整、准确！一次性解决所有问题！ </span><br><span class="line">Tips：在这里我们顺便说一下，统一的规范几乎可以说成是程序员的最高信仰。如果没有统一的规范，就意味着每个具体的技术都各自为政，需要以诸多不同的特殊的方式加入到项目中；好不容易加入进来还会和其他技术格格不入，最终受苦的是我们。而任何一个领域的统一规范都能够极大的降低程序员的工作难度，减少工作量。例如：USB 接口可以外接各种设备，如果每个设备都有自己独特的接口，那么不仅制造商需要维护各个接口的设计方案，使用者也需要详细了解每个设备对应的接口，无疑是非常繁琐的。</span><br></pre></td></tr></table></figure><ul><li><strong>④、将项目拆分成多个工程模块</strong> </li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">随着 <span class="keyword">JavaEE </span>项目的规模越来越庞大，开发团队的规模也与日俱增。一个项目上千人的团队持续开发很多年对于 <span class="keyword">JavaEE </span>项目来说再正常不过。那么我们想象一下：几百上千的人开发的项目是同一个 Web 工程。那么架构师、项目经理该如何划分项目的模块、如何分工呢？这么大的项目已经不可能通过 package 结构来划分模块，必须将项目拆分成多个工程协同开发。多个模块工程中有的是 <span class="keyword">Java </span>工程，有的是 Web 工程。 </span><br><span class="line">那么工程拆分后又如何进行互相调用和访问呢？这就需要用到 Maven 的依赖管理机制。大家请看我们的 Survey 调查项目拆分的情况： </span><br><span class="line"> 上层模块依赖下层，所以下层模块中定义的 API 都可以为上层所调用和访问。</span><br></pre></td></tr></table></figure><h5 id="二、什么是Maven-What"><a href="#二、什么是Maven-What" class="headerlink" title="二、什么是Maven (What)?"></a>二、什么是Maven (What)?</h5><h6 id="2-1、Maven-简介"><a href="#2-1、Maven-简介" class="headerlink" title="2.1、Maven 简介"></a>2.1、Maven 简介</h6><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Maven</span> 是 <span class="type">Apache</span> 软件基金会组织维护的一款自动化构建工具，专注服务于 <span class="type">Java</span> 平台的项目构建和依赖管理。<span class="type">Maven</span> 这个单词的本意是：专家，内行。读音是[<span class="symbol">'me</span>ɪv(ə)n]或[<span class="symbol">'mevn</span>]。</span><br></pre></td></tr></table></figure><h6 id="2-2、什么是构建"><a href="#2-2、什么是构建" class="headerlink" title="2.2、什么是构建"></a>2.2、什么是构建</h6><p>构建：构建并不是创建，创建一个工程并不等于构建一个项目。要了解构建的含义我们应该由浅入深的从以下三个层面来看： </p><ul><li><strong>①、纯 Java 代码</strong> </li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大家都知道，我们 Java 是一门编译型语言，<span class="selector-class">.java</span> 扩展名的源文件需要编译成<span class="selector-class">.class</span> 扩展名的字节码文件才能够执行。所以编写任何 Java 代码想要执行的话就必须经过编译得到对应的<span class="selector-class">.class</span> 文件。</span><br></pre></td></tr></table></figure><ul><li><strong>②、Web 工程</strong> </li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当我们需要通过浏览器访问 <span class="keyword">Java </span>程序时就必须将包含 <span class="keyword">Java </span>程序的 Web 工程编译的结果“拿”到服务器上的指定目录下，并启动服务器才行。这个“拿”的过程我们叫部署。 </span><br><span class="line">我们可以将未编译的 Web 工程比喻为一只生的鸡，编译好的 Web 工程是一只煮熟的鸡，编译部署的过程就是将鸡炖熟。</span><br></pre></td></tr></table></figure><p>Web 工程和其编译结果的目录结构对比见下图： </p><p><img src="https://i.loli.net/2019/05/16/5cdd0fa574c9841603.jpg" alt="编译目录与web目录对比"></p><ul><li><strong>③、实际项目</strong> </li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在实际项目中整合第三方框架，Web 工程中除了 <span class="keyword">Java </span>程序和 <span class="keyword">JSP </span>页面、图片等静态资源之外，还包括第三方框架的 <span class="keyword">jar </span>包以及各种各样的配置文件。所有这些资源都必须按照正确的目录结构部署到服务器上，项目才可以运行。 </span><br><span class="line">所以综上所述：构建就是以我们编写的 <span class="keyword">Java </span>代码、框架配置文件、国际化等其他资源文件、<span class="keyword">JSP </span>页面和图片等静态资源作为“原材料”，去“生产”出一个可以运行的项目的过程。 </span><br><span class="line">那么项目构建的全过程中都包含哪些环节呢？</span><br></pre></td></tr></table></figure><h6 id="2-3、-构建过程的几个主要环节"><a href="#2-3、-构建过程的几个主要环节" class="headerlink" title="2.3、 构建过程的几个主要环节"></a>2.3、 构建过程的几个主要环节</h6><ul><li>①、清理：删除以前的编译结果，为重新编译做好准备。 </li><li>②、编译：将 Java 源程序编译为字节码文件。 </li><li>③、测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。 </li><li>④、报告：在每一次测试后以标准的格式记录和展示测试结果。 </li><li>⑤、打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web 工程对应 war 包。 </li><li>⑥、安装：在 Maven 环境下特指将打包的结果——jar 包或 war 包安装到本地仓库中。 </li><li>⑦、部署：将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。 </li></ul><h6 id="2-4-、自动化构建"><a href="#2-4-、自动化构建" class="headerlink" title="2.4 、自动化构建"></a>2.4 、自动化构建</h6><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其实上述环节我们在 Eclipse 中都可以找到对应的操作，只是不太标准。那么既然 IDE 已经可以进行构建了我们为什么还要使用 Maven 这样的构建工具呢？我们来看一个小故事：这是阳光明媚的一天。托马斯向往常一样早早的来到了公司，冲好一杯咖啡，进入了自己的邮箱——很不幸，QA 小组发来了一封邮件，报告了他昨天提交的模块的测试结果——有 <span class="keyword">BUG。“好吧，反正也不是第一次”，托马斯摇摇头，进入 </span>IDE，运行自己的程序，编译、打包、部署到服务器上，然后按照邮件中的操作路径进行测试。“嗯，没错，这个地方确实有问题”，托马斯说道。于是托马斯开始尝试修复这个 <span class="keyword">BUG，当他差不多有眉目的时候已经到了午饭时间。 </span></span><br><span class="line">下午继续工作。<span class="keyword">BUG </span>很快被修正了，接着托马斯对模块重新进行了编译、打包、部署，测试之后确认没有问题了，回复了 QA 小组的邮件。 </span><br><span class="line">一天就这样过去了，明媚的阳光化作了美丽的晚霞，托马斯却觉得生活并不像晚霞那样美好啊。 </span><br><span class="line">让我们来梳理一下托马斯这一天中的工作内容</span><br></pre></td></tr></table></figure><p> <img src="https://i.loli.net/2019/05/16/5cdd0fe29a92645589.jpg" alt="托马斯1"><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从中我们发现，托马斯的很大一部分时间花在了“编译、打包、部署、测试”这些程式化的工作上面，而真正需要由“人”的智慧实现的分析问题和编码却只占了很少一部分。</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2019/05/16/5cdd1001629fa48188.jpg" alt="托马斯2"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">能否将这些程式化的工作交给机器自动完成呢？——当然可以！这就是自动化构建。</span><br></pre></td></tr></table></figure></p><p> <img src="https://i.loli.net/2019/05/16/5cdd10250fb8049283.jpg" alt="托马斯3"><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此时 Maven 的意义就体现出来了，它可以自动的从构建过程的起点一直执行到终点：</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2019/05/16/5cdd103ba7f7741267.jpg" alt="maven"></p><h6 id="2-5-Maven-核心概念"><a href="#2-5-Maven-核心概念" class="headerlink" title="2.5 Maven 核心概念"></a>2.5 Maven 核心概念</h6><p>Maven 能够实现自动化构建是和它的内部原理分不开的，这里我们从 Maven 的九个核心概念入手，看看 Maven 是如何实现自动化构建的 。</p><ul><li>①POM </li><li>②约定的目录结构 </li><li>③坐标 </li><li>④依赖管理 </li><li>⑤仓库管理 </li><li>⑥生命周期 </li><li>⑦插件和目标 </li><li>⑧继承 </li><li>⑨聚合 </li></ul><h5 id="三、How"><a href="#三、How" class="headerlink" title="三、How?"></a>三、How?</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Maven</span> 的核心程序中仅仅定义了抽象的生命周期，而具体的操作则是由 <span class="selector-tag">Maven</span> 的插件来完成的。可是<span class="selector-tag">Maven</span> 的插件并不包含在 <span class="selector-tag">Maven</span> 的核心程序中，在首次使用时需要联网下载。 </span><br><span class="line">下载得到的插件会被保存到本地仓库中。本地仓库默认的位置是：~\<span class="selector-class">.m2</span>\<span class="selector-tag">repository</span>。 </span><br><span class="line">如果不能联网可以使用我们提供的 <span class="selector-tag">RepMaven</span><span class="selector-class">.zip</span> 解压得到。</span><br></pre></td></tr></table></figure><h6 id="3-1、具体操作参见“Maven-操作指南-txt。”"><a href="#3-1、具体操作参见“Maven-操作指南-txt。”" class="headerlink" title="3.1、具体操作参见“Maven 操作指南.txt。”"></a>3.1、具体操作参见“Maven 操作指南.txt。”</h6><h6 id="3-2、约定的目录结构"><a href="#3-2、约定的目录结构" class="headerlink" title="3.2、约定的目录结构"></a>3.2、约定的目录结构</h6><p>约定的目录结构对于 Maven 实现自动化构建而言是必不可少的一环，就拿自动编译来说，Maven 必须能找到 Java 源文件，下一步才能编译，而编译之后也必须有一个准确的位置保持编译得到的字节码文件。<br>我们在开发中如果需要让第三方工具或框架知道我们自己创建的资源在哪，那么基本上就是两种方式： </p><ul><li>①通过配置的形式明确告诉它 。</li><li>②基于第三方工具或框架的约定<br>Maven 对工程目录结构的要求就属于后面的一种。<br><img src="https://i.loli.net/2019/05/16/5cdd105f1541493261.jpg" alt="Maven约定目录"></li></ul><p>现在 JavaEE 开发领域普遍认同一个观点：约定&gt;配置&gt;编码。意思就是能用配置解决的问题就不编码，能基于约定的就不进行配置。而 Maven 正是因为指定了特定文件保存的目录才能够对我们的 Java 工程进行自动化构建。 </p><hr><h5 id="四、POM"><a href="#四、POM" class="headerlink" title="四、POM"></a>四、POM</h5><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Project Object Model：项目对象模型。将 Java 工程的相关信息封装为对象作为便于操作和管理的模型。 Maven 工程的核心配置。可以说学习 Maven 就是学习 pom.<span class="keyword">xml</span> <span class="title">文件中的配置。</span></span><br></pre></td></tr></table></figure><h6 id="4-1、坐标"><a href="#4-1、坐标" class="headerlink" title="4-1、坐标"></a>4-1、坐标</h6><ul><li><p>几何中的坐标<br>[1]、在一个平面中使用 x、y 两个向量可以唯一的确定平面中的一个点。<br>[2]、在空间中使用 x、y、z 三个向量可以唯一的确定空间中的一个点。 </p></li><li><p>Maven 的坐标<br>使用如下三个向量在 Maven 的仓库中唯一的确定一个 Maven 工程。<br>[1]、groupid：公司或组织的域名倒序+当前项目名称<br>[2]、artifactId：当前项目的模块名称<br>[3]、version：当前模块的版本 </p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如何通过坐标到仓库中查找 jar 包？ <ul><li>[1]、将 gav 三个向量连起来<br>com.atguigu.maven+Hello+0.0.1-SNAPSHOT </li><li>[2]、以连起来的字符串作为目录结构到仓库中查找<br>com/atguigu/maven/Hello/0.0.1-SNAPSHOT/Hello-0.0.1-SNAPSHOT.jar<br><strong>※注意：我们自己的 Maven 工程必须执行安装操作才会进入仓库。安装的命令是：mvn install</strong> </li></ul></li></ul><hr><h5 id="五、依赖"><a href="#五、依赖" class="headerlink" title="五、依赖"></a>五、依赖</h5><p>Maven 中最关键的部分，我们使用 Maven 最主要的就是使用它的依赖管理功能。要理解和掌握 Maven 的依赖管理，我们只需要解决一下几个问题： </p><h6 id="①、依赖的目的是什么"><a href="#①、依赖的目的是什么" class="headerlink" title="①、依赖的目的是什么"></a>①、依赖的目的是什么</h6><p>当A jar包用到了B jar包中的某些类时，A就对B产生了依赖，这是概念上的描述。<br>那么如何在项目中以依赖的方式引入一个我们需要的jar包呢？答案非常简单，就是使用dependency标签指定被依赖jar包的坐标就可以了。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="②、依赖的范围"><a href="#②、依赖的范围" class="headerlink" title="②、依赖的范围"></a>②、依赖的范围</h6><p>大家注意到上面的依赖信息中除了目标jar包的坐标还有一个scope设置，这是依赖的范围。依赖的范围有几个可选值，我们用得到的是：compile、test、provided三个。 </p><ul><li>[1]、从项目结构角度理解 compile 和 test 的区别<br><img src="https://i.loli.net/2019/05/16/5cdd108b2f89492045.jpg" alt="依赖范围"><br>结合具体例子：对于HelloFriend来说，Hello就是服务于主程序的，junit是服务于测试程序的。<br>HelloFriend 主程序需要 Hello 是非常明显的，测试程序由于要调用主程序所以也需要 Hello，所以 compile范围依赖对主程序和测试程序都应该有效。<br>HelloFriend的测试程序部分需要junit也是非常明显的，而主程序是不需要的，所以test范围依赖仅仅对于主程序有效。 </li><li>[2]、从开发和运行这两个不同阶段理解 compile 和 provided 的区别<br><img src="https://i.loli.net/2019/05/16/5cdd10a7296e568065.jpg" alt="enter description here"></li><li>[3]、有效性总结 </li></ul><table><thead><tr><th></th><th>compile</th><th>test</th><th>provided</th></tr></thead><tbody><tr><td>主程序</td><td>√</td><td>×</td><td>√</td></tr><tr><td>测试程序</td><td>√</td><td>√</td><td>√</td></tr><tr><td>参与部署</td><td>√</td><td>×</td><td>×</td></tr></tbody></table><h6 id="③、依赖的传递性"><a href="#③、依赖的传递性" class="headerlink" title="③、依赖的传递性"></a>③、依赖的传递性</h6><p>A依赖B，B依赖C，A能否使用C呢？那要看B依赖C的范围是不是compile，如果是则可用，否则不可用。 </p><p><img src="https://i.loli.net/2019/05/14/5cda39cb852fe88049.jpg" alt="依赖的传递性"></p><h6 id="④、依赖的排除"><a href="#④、依赖的排除" class="headerlink" title="④、依赖的排除"></a>④、依赖的排除</h6><p>如果我们在当前工程中引入了一个依赖是A，而A又依赖了 B，那么 Maven 会自动将 A 依赖的 B 引入当前工程，但是个别情况下B有可能是一个不稳定版，或对当前工程有不良影响。这时我们可以在引入A的时候将B排除。<br>[1]、情景举例 </p><p> <img src="https://i.loli.net/2019/05/16/5cdd10dda179412292.jpg" alt="依赖的排除"><br>[2]、配置方式 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line"> &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; </span><br><span class="line"> &lt;artifactId&gt;HelloFriend&lt;/artifactId&gt; </span><br><span class="line"> &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; </span><br><span class="line"> &lt;type&gt;jar&lt;/type&gt; </span><br><span class="line"> &lt;scope&gt;compile&lt;/scope&gt; </span><br><span class="line"> &lt;exclusions&gt; </span><br><span class="line">  &lt;exclusion&gt; </span><br><span class="line">  &lt;groupId&gt;commons-logging&lt;/groupId&gt; </span><br><span class="line">  &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; </span><br><span class="line">  &lt;/exclusion&gt; </span><br><span class="line"> &lt;/exclusions&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>[3]、排除后的效果<br> <img src="https://i.loli.net/2019/05/16/5cdd10f117e8740700.jpg" alt="依赖排除效果"></p><h6 id="⑤、统一管理所依赖jar包的版本"><a href="#⑤、统一管理所依赖jar包的版本" class="headerlink" title="⑤、统一管理所依赖jar包的版本"></a>⑤、统一管理所依赖jar包的版本</h6><p>对同一个框架的一组jar包最好使用相同的版本。为了方便升级框架，可以将jar包的版本信息统一提取出来<br>[1]、统一声明版本号 </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt; </span><br><span class="line">     &lt;atguigu<span class="selector-class">.spring</span><span class="selector-class">.version</span>&gt;<span class="number">4.1</span>.<span class="number">1</span>.RELEASE&lt;/atguigu<span class="selector-class">.spring</span><span class="selector-class">.version</span>&gt; </span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><p>其中atguigu.spring.version部分是自定义标签。 </p><p>[2]、引用前面声明的版本号 </p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;atguigu.spring.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span></span><br><span class="line"><span class="xml">…… </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>[3]、其他用法 </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt; </span><br><span class="line">     &lt;project<span class="selector-class">.build</span><span class="selector-class">.sourceEncoding</span>&gt;UTF-<span class="number">8</span>&lt;/project<span class="selector-class">.build</span><span class="selector-class">.sourceEncoding</span>&gt; </span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><h6 id="⑥、依赖的原则：解决-jar-包冲突"><a href="#⑥、依赖的原则：解决-jar-包冲突" class="headerlink" title="⑥、依赖的原则：解决 jar 包冲突"></a>⑥、依赖的原则：解决 jar 包冲突</h6><p>[1]、路径最短者优先<br> <img src="https://i.loli.net/2019/05/16/5cdd11179914065450.jpg" alt="enter description here"><br>[2]、路径相同时先声明者优先<br><img src="https://i.loli.net/2019/05/16/5cdd1122da95d41741.jpg" alt="enter description here"><br>    这里“声明”的先后顺序指的是 dependency 标签配置的先后顺序。 </p><hr><h5 id="六、仓库"><a href="#六、仓库" class="headerlink" title="六、仓库"></a>六、仓库</h5><h6 id="6-1、分类"><a href="#6-1、分类" class="headerlink" title="6-1、分类"></a>6-1、分类</h6><p>[1]、本地仓库：为当前本机电脑上的所有 Maven 工程服务。<br>[2]、远程仓库 </p><ul><li>(1)、私服：架设在当前局域网环境下，为当前局域网范围内的所有 Maven 工程服务。<br><img src="https://i.loli.net/2019/05/16/5cdd1138bc48d56294.jpg" alt="私服"></li><li>(2)、中央仓库：架设在 Internet 上，为全世界所有 Maven 工程服务。 </li><li>(3)、中央仓库的镜像：架设在各个大洲，为中央仓库分担流量。减轻中央仓库的压力，同时更快的响应用户请求。 <h6 id="6-2、仓库中的文件"><a href="#6-2、仓库中的文件" class="headerlink" title="6-2、仓库中的文件"></a>6-2、仓库中的文件</h6></li><li>[1]、Maven 的插件 。</li><li>[2]、我们自己开发的项目的模块 。</li><li>[3]、第三方框架或工具的 jar 包 。</li></ul><p><strong>※不管是什么样的 jar 包，在仓库中都是按照坐标生成目录结构，所以可以通过统一的方式查询或依赖。</strong> </p><hr><h5 id="六、生命周期"><a href="#六、生命周期" class="headerlink" title="六、生命周期"></a>六、生命周期</h5><h6 id="6-1、什么是-Maven-的生命周期？"><a href="#6-1、什么是-Maven-的生命周期？" class="headerlink" title="6.1、什么是 Maven 的生命周期？"></a>6.1、什么是 Maven 的生命周期？</h6><p>Maven 生命周期定义了各个构建环节的执行顺序，有了这个清单，Maven 就可以自动化的执行构建命令了。 </p><p>Maven 有三套相互独立的生命周期，分别是：  </p><ul><li>①、Clean Lifecycle 在进行真正的构建之前进行一些清理工作。 </li><li>②、Default Lifecycle 构建的核心部分，编译，测试，打包，安装，部署等等。 </li><li>③、Site Lifecycle 生成项目报告，站点，发布站点。</li></ul><p>它们是相互独立的，你可以仅仅调用 clean 来清理工作目录，仅仅调用 site 来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。 </p><p>每套生命周期都由一组阶段 (Phase) 组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行 mvn clean，这个 clean 是 Clean 生命周期的一个阶段。有 Clean 生命周期，也有 clean 阶段。 </p><ul><li><p><strong>1、Clean 生命周期</strong><br>Clean 生命周期一共包含了三个阶段：<br>①pre-clean 执行一些需要在 clean 之前完成的工作<br>②clean 移除所有上一次构建生成的文件<br>③post-clean 执行一些需要在 clean 之后立刻完成的工作  </p></li><li><p><strong>2、Site 生命周期</strong><br>①pre-site 执行一些需要在生成站点文档之前完成的工作<br>②site 生成项目的站点文档<br>③post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备<br>④site-deploy 将生成的站点文档部署到特定的服务器上<br>这里经常用到的是 site 阶段和 site-deploy 阶段，用以生成和发布 Maven 站点，这可是 Maven 相当强大的功能，Manager 比较喜欢，文档及统计数据自动生成，很好看。 </p></li><li><p><strong>3、Default 生命周期</strong><br>Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段： validate generate-sources process-sources<br>generate-resources<br>process-resources 复制并处理资源文件，至目标目录，准备打包。<br>compile 编译项目的源代码。<br>process-classes generate-test-sources process-test-sources<br>generate-test-resources<br>process-test-resources 复制并处理资源文件，至目标测试目录。<br>test-compile 编译测试源代码。<br>process-test-classes<br>test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。<br>prepare-package<br>package 接受编译好的代码，打包成可发布的格式，如 JAR。<br>pre-integration-test integration-test post-integration-test verify<br>install 将包安装至本地仓库，以让其它项目依赖。<br>deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享或部署到服务器上运行。 </p></li></ul><h6 id="6-2、-生命周期与自动化构建"><a href="#6-2、-生命周期与自动化构建" class="headerlink" title="6.2、 生命周期与自动化构建"></a>6.2、 生命周期与自动化构建</h6><p>运行任何一个阶段的时候，它前面的所有阶段都会被运行，例如我们运行 mvn install 的时候，代码会被编译，测试，打包。这就是 Maven 为什么能够自动执行构建过程的各个环节的原因。此外，Maven 的插件机制是完全依赖 Maven 的生命周期的，因此理解生命周期至关重要。<br>插件和目标<br>●Maven 的核心仅仅定义了抽象的生命周期，具体的任务都是交由插件完成的。<br>●每个插件都能实现多个功能，每个功能就是一个插件目标。<br>●Maven 的生命周期与插件目标相互绑定，以完成某个具体的构建任务。<br>例如：compile 就是插件 maven-compiler-plugin 的一个目标；pre-clean 是插件 maven-clean-plugin 的一个目标。 </p><hr><h5 id="七、继承"><a href="#七、继承" class="headerlink" title="七、继承"></a>七、继承</h5><h6 id="7-1、为什么需要继承机制？"><a href="#7-1、为什么需要继承机制？" class="headerlink" title="7.1、为什么需要继承机制？"></a>7.1、为什么需要继承机制？</h6><p>由于非 compile 范围的依赖信息是不能在“依赖链”中传递的，所以有需要的工程只能单独配置。例如： 以下工程pom配置<br>Hello </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">HelloFriend </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">MakeFriend </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时如果项目需要将各个模块的 junit 版本统一为 4.9，那么到各个工程中手动修改无疑是非常不可取的。<br>使用继承机制就可以将这样的依赖信息统一提取到父工程模块中进行统一管理。 </p><p>创建父工程创建父工程和创建一般的 Java 工程操作一致，唯一需要注意的是：打包方式处要设置为 pom。 </p><p>在子工程中引用父工程 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span> </span><br><span class="line"> <span class="comment">&lt;!-- 父工程坐标 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>...<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>从当前目录到父项目的 pom.xml 文件的相对路径<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">  </span><br><span class="line"> <span class="comment">&lt;!-- 指定从当前子工程的pom.xml文件出发，查找父工程的pom.xml的路径 --&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../Parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span> </span><br><span class="line"> 此时如果子工程的 groupId 和 version 如果和父工程重复则可以删除。 </span><br><span class="line"> </span><br><span class="line">11.4 在父工程中管理依赖将 Parent 项目中的 dependencies 标签，用 dependencyManagement 标签括起来 </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span> </span><br><span class="line">在子项目中重新指定需要的依赖，删除范围和版本号 </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h5 id="八、聚合"><a href="#八、聚合" class="headerlink" title="八、聚合"></a>八、聚合</h5><h6 id="8-1、为什么要使用聚合？"><a href="#8-1、为什么要使用聚合？" class="headerlink" title="8.1、为什么要使用聚合？"></a>8.1、为什么要使用聚合？</h6><p>将多个工程拆分为模块后，需要手动逐个安装到仓库后依赖才能够生效。修改源码后也需要逐个手动进行 clean 操作。而使用了聚合之后就可以批量进行 Maven 工程的安装、清理工作。 </p><h6 id="8-2、如何配置聚合？"><a href="#8-2、如何配置聚合？" class="headerlink" title="8.2、如何配置聚合？"></a>8.2、如何配置聚合？</h6><p>在总的聚合工程中使用 modules/module 标签组合，指定模块工程的相对路径即可 </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt; </span><br><span class="line"> &lt;<span class="class"><span class="keyword">module</span>&gt;../<span class="title">Hello</span>&lt;/<span class="title">module</span>&gt; </span></span><br><span class="line"> &lt;<span class="class"><span class="keyword">module</span>&gt;../<span class="title">HelloFriend</span>&lt;/<span class="title">module</span>&gt;  &lt;module&gt;../<span class="title">MakeFriends</span>&lt;/<span class="title">module</span>&gt; </span></span><br><span class="line">&lt;<span class="regexp">/modules&gt;</span></span><br></pre></td></tr></table></figure><p>13 Maven 酷站我们可以到 <a href="http://mvnrepository.com/搜索需要的" target="_blank" rel="noopener">http://mvnrepository.com/搜索需要的</a> jar 包的依赖信息。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;br&gt;&lt;strong&gt;Maven&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;导言：生产环境下开发不再是一个项目一个工程，而是每一个模块创建一个工程，而多个模块整合在一起就需要使用到像 Maven 这样的构建工具。&lt;/strong&gt; &lt;/p&gt;
&lt;hr&gt;
&lt;
      
    
    </summary>
    
      <category term="开发工具相关" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Maven使用手册" scheme="http://yoursite.com/tags/Maven%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>一、MySQL 基础</title>
    <link href="http://yoursite.com/2019/04/28/MySQL%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/04/28/MySQL基础/</id>
    <published>2019-04-28T03:47:29.898Z</published>
    <updated>2019-04-28T03:47:29.899Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h5 id="一、为什么要学习数据库"><a href="#一、为什么要学习数据库" class="headerlink" title="一、为什么要学习数据库"></a>一、为什么要学习数据库</h5><ul><li>1、持久化数据到本地。</li><li>2、可以实现结构化查询，方便管理。</li></ul><hr><h5 id="二、数据库的相关概念"><a href="#二、数据库的相关概念" class="headerlink" title="二、数据库的相关概念"></a>二、数据库的相关概念</h5><p><strong>DBMS、DB、SQL</strong></p><ul><li>1、DB：数据库，保存一组有组织的数据的容器。</li><li>2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据。</li><li>3、SQL:结构化查询语言，用于和DBMS通信的语言。</li></ul><hr><h5 id="三、数据库存储数据的特点"><a href="#三、数据库存储数据的特点" class="headerlink" title="三、数据库存储数据的特点"></a>三、数据库存储数据的特点</h5><ul><li>1、数据存放到表中，然后表再放到库中。</li><li>2、一个库中可以有多张表，每张表具有唯一的表名用来标识自己。</li><li>3、表中有一个或多个列，列又称为“字段”，相当于java中“属性”。</li><li>4、表中的每一行数据，相当于java中“对象”。</li></ul><hr><h5 id="四、初始-MySQL"><a href="#四、初始-MySQL" class="headerlink" title="四、初始 MySQL"></a>四、初始 MySQL</h5><h6 id="4-2、MySQL-产品的介绍"><a href="#4-2、MySQL-产品的介绍" class="headerlink" title="4-2、MySQL 产品的介绍"></a>4-2、MySQL 产品的介绍</h6><ul><li>1、MySQL 的背景<ul><li>前身属于瑞典的一家公司，MySQL AB。</li><li>08 年被 sun 公司收购。</li><li>09 年 sun 被 oracle 收购。</li></ul></li><li>2、MySQL 的优点<ul><li>1、开源、免费、成本低。</li><li>2、性能高、移植性也好。</li><li>3、体积小，便于安装。</li></ul></li></ul><h6 id="4-3、MySQL-产品的安装-★"><a href="#4-3、MySQL-产品的安装-★" class="headerlink" title="4-3、MySQL 产品的安装          ★"></a>4-3、MySQL 产品的安装          ★</h6><ul><li>1、属于c/s架构的软件，一般来讲安装服务端。<ul><li>企业版。</li><li>社区版(5.5、5.6、5.7、8.0)。</li></ul></li></ul><h6 id="4-4、MySQL-服务的启动和停止-★"><a href="#4-4、MySQL-服务的启动和停止-★" class="headerlink" title="4-4、MySQL 服务的启动和停止     ★"></a>4-4、MySQL 服务的启动和停止     ★</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方式一：计算机——右击管理——服务</span><br><span class="line"></span><br><span class="line">方式二：通过管理员身份运行</span><br><span class="line">net start 服务名（启动服务）</span><br><span class="line">net stop 服务名（停止服务）</span><br></pre></td></tr></table></figure><h6 id="4-5、MySQL-服务的登录和退出-★"><a href="#4-5、MySQL-服务的登录和退出-★" class="headerlink" title="4-5、MySQL 服务的登录和退出     ★"></a>4-5、MySQL 服务的登录和退出     ★</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">方式一：通过mysql自带的客户端</span><br><span class="line">只限于root用户</span><br><span class="line"></span><br><span class="line">方式二：通过windows自带的客户端</span><br><span class="line">登录：</span><br><span class="line">mysql 【-h主机名 -P端口号 】-u用户名 -p密码</span><br><span class="line"></span><br><span class="line">退出：</span><br><span class="line">exit或ctrl+C</span><br></pre></td></tr></table></figure><h6 id="4-6、MySQL-的常见命令和语法规范"><a href="#4-6、MySQL-的常见命令和语法规范" class="headerlink" title="4-6、MySQL 的常见命令和语法规范"></a>4-6、MySQL 的常见命令和语法规范</h6><p><strong>常见命令</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.查看当前所有的数据库。</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.打开指定的库。</span></span><br><span class="line"><span class="keyword">use</span> 库名</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.查看当前库的所有表。</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4.查看其它库的所有表。</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">from</span> 库名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.创建表。</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line"></span><br><span class="line">列名 列类型,</span><br><span class="line">列名 列类型，</span><br><span class="line">。。。</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 6.查看表结构。</span></span><br><span class="line">desc 表名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7.查看服务器的版本。</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">version</span>();<span class="comment">-- 方式一：登录到mysql服务端。</span></span><br><span class="line">mysql <span class="comment">-- version;或 mysql --V;-- 方式二：没有登录到mysql服务端。</span></span><br></pre></td></tr></table></figure></p><p><strong>语法规范</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>不区分大小写,但建议关键字大写，表名、列名小写。</span><br><span class="line"><span class="number">2.</span>每条命令最好用分号结尾。</span><br><span class="line"><span class="number">3.</span>每条命令根据需要，可以进行缩进 或换行。</span><br><span class="line"><span class="number">4.</span>注释。</span><br><span class="line">单行注释：#注释文字</span><br><span class="line">单行注释：-- 注释文字</span><br><span class="line">多行注释：<span class="comment">/* 注释文字  */</span></span><br></pre></td></tr></table></figure></p><h6 id="4-7、SQL-的语言分类。"><a href="#4-7、SQL-的语言分类。" class="headerlink" title="4-7、SQL 的语言分类。"></a>4-7、SQL 的语言分类。</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DQL（Data Query Language）：数据查询语言</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">DML(<span class="keyword">Data</span> Manipulate <span class="keyword">Language</span>):数据操作语言</span><br><span class="line"><span class="keyword">insert</span> 、<span class="keyword">update</span>、<span class="keyword">delete</span></span><br><span class="line"><span class="keyword">DDL</span>（<span class="keyword">Data</span> <span class="keyword">Define</span> Languge）：数据定义语言</span><br><span class="line"><span class="keyword">create</span>、<span class="keyword">drop</span>、<span class="keyword">alter</span></span><br><span class="line">TCL（<span class="keyword">Transaction</span> Control <span class="keyword">Language</span>）：事务控制语言</span><br><span class="line"><span class="keyword">commit</span>、<span class="keyword">rollback</span></span><br></pre></td></tr></table></figure><hr><h5 id="五、DQL语言的学习-★"><a href="#五、DQL语言的学习-★" class="headerlink" title="五、DQL语言的学习   ★"></a>五、DQL语言的学习   ★</h5><h6 id="5-1、基础查询-★"><a href="#5-1、基础查询-★" class="headerlink" title="5-1、基础查询        ★"></a>5-1、基础查询        ★</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="keyword">SELECT</span> 要查询的东西</span><br><span class="line">【<span class="keyword">FROM</span> 表名】;</span><br><span class="line"></span><br><span class="line">类似于Java中 :System.out.println(要打印的东西);</span><br><span class="line">特点：</span><br><span class="line">①通过<span class="keyword">select</span>查询完的结果 ，是一个虚拟的表格，不是真实存在。</span><br><span class="line">②要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数  。</span><br></pre></td></tr></table></figure><h6 id="5-2、条件查询-★"><a href="#5-2、条件查询-★" class="headerlink" title="5-2、条件查询         ★"></a>5-2、条件查询         ★</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">条件查询：根据条件过滤原始表的数据，查询到想要的数据</span><br><span class="line">语法：</span><br><span class="line">select </span><br><span class="line">要查询的字段|表达式|常量值|函数</span><br><span class="line">from </span><br><span class="line">表</span><br><span class="line">where </span><br><span class="line">条件 ;</span><br><span class="line"></span><br><span class="line">分类：</span><br><span class="line">一、条件表达式</span><br><span class="line">示例：salary&gt;10000</span><br><span class="line">条件运算符：</span><br><span class="line">&gt; &lt; &gt;= &lt;= = != &lt;&gt;</span><br><span class="line"></span><br><span class="line">二、逻辑表达式</span><br><span class="line">示例：salary&gt;10000 &amp;&amp; salary&lt;20000</span><br><span class="line"></span><br><span class="line">逻辑运算符：</span><br><span class="line"></span><br><span class="line">and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false</span><br><span class="line">or(||)：两个条件只要有一个成立，结果为true，否则为false</span><br><span class="line">not(!)：如果条件成立，则not后为false，否则为true</span><br><span class="line"></span><br><span class="line">三、模糊查询</span><br><span class="line">示例：last_name like &apos;a%&apos;</span><br></pre></td></tr></table></figure><h6 id="5-3、排序查询-★"><a href="#5-3、排序查询-★" class="headerlink" title="5-3、排序查询         ★"></a>5-3、排序查询         ★</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">select</span><br><span class="line">要查询的东西</span><br><span class="line">from</span><br><span class="line">表</span><br><span class="line">where </span><br><span class="line">条件</span><br><span class="line"></span><br><span class="line">order by 排序的字段|表达式|函数|别名 【asc|desc】</span><br></pre></td></tr></table></figure><h6 id="5-4、常见函数-★"><a href="#5-4、常见函数-★" class="headerlink" title="5-4、常见函数        ★"></a>5-4、常见函数        ★</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">一、单行函数</span><br><span class="line">1、字符函数</span><br><span class="line">concat拼接</span><br><span class="line">substr截取子串</span><br><span class="line">upper转换成大写</span><br><span class="line">lower转换成小写</span><br><span class="line">trim去前后指定的空格和字符</span><br><span class="line">ltrim去左边空格</span><br><span class="line">rtrim去右边空格</span><br><span class="line">replace替换</span><br><span class="line">lpad左填充</span><br><span class="line">rpad右填充</span><br><span class="line">instr返回子串第一次出现的索引</span><br><span class="line">length 获取字节个数</span><br><span class="line"></span><br><span class="line">2、数学函数</span><br><span class="line">round 四舍五入</span><br><span class="line">rand 随机数</span><br><span class="line">floor向下取整</span><br><span class="line">ceil向上取整</span><br><span class="line">mod取余</span><br><span class="line">truncate截断</span><br><span class="line">3、日期函数</span><br><span class="line">now当前系统日期+时间</span><br><span class="line">curdate当前系统日期</span><br><span class="line">curtime当前系统时间</span><br><span class="line">str_to_date 将字符转换成日期</span><br><span class="line">date_format将日期转换成字符</span><br><span class="line">4、流程控制函数</span><br><span class="line">if 处理双分支</span><br><span class="line">case语句 处理多分支</span><br><span class="line">情况1：处理等值判断</span><br><span class="line">情况2：处理条件判断</span><br><span class="line"></span><br><span class="line">5、其他函数</span><br><span class="line">version版本</span><br><span class="line">database当前库</span><br><span class="line">user当前连接用户</span><br></pre></td></tr></table></figure><h6 id="5-5、分组函数-★"><a href="#5-5、分组函数-★" class="headerlink" title="5-5、分组函数        ★"></a>5-5、分组函数        ★</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sum 求和</span><br><span class="line">max 最大值</span><br><span class="line">min 最小值</span><br><span class="line">avg 平均值</span><br><span class="line">count 计数</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">1、以上五个分组函数都忽略null值，除了count(*)</span><br><span class="line">2、sum和avg一般用于处理数值型</span><br><span class="line">max、min、count可以处理任何数据类型</span><br><span class="line">3、都可以搭配distinct使用，用于统计去重后的结果</span><br><span class="line">4、count的参数可以支持：</span><br><span class="line">字段、*、常量值，一般放1</span><br><span class="line"></span><br><span class="line">   建议使用 count(*)</span><br></pre></td></tr></table></figure><h6 id="5-6、分组查询-★"><a href="#5-6、分组查询-★" class="headerlink" title="5-6、分组查询           ★"></a>5-6、分组查询           ★</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">select 查询的字段，分组函数</span><br><span class="line">from 表</span><br><span class="line">group by 分组的字段</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">1、可以按单个字段分组</span><br><span class="line">2、和分组函数一同查询的字段最好是分组后的字段</span><br><span class="line">3、分组筛选</span><br><span class="line">针对的表位置关键字</span><br><span class="line">分组前筛选：原始表group by的前面where</span><br><span class="line">分组后筛选：分组后的结果集group by的后面having</span><br><span class="line"></span><br><span class="line">4、可以按多个字段分组，字段之间用逗号隔开</span><br><span class="line">5、可以支持排序</span><br><span class="line">6、having后可以支持别名</span><br></pre></td></tr></table></figure><h6 id="5-7、连接查询-★"><a href="#5-7、连接查询-★" class="headerlink" title="5-7、连接查询         ★"></a>5-7、连接查询         ★</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">笛卡尔乘积：如果连接条件省略或无效则会出现</span><br><span class="line">解决办法：添加上连接条件。</span><br></pre></td></tr></table></figure><p><strong>一、传统模式下的连接 ：等值连接——非等值连接。</strong></p><ul><li>1.等值连接的结果 = 多个表的交集。</li><li>2.n表连接，至少需要n-1个连接条件。</li><li>3.多个表不分主次，没有顺序要求。</li><li>4.一般为表起别名，提高阅读性和性能。</li></ul><p><strong>二、sql99语法：通过join关键字实现连接。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">含义：1999年推出的sql语法</span><br><span class="line">支持：</span><br><span class="line">等值连接、非等值连接 （内连接）</span><br><span class="line">外连接</span><br><span class="line">交叉连接</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line">select 字段，...</span><br><span class="line">from 表1</span><br><span class="line">【inner|left outer|right outer|cross】join 表2 on  连接条件</span><br><span class="line">【inner|left outer|right outer|cross】join 表3 on  连接条件</span><br><span class="line">【where 筛选条件】</span><br><span class="line">【group by 分组字段】</span><br><span class="line">【having 分组后的筛选条件】</span><br><span class="line">【order by 排序的字段或表达式】</span><br><span class="line"></span><br><span class="line">好处：语句上，连接条件和筛选条件实现了分离，简洁明了！</span><br></pre></td></tr></table></figure><p><strong>三、自连接</strong><br>案例：查询员工名和直接上级的名称</p><p>sql99</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN employees m ON e.`manager_id`=m.`employee_id`;</span><br></pre></td></tr></table></figure><p>sql92</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e,employees m </span><br><span class="line">WHERE e.`manager_id`=m.`employee_id`;</span><br></pre></td></tr></table></figure><h6 id="5-8、子查询-√"><a href="#5-8、子查询-√" class="headerlink" title="5-8、子查询       √"></a>5-8、子查询       √</h6><p><strong>含义：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询。</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1、子查询都放在小括号内</span><br><span class="line">2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧</span><br><span class="line">3、子查询优先于主查询执行，主查询使用了子查询的执行结果</span><br><span class="line">4、子查询根据查询结果的行数不同分为以下两类：</span><br><span class="line">① 单行子查询</span><br><span class="line">结果集只有一行</span><br><span class="line">一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= </span><br><span class="line">非法使用子查询的情况：</span><br><span class="line">a、子查询的结果为一组值</span><br><span class="line">b、子查询的结果为空</span><br><span class="line"></span><br><span class="line">② 多行子查询</span><br><span class="line">结果集有多行</span><br><span class="line">一般搭配多行操作符使用：any、all、in、not in</span><br><span class="line">in： 属于子查询结果中的任意一个就行</span><br><span class="line">any和all往往可以用其他查询代替</span><br></pre></td></tr></table></figure><h6 id="5-9、分页查询-★"><a href="#5-9、分页查询-★" class="headerlink" title="5-9、分页查询       ★"></a>5-9、分页查询       ★</h6><p><strong>应用场景：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句。</span><br></pre></td></tr></table></figure><p><strong>语法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select 字段|表达式,...</span><br><span class="line"><span class="keyword">from</span> 表</span><br><span class="line">【where 条件】</span><br><span class="line">【group by 分组字段】</span><br><span class="line">【having 条件】</span><br><span class="line">【order by 排序的字段】</span><br><span class="line">limit 【起始的条目索引，】条目数;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>起始条目索引从<span class="number">0</span>开始</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>limit子句放在查询语句的最后</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>公式：select * <span class="keyword">from</span>  表 limit （page<span class="number">-1</span>）*sizePerPage,sizePerPage</span><br><span class="line">假如:</span><br><span class="line">每页显示条目数sizePerPage</span><br><span class="line">要显示的页数 page</span><br></pre></td></tr></table></figure><h6 id="5-10、union联合查询-√"><a href="#5-10、union联合查询-√" class="headerlink" title="5-10、union联合查询    √"></a>5-10、union联合查询    √</h6><p><strong>引入：</strong><br>    union 联合、合并</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】</span><br><span class="line">.....</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、多条查询语句的查询的列数必须是一致的</span><br><span class="line">2、多条查询语句的查询的列的类型几乎相同</span><br><span class="line">3、union代表去重，union all代表不去重</span><br></pre></td></tr></table></figure><hr><h5 id="六、DML语言的学习-★"><a href="#六、DML语言的学习-★" class="headerlink" title="六、DML语言的学习    ★"></a>六、DML语言的学习    ★</h5><h6 id="6-2、插入语句"><a href="#6-2、插入语句" class="headerlink" title="6-2、插入语句"></a>6-2、插入语句</h6><p><strong>语法：</strong><br>    insert into 表名(字段名，…)<br>    values(值1，…);</p><p><strong>特点：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、字段类型和值类型一致或兼容，而且一一对应。</span><br><span class="line">2、可以为空的字段，可以不用插入值，或用null填充。</span><br><span class="line">3、不可以为空的字段，必须插入值。</span><br><span class="line">4、字段个数和值的个数必须一致。</span><br><span class="line">5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致。</span><br></pre></td></tr></table></figure><h6 id="6-3、修改语句"><a href="#6-3、修改语句" class="headerlink" title="6-3、修改语句"></a>6-3、修改语句</h6><p><strong>修改单表语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段=新值,字段=新值</span><br><span class="line">【<span class="keyword">where</span> 条件】</span><br></pre></td></tr></table></figure><p><strong>修改多表语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表<span class="number">1</span> 别名<span class="number">1</span>,表<span class="number">2</span> 别名<span class="number">2</span></span><br><span class="line"><span class="keyword">set</span> 字段=新值，字段=新值</span><br><span class="line"><span class="keyword">where</span> 连接条件</span><br><span class="line"><span class="keyword">and</span> 筛选条件</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 1、如何对一张表的数据进行批量更新？</li></ul><h6 id="6-4、删除语句"><a href="#6-4、删除语句" class="headerlink" title="6-4、删除语句"></a>6-4、删除语句</h6><p><strong>方式1：delete语句</strong> </p><p><strong>1、单表的删除： ★</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 【<span class="keyword">where</span> 筛选条件】</span><br></pre></td></tr></table></figure><p><strong>2、多表的删除：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> 别名<span class="number">1</span>，别名<span class="number">2</span></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> 别名<span class="number">1</span>，表<span class="number">2</span> 别名<span class="number">2</span></span><br><span class="line"><span class="keyword">where</span> 连接条件</span><br><span class="line"><span class="keyword">and</span> 筛选条件;</span><br></pre></td></tr></table></figure><p><strong>方式2：truncate语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名</span><br></pre></td></tr></table></figure><p><strong>两种方式的区别【面试题】</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>1.truncate不能加where条件，而delete可以加where条件。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>2.truncate的效率高一丢丢。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始。</span><br><span class="line"><span class="meta">#</span>delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>4.truncate删除不能回滚，delete删除可以回滚。</span><br></pre></td></tr></table></figure><hr><h5 id="七、DDL语言的学习"><a href="#七、DDL语言的学习" class="headerlink" title="七、DDL语言的学习"></a>七、DDL语言的学习</h5><h6 id="7-1、库和表的管理-√"><a href="#7-1、库和表的管理-√" class="headerlink" title="7-1、库和表的管理     √"></a>7-1、库和表的管理     √</h6><p><strong>库的管理：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一、创建库</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 库名</span><br><span class="line">二、删除库</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 库名</span><br></pre></td></tr></table></figure><p><strong>表的管理：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#1.创建表</span><br><span class="line">CREATE TABLE IF NOT EXISTS stuinfo(</span><br><span class="line">stuId INT,</span><br><span class="line">stuName VARCHAR(20),</span><br><span class="line">gender CHAR,</span><br><span class="line">bornDate DATETIME</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DESC studentinfo;</span><br><span class="line"></span><br><span class="line">#2.修改表 alter</span><br><span class="line">语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;</span><br><span class="line"></span><br><span class="line">#①修改字段名</span><br><span class="line">ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;</span><br><span class="line"></span><br><span class="line">#②修改表名</span><br><span class="line">ALTER TABLE stuinfo RENAME [TO]  studentinfo;</span><br><span class="line">#③修改字段类型和列级约束</span><br><span class="line">ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;</span><br><span class="line"></span><br><span class="line">#④添加字段</span><br><span class="line"></span><br><span class="line">ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;</span><br><span class="line">#⑤删除字段</span><br><span class="line">ALTER TABLE studentinfo DROP COLUMN email;</span><br><span class="line"></span><br><span class="line">#3.删除表</span><br><span class="line"></span><br><span class="line">DROP TABLE [IF EXISTS] studentinfo;</span><br></pre></td></tr></table></figure><h6 id="7-2、常见数据类型介绍-√"><a href="#7-2、常见数据类型介绍-√" class="headerlink" title="7-2、常见数据类型介绍  √"></a>7-2、常见数据类型介绍  √</h6><ul><li>整型：</li><li>小数：<ul><li>浮点型</li><li>定点型</li></ul></li><li>字符型：</li><li>日期型：</li><li>Blob类型：</li></ul><h6 id="7-3、常见约束-√"><a href="#7-3、常见约束-√" class="headerlink" title="7-3、常见约束        √"></a>7-3、常见约束        √</h6><ul><li>NOT NULL</li><li>DEFAULT</li><li>UNIQUE</li><li>CHECK</li><li>PRIMARY KEY</li><li>FOREIGN KEY</li></ul><hr><h5 id="八、TCL语言的学习"><a href="#八、TCL语言的学习" class="headerlink" title="八、TCL语言的学习"></a>八、TCL语言的学习</h5><p>事务和事务处理<br><strong>含义：</strong><br>通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态<br><strong>特点：</strong><br>（ACID）</p><ul><li>原子性：要么都执行，要么都回滚。</li><li>一致性：保证数据的状态操作前和操作后保持一致。（比如：钱的总额一定，分布式数据库中数据存储保持一致性。）</li><li>隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰。</li><li>持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改。<h6 id="8-1、事务的分类"><a href="#8-1、事务的分类" class="headerlink" title="8-1、事务的分类"></a>8-1、事务的分类</h6></li><li>隐式事务，没有明显的开启和结束事务的标志。</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比如</span><br><span class="line"><span class="keyword">insert</span>、<span class="keyword">update</span>、<span class="keyword">delete</span>语句本身就是一个事务。</span><br><span class="line">- 显式事务，具有明显的开启和结束事务的标志。</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、开启事务</span><br><span class="line">取消自动提交事务的功能</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、编写事务的一组逻辑操作单元（多条sql语句）</span><br><span class="line"><span class="keyword">insert</span></span><br><span class="line"><span class="keyword">update</span></span><br><span class="line"><span class="keyword">delete</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、提交事务或回滚事务</span><br></pre></td></tr></table></figure><h6 id="8-2、使用到的关键字"><a href="#8-2、使用到的关键字" class="headerlink" title="8-2、使用到的关键字"></a>8-2、使用到的关键字</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">savepoint</span>  断点</span><br><span class="line"><span class="keyword">commit</span> <span class="keyword">to</span> 断点</span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> 断点</span><br></pre></td></tr></table></figure><h6 id="8-3、事务的隔离级别"><a href="#8-3、事务的隔离级别" class="headerlink" title="8-3、事务的隔离级别"></a>8-3、事务的隔离级别</h6><ul><li>1、事务并发问题如何发生？<br>当多个事务同时操作同一个数据库的相同数据时。</li><li>2、事务的并发问题有哪些？<ul><li>脏读：一个事务读取到了另外一个事务未提交的数据。</li><li>不可重复读：同一个事务中，多次读取到的数据不一致。</li><li>幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据。</li></ul></li><li>3、如何避免事务的并发问题？</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通过设置事务的隔离级别</span><br><span class="line"><span class="number">1</span>、READ UNCOMMITTED。</span><br><span class="line"><span class="number">2</span>、READ COMMITTED 可以避免脏读。</span><br><span class="line"><span class="number">3</span>、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读。</span><br><span class="line"><span class="number">4</span>、SERIALIZABLE可以避免脏读、不可重复读和幻读。</span><br></pre></td></tr></table></figure><ul><li>4、设置隔离级别：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span>|<span class="keyword">global</span>  <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> 隔离级别名;</span><br></pre></td></tr></table></figure><ul><li>5、查看隔离级别：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@tx_isolation;</span><br></pre></td></tr></table></figure><hr><h5 id="九、视图的讲解-√"><a href="#九、视图的讲解-√" class="headerlink" title="九、视图的讲解           √"></a>九、视图的讲解           √</h5><ul><li><strong>含义</strong>：理解成一张虚拟的表。</li><li><strong>视图和表的区别</strong>：</li></ul><table><thead><tr><th></th><th>使用方式</th><th>占用物理空间</th></tr></thead><tbody><tr><td>视图</td><td>完全相同</td><td>不占用，仅仅保存的是sql逻辑</td></tr><tr><td>表</td><td>完全相同</td><td>占用</td></tr></tbody></table><ul><li><strong>视图的好处</strong>：<ul><li>1、sql语句提高重用性，效率高。</li><li>2、和表实现了分离，提高了安全性。<h6 id="9-1、视图的创建"><a href="#9-1、视图的创建" class="headerlink" title="9-1、视图的创建"></a>9-1、视图的创建</h6></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">CREATE VIEW  视图名</span><br><span class="line">AS</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure><h6 id="9-2、视图的增删改查"><a href="#9-2、视图的增删改查" class="headerlink" title="9-2、视图的增删改查"></a>9-2、视图的增删改查</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、查看视图的数据 ★</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_v4;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_v1 <span class="keyword">WHERE</span> last_name=<span class="string">'Partners'</span>;</span><br><span class="line"></span><br><span class="line">2、插入视图的数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_v4(last_name,department_id) <span class="keyword">VALUES</span>(<span class="string">'虚竹'</span>,<span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">3、修改视图的数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> my_v4 <span class="keyword">SET</span> last_name =<span class="string">'梦姑'</span> <span class="keyword">WHERE</span> last_name=<span class="string">'虚竹'</span>;</span><br><span class="line"></span><br><span class="line">4、删除视图的数据</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> my_v4;</span><br></pre></td></tr></table></figure><h6 id="9-3、某些视图不能更新"><a href="#9-3、某些视图不能更新" class="headerlink" title="9-3、某些视图不能更新"></a>9-3、某些视图不能更新</h6><p>包含以下关键字的sql语句：</p><ul><li>分组函数、distinct、group  by、having、union或者union all。</li><li>常量视图。</li><li>Select中包含子查询。</li><li>join</li><li>from一个不能更新的视图。</li><li>where子句的子查询引用了from子句中的表。<h6 id="9-4、视图逻辑的更新"><a href="#9-4、视图逻辑的更新" class="headerlink" title="9-4、视图逻辑的更新"></a>9-4、视图逻辑的更新</h6></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#方式一：重新创建</span><br><span class="line">CREATE OR REPLACE VIEW test_v7</span><br><span class="line">AS</span><br><span class="line">SELECT last_name FROM employees</span><br><span class="line">WHERE employee_id&gt;100;</span><br><span class="line"></span><br><span class="line">#方式二: 修改更新视图逻辑</span><br><span class="line">ALTER VIEW test_v7</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT * FROM test_v7;</span><br></pre></td></tr></table></figure><h6 id="9-5、视图的删除"><a href="#9-5、视图的删除" class="headerlink" title="9-5、视图的删除"></a>9-5、视图的删除</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW test_v1,test_v2,test_v3;</span><br></pre></td></tr></table></figure><h6 id="9-6、视图结构的查看"><a href="#9-6、视图结构的查看" class="headerlink" title="9-6、视图结构的查看"></a>9-6、视图结构的查看</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DESC test_v7;</span><br><span class="line">SHOW CREATE VIEW test_v7;</span><br></pre></td></tr></table></figure><h5 id="十、变量"><a href="#十、变量" class="headerlink" title="十、变量"></a>十、变量</h5><h6 id="10-1、系统变量"><a href="#10-1、系统变量" class="headerlink" title="10-1、系统变量"></a>10-1、系统变量</h6><ul><li>1、全局变量(作用域：针对于所有会话（连接）有效，但不能跨重启)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES;</span><br><span class="line"></span><br><span class="line">查看满足条件的部分系统变量</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &apos;%char%&apos;;</span><br><span class="line"></span><br><span class="line">查看指定的系统变量的值</span><br><span class="line">SELECT @@global.autocommit;</span><br><span class="line"></span><br><span class="line">为某个系统变量赋值</span><br><span class="line">SET @@global.autocommit=0;</span><br><span class="line">SET GLOBAL autocommit=0;</span><br></pre></td></tr></table></figure><ul><li>2、会话变量(作用域：针对于当前会话（连接）有效)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES;</span><br><span class="line"></span><br><span class="line">查看满足条件的部分会话变量</span><br><span class="line">SHOW SESSION VARIABLES LIKE &apos;%char%&apos;;</span><br><span class="line"></span><br><span class="line">查看指定的会话变量的值</span><br><span class="line">SELECT @@autocommit;</span><br><span class="line">SELECT @@session.tx_isolation;</span><br><span class="line"></span><br><span class="line">为某个会话变量赋值</span><br><span class="line">SET @@session.tx_isolation=&apos;read-uncommitted&apos;;</span><br><span class="line">SET SESSION tx_isolation=&apos;read-committed&apos;;</span><br></pre></td></tr></table></figure><h6 id="10-2、自定义变量"><a href="#10-2、自定义变量" class="headerlink" title="10-2、自定义变量"></a>10-2、自定义变量</h6><ul><li><p>1、用户变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 声明并初始化</span><br><span class="line">SET @变量名=值;</span><br><span class="line">SET @变量名:=值;</span><br><span class="line">SELECT @变量名:=值;</span><br><span class="line"></span><br><span class="line">- 赋值</span><br><span class="line"></span><br><span class="line">方式一：一般用于赋简单的值</span><br><span class="line">SET 变量名=值;</span><br><span class="line">SET 变量名:=值;</span><br><span class="line">SELECT 变量名:=值;</span><br><span class="line"></span><br><span class="line">方式二：一般用于赋表 中的字段值</span><br><span class="line">SELECT 字段名或表达式 INTO 变量</span><br><span class="line">FROM 表;</span><br><span class="line"></span><br><span class="line">- 使用</span><br><span class="line">select @变量名;</span><br></pre></td></tr></table></figure></li><li><p>2、局部变量</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">声明：</span><br><span class="line">declare 变量名 类型 【default 值】;</span><br><span class="line"></span><br><span class="line">赋值：</span><br><span class="line">方式一：一般用于赋简单的值</span><br><span class="line">SET 变量名=值;</span><br><span class="line">SET 变量名:=值;</span><br><span class="line">SELECT 变量名:=值;</span><br><span class="line"></span><br><span class="line">方式二：一般用于赋表 中的字段值</span><br><span class="line">SELECT 字段名或表达式 INTO 变量</span><br><span class="line">FROM 表;</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">select 变量名</span><br></pre></td></tr></table></figure><h6 id="10-3、系统变量和自定义变量区别"><a href="#10-3、系统变量和自定义变量区别" class="headerlink" title="10-3、系统变量和自定义变量区别"></a>10-3、系统变量和自定义变量区别</h6><table><thead><tr><th></th><th>作用域</th><th>定义位置</th><th>语法</th></tr></thead><tbody><tr><td>用户变量</td><td>当前会话</td><td>会话的任何地方</td><td>加@符号，不用指定类型</td></tr><tr><td>局部变量</td><td>定义它的BEGIN END中</td><td>BEGIN END的第一句话</td><td>一般不用加@,需要指定类型</td></tr></tbody></table><h5 id="十一、存储过程和函数"><a href="#十一、存储过程和函数" class="headerlink" title="十一、存储过程和函数"></a>十一、存储过程和函数</h5><ul><li><strong>含义</strong>：一组经过预先编译的sql语句的集合。</li><li><strong>好处</strong>：<ul><li>1、提高了sql语句的重用性，减少了开发程序员的压力。</li><li>2、提高了效率。</li><li>3、减少了传输次数。</li></ul></li><li><strong>分类</strong>：<ul><li>1、无返回无参。</li><li>2、仅仅带in类型，无返回有参。</li><li>3、仅仅带out类型，有返回无参。</li><li>4、既带in又带out，有返回有参。</li><li>5、带inout，有返回有参。<h6 id="11-1、创建存储过程"><a href="#11-1、创建存储过程" class="headerlink" title="11-1、创建存储过程"></a>11-1、创建存储过程</h6></li></ul></li><li>1、DELIMITER 关键字及语法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql 默认以分号为语句的结束，但是在创建存储过程时 sql 语句中一般会出现多个分号。为了不让语句过早遇见分号;执行。在创建语句首行使用该关键字+特殊符号来指定其他字符为语句的结束。最后再指定 delimiter ; 恢复分号为语句结束标志。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">DELIMITER $$ </span><br><span class="line">DROP TRIGGER IF EXISTS `updateegopriceondelete`$$ </span><br><span class="line">CREATE </span><br><span class="line">    TRIGGER `updateegopriceondelete` AFTER  DELETE ON  `customerinfo` </span><br><span class="line">    FOR EACH ROW BEGIN </span><br><span class="line">DELETE FROM egoprice  WHERE customerId=OLD.customerId; </span><br><span class="line">    END$$ </span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><ul><li>2 、语法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#1、语法</span><br><span class="line">create procedure 存储过程名(in|out|inout 参数名  参数类型,...)</span><br><span class="line">begin</span><br><span class="line">存储过程体</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">#2、类似于方法</span><br><span class="line">修饰符 返回类型 方法名(参数类型 参数名,...)&#123;</span><br><span class="line"></span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#3、注意</span><br><span class="line">1、需要设置新的结束标记</span><br><span class="line">delimiter 新的结束标记</span><br><span class="line">示例：</span><br><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)</span><br><span class="line">BEGIN</span><br><span class="line">sql语句1;</span><br><span class="line">sql语句2;</span><br><span class="line"></span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end</span><br><span class="line"></span><br><span class="line">3、参数前面的符号的意思</span><br><span class="line">in:该参数只能作为输入 （该参数不能做返回值）</span><br><span class="line">out：该参数只能作为输出（该参数只能做返回值）</span><br><span class="line">inout：既能做输入又能做输出</span><br></pre></td></tr></table></figure><h6 id="11-2、调用存储过程"><a href="#11-2、调用存储过程" class="headerlink" title="11-2、调用存储过程"></a>11-2、调用存储过程</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 存储过程名(实参列表)</span><br></pre></td></tr></table></figure><h6 id="11-3、创建函数"><a href="#11-3、创建函数" class="headerlink" title="11-3、创建函数"></a>11-3、创建函数</h6><ul><li>学过的函数：LENGTH、SUBSTR、CONCAT 等。</li><li>语法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型</span><br><span class="line">BEGIN</span><br><span class="line">函数体</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure><h6 id="11-4、调用函数"><a href="#11-4、调用函数" class="headerlink" title="11-4、调用函数"></a>11-4、调用函数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 函数名（实参列表）</span><br></pre></td></tr></table></figure><h6 id="11-5、函数和存储过程的区别"><a href="#11-5、函数和存储过程的区别" class="headerlink" title="11-5、函数和存储过程的区别"></a>11-5、函数和存储过程的区别</h6><table><thead><tr><th></th><th>关键字</th><th>调用语法</th><th>返回值</th><th>应用场景</th></tr></thead><tbody><tr><td>函数</td><td>FUNCTION</td><td>SELECT 函数()</td><td>只能是一个</td><td>一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个</td></tr><tr><td>存储过程</td><td>PROCEDURE</td><td>CALL 存储过程()</td><td>可以有0个或多个</td><td>一般用于更新</td></tr></tbody></table><h5 id="十二、流程控制结构"><a href="#十二、流程控制结构" class="headerlink" title="十二、流程控制结构"></a>十二、流程控制结构</h5><h6 id="12-1、分支"><a href="#12-1、分支" class="headerlink" title="12-1、分支"></a>12-1、分支</h6><p><strong>一、if函数</strong><br>    语法：if(条件，值1，值2)<br>    特点：可以用在任何位置</p><p><strong>二、case语句</strong></p><p>语法：</p><pre><code>情况一：类似于switchcase 表达式when 值1 then 结果1或语句1(如果是语句，需要加分号) when 值2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）情况二：类似于多重ifcase when 条件1 then 结果1或语句1(如果是语句，需要加分号) when 条件2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）</code></pre><p>特点：<br>    可以用在任何位置</p><p><strong>三、if elseif语句</strong></p><p>语法：</p><pre><code>if 情况1 then 语句1;elseif 情况2 then 语句2;...else 语句n;end if;</code></pre><p>特点：<br>    只能用在begin end中！！！！！！！！！！！！！！！</p><p>三者比较：<br>            应用场合<br>    if函数        简单双分支<br>    case结构    等值判断 的多分支<br>    if结构        区间判断 的多分支</p><h6 id="12-2、循环"><a href="#12-2、循环" class="headerlink" title="12-2、循环"></a>12-2、循环</h6><p><strong>语法：</strong></p><pre><code>【标签：】WHILE 循环条件  DO    循环体END WHILE 【标签】;</code></pre><p><strong>特点：</strong></p><pre><code>只能放在BEGIN END里面如果要搭配leave跳转语句，需要使用标签，否则可以不用标签leave类似于java中的break语句，跳出所在循环！！！</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h5 id=&quot;一、为什么要学习数据库&quot;&gt;&lt;a href=&quot;#一、为什么要学习数据库&quot; class=&quot;headerlink&quot; title=&quot;一、为什么要学习数据库&quot;&gt;&lt;/a&gt;一、为什么要学习数据库&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;1、持久化数据到本地。&lt;/li
      
    
    </summary>
    
      <category term="MySQL基础" scheme="http://yoursite.com/categories/MySQL%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="MySQL基础" scheme="http://yoursite.com/tags/MySQL%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>一、SQL 转换：Oracle 转 MySQL</title>
    <link href="http://yoursite.com/2019/04/25/MySQL%E6%9B%BF%E4%BB%A3Oracle%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2019/04/25/MySQL替代Oracle序列/</id>
    <published>2019-04-25T03:05:07.000Z</published>
    <updated>2019-04-25T06:09:07.321Z</updated>
    
    <content type="html"><![CDATA[<p><strong>什么是自增长？</strong></p><ul><li>自增长只能用于表中的其中一个字段。</li><li>自增长只能被分配给固定表的固定的某一字段，不能被多个表共用。</li><li>自增长会把一个未指定或NULL值的字段自动填上。</li></ul><h5 id="一、在-Oracle-中如何实现-MySQL-的自增长？"><a href="#一、在-Oracle-中如何实现-MySQL-的自增长？" class="headerlink" title="一、在 Oracle 中如何实现 MySQL 的自增长？"></a>一、在 Oracle 中如何实现 MySQL 的自增长？</h5><p>请看下面的实例：</p><ul><li><p>1-1、在 MYSQL 里有这样一张表:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Movie(  </span><br><span class="line">  <span class="keyword">id</span>           <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,  </span><br><span class="line">  <span class="keyword">name</span>     <span class="built_in">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">  released <span class="keyword">YEAR</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)  </span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Movie (<span class="keyword">name</span>,released) <span class="keyword">VALUES</span> (<span class="string">'Gladiator'</span>,<span class="number">2000</span>);  </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Movie (<span class="keyword">id</span>,<span class="keyword">name</span>,released) <span class="keyword">VALUES</span> (<span class="literal">NULL</span>,<span class="string">'The Bourne Identity'</span>,<span class="number">1998</span>);</span><br></pre></td></tr></table></figure></li><li><p>1-2、在 ORACLE 是这样的使用序列对象+触发器来完成 MySQL 的自增长功能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Movie(  </span><br><span class="line"> <span class="keyword">id</span>          <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line"> <span class="keyword">name</span>     VARCHAR2(<span class="number">60</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line"> released <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)  </span><br><span class="line">);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SEQUENCE</span> MovieSeq;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Movie (<span class="keyword">id</span>,<span class="keyword">name</span>,released) <span class="keyword">VALUES</span> (MovieSeq.NEXTVAL,<span class="string">'Gladiator'</span>,<span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>在 Oracle 下为表添加一个触发器，就可以实现 MySQL 自增长功能:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.  <span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">TRIGGER</span> BRI_MOVIE_TRG  </span><br><span class="line"><span class="number">2.</span>  <span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> Movie  </span><br><span class="line"><span class="number">3.</span>  <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span>  </span><br><span class="line"><span class="number">4.</span>  <span class="keyword">BEGIN</span>  </span><br><span class="line"><span class="number">5.</span>  <span class="keyword">SELECT</span> MovieSeq.NEXTVAL <span class="keyword">INTO</span> :new.id <span class="keyword">FROM</span> DUAL;  </span><br><span class="line">6.  <span class="keyword">END</span> BRI_MOVIE_TRG;  </span><br><span class="line">7.  .  </span><br><span class="line">8.  RUN;</span><br></pre></td></tr></table></figure></p><p>这样，插入记录就可以成为 MYSQL 风格：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Movie (<span class="keyword">name</span>,released) <span class="keyword">VALUES</span> (<span class="string">'The Lion King'</span>,<span class="number">1994</span>);</span><br></pre></td></tr></table></figure><p>下面我们来看看如何在 mysql 数据里使用 Oracle 序列语法 .NEXTVAL 和  .CURVAL。</p><h5 id="二、MySQL-如何实现-Oracle-序列？"><a href="#二、MySQL-如何实现-Oracle-序列？" class="headerlink" title="二、MySQL 如何实现 Oracle 序列？"></a>二、MySQL 如何实现 Oracle 序列？</h5><p><strong>一般使用序列 (Sequence) 来处理主键字段，在 MySQL中 是没有序列的，但是 MySQL有提供了自增长 (increment) 来实现类似的目的，但也只是自增，而不能设置步长、开始索引、是否循环等，最重要的是一张表只能由一个字段使用自增，但有的时候我们需要两个或两个以上的字段实现自增（单表多字段自增），MySQL本身是实现不了的，但我们可以用创建一个序列表，使用函数来获取序列的值。</strong></p><p>我们假设在 MySQL 中序列的语法是:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NEXTVAL(’sequence’);</span><br><span class="line">CURRVAL(’sequence’);</span><br><span class="line">SETVAL(’sequence’,value);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="keyword">sequence</span>;  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">sequence</span> (  </span><br><span class="line"><span class="keyword">name</span>              <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">current_value <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line"><span class="keyword">increment</span>       <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,  </span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">name</span>)  </span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;  </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">sequence</span> <span class="keyword">VALUES</span> (<span class="string">'MovieSeq'</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h6 id="测试一下结果："><a href="#测试一下结果：" class="headerlink" title="测试一下结果："></a>测试一下结果：</h6><p>测试 <strong>currval</strong> 函数使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* currval 函数的实现 */</span></span><br><span class="line"> <span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> currval;  </span><br><span class="line"> DELIMITER $  </span><br><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> currval (seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>))  </span><br><span class="line"> <span class="keyword">RETURNS</span> <span class="built_in">INTEGER</span>  </span><br><span class="line"> CONTAINS <span class="keyword">SQL</span>  </span><br><span class="line"> <span class="keyword">BEGIN</span>  </span><br><span class="line"> <span class="keyword">DECLARE</span> <span class="keyword">value</span> <span class="built_in">INTEGER</span>;  </span><br><span class="line"> <span class="keyword">SET</span> <span class="keyword">value</span> = <span class="number">0</span>;  </span><br><span class="line"> <span class="keyword">SELECT</span> current_value <span class="keyword">INTO</span> <span class="keyword">value</span>  </span><br><span class="line"> <span class="keyword">FROM</span> <span class="keyword">sequence</span>  </span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;  </span><br><span class="line"> RETURN value;  </span><br><span class="line"> <span class="keyword">END</span>$  </span><br><span class="line"> DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.  mysql&gt; SELECT currval(<span class="string">'MovieSeq'</span>);  </span><br><span class="line">2.  +---------------------+  </span><br><span class="line">3.  | currval(<span class="string">'MovieSeq'</span>) |  </span><br><span class="line">4.  +---------------------+  </span><br><span class="line">5.  |                   3 |  </span><br><span class="line">6.  +---------------------+  </span><br><span class="line">7.  1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)  </span><br><span class="line">8.  mysql&gt; SELECT currval(<span class="string">'x'</span>);  </span><br><span class="line">9.  +--------------+  </span><br><span class="line">10.  | currval(<span class="string">'x'</span>) |  </span><br><span class="line">11.  +--------------+  </span><br><span class="line">12.  |            0 |  </span><br><span class="line">13.  +--------------+  </span><br><span class="line">14.  1 row <span class="keyword">in</span> <span class="built_in">set</span>, 1 warning (0.00 sec)  </span><br><span class="line">15.  mysql&gt; show warnings;  </span><br><span class="line">16.  +---------+------+------------------+  </span><br><span class="line">17.  | Level   | Code | Message          |  </span><br><span class="line">18.  +---------+------+------------------+  </span><br><span class="line">19.  | Warning | 1329 | No data to FETCH |  </span><br><span class="line">20.  +---------+------+------------------+  </span><br><span class="line">21.  1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>测试 <strong>nextval</strong> 函数使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* nextval 函数的实现 */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="keyword">nextval</span>;  </span><br><span class="line">DELIMITER $  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> <span class="keyword">nextval</span> (seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>))  </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">INTEGER</span>  </span><br><span class="line">CONTAINS <span class="keyword">SQL</span>  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">sequence</span>  </span><br><span class="line"><span class="keyword">SET</span>          current_value = current_value + <span class="keyword">increment</span>  </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;  </span><br><span class="line">RETURN currval(seq_name);  </span><br><span class="line"><span class="keyword">END</span>$  </span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.  mysql&gt; select nextval(<span class="string">'MovieSeq'</span>);  </span><br><span class="line">2.  +---------------------+  </span><br><span class="line">3.  | nextval(<span class="string">'MovieSeq'</span>) |  </span><br><span class="line">4.  +---------------------+  </span><br><span class="line">5.  |                  15 |  </span><br><span class="line">6.  +---------------------+  </span><br><span class="line">7.  1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.09 sec)  </span><br><span class="line"></span><br><span class="line">9.  mysql&gt; select nextval(<span class="string">'MovieSeq'</span>);  </span><br><span class="line">10.  +---------------------+  </span><br><span class="line">11.  | nextval(<span class="string">'MovieSeq'</span>) |  </span><br><span class="line">12.  +---------------------+  </span><br><span class="line">13.  |                  20 |  </span><br><span class="line">14.  +---------------------+  </span><br><span class="line">15.  1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.01 sec)  </span><br><span class="line"></span><br><span class="line">17.  mysql&gt; select nextval(<span class="string">'MovieSeq'</span>);  </span><br><span class="line">18.  +---------------------+  </span><br><span class="line">19.  | nextval(<span class="string">'MovieSeq'</span>) |  </span><br><span class="line">20.  +---------------------+  </span><br><span class="line">21.  |                  25 |  </span><br><span class="line">22.  +---------------------+  </span><br><span class="line">23.  1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>测试 <strong>setval</strong> 函数的使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* setval 函数的实现 */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> setval;  </span><br><span class="line">DELIMITER $  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> setval (seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>), <span class="keyword">value</span> <span class="built_in">INTEGER</span>)  </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">INTEGER</span>  </span><br><span class="line">CONTAINS <span class="keyword">SQL</span>  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">sequence</span>  </span><br><span class="line"><span class="keyword">SET</span>          current_value = <span class="keyword">value</span>  </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;  </span><br><span class="line">RETURN currval(seq_name);  </span><br><span class="line"><span class="keyword">END</span>$  </span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  mysql&gt; select setval('MovieSeq',<span class="number">150</span>);  </span><br><span class="line"><span class="number">2.</span>  +------------------------+  </span><br><span class="line"><span class="number">3.</span>  | setval('MovieSeq',<span class="number">150</span>) |  </span><br><span class="line"><span class="number">4.</span>  +------------------------+  </span><br><span class="line"><span class="number">5.</span>  |                    <span class="number">150</span> |  </span><br><span class="line"><span class="number">6.</span>  +------------------------+  </span><br><span class="line"><span class="number">7.</span>  <span class="number">1</span> row in set (<span class="number">0.06</span> sec)  </span><br><span class="line"></span><br><span class="line"><span class="number">9.</span>  mysql&gt; select curval('MovieSeq');  </span><br><span class="line"><span class="number">10.</span>  +---------------------+  </span><br><span class="line"><span class="number">11.</span>  | currval('MovieSeq') |  </span><br><span class="line"><span class="number">12.</span>  +---------------------+  </span><br><span class="line"><span class="number">13.</span>  |                 <span class="number">150</span> |  </span><br><span class="line"><span class="number">14.</span>  +---------------------+  </span><br><span class="line"><span class="number">15.</span>  <span class="number">1</span> row in set (<span class="number">0.00</span> sec)  </span><br><span class="line"></span><br><span class="line"><span class="number">17.</span>  mysql&gt; select nextval('MovieSeq');  </span><br><span class="line"><span class="number">18.</span>  +---------------------+  </span><br><span class="line"><span class="number">19.</span>  | nextval('MovieSeq') |  </span><br><span class="line"><span class="number">20.</span>  +---------------------+  </span><br><span class="line"><span class="number">21.</span>  |                 <span class="number">155</span> |  </span><br><span class="line"><span class="number">22.</span>  +---------------------+  </span><br><span class="line"><span class="number">23.</span>  <span class="number">1</span> row in set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h5 id="三、MySQL-替代-Oracle-序列实例："><a href="#三、MySQL-替代-Oracle-序列实例：" class="headerlink" title="三、MySQL 替代 Oracle 序列实例："></a>三、MySQL 替代 Oracle 序列实例：</h5><ul><li>1、问题场景：<br><strong>一般使用序列 (Sequence) 来处理主键字段，在 MySQL中 是没有序列的，但是 MySQL有提供了自增长 (increment) 来实现类似的目的，但也只是自增，而不能设置步长、开始索引、是否循环等，最重要的是一张表只能由一个字段使用自增，但有的时候我们需要两个或两个以上的字段实现自增（单表多字段自增），MySQL本身是实现不了的，但我们可以用创建一个序列表，使用函数来获取序列的值。</strong></li></ul><p>– MySQL 给数据表某个字段创建序列。<br>– 序列：自增（步长、开始索引、是否循环），暂不考虑是否循环自增（触发器可实现？）<br>select * from PAN_WF_HISTORYNODE;– ORDER_NUMBER 字段创建序列</p><p>– 创建代替序列的数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="keyword">sequence</span>;  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">sequence</span> (  </span><br><span class="line"><span class="keyword">name</span>              <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="comment">-- 序列 名称 50个字符最大值问题已够用，暂不考虑是否循环。</span></span><br><span class="line">current_value <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,  <span class="comment">-- 当前值</span></span><br><span class="line"><span class="keyword">increment</span>       <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,  <span class="comment">-- 步长</span></span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">name</span>)  </span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;  </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">sequence</span> <span class="keyword">VALUES</span> (<span class="string">'seq_hisnode'</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>–  处理 序列的 currval 函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span> <span class="keyword">global</span> log_bin_trust_function_creators=<span class="number">1</span>;<span class="comment">-- 解决自定义函数报错：ERROR 1418-This function has none of DETERMINISTIC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> currval;  </span><br><span class="line">DELIMITER $  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> currval (seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>))  </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">INTEGER</span>  </span><br><span class="line">CONTAINS <span class="keyword">SQL</span>  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line">  <span class="keyword">DECLARE</span> <span class="keyword">value</span> <span class="built_in">INTEGER</span>;  </span><br><span class="line">  <span class="keyword">SET</span> <span class="keyword">value</span> = <span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">SELECT</span> current_value <span class="keyword">INTO</span> <span class="keyword">value</span>  </span><br><span class="line">  <span class="keyword">FROM</span> <span class="keyword">sequence</span>  </span><br><span class="line">  <span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;  </span><br><span class="line">  RETURN value;  </span><br><span class="line"><span class="keyword">END</span>$  </span><br><span class="line">DELIMITER ;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> currval(<span class="string">'seq_hisnode'</span>);<span class="comment">-- 测试 该函数的使用。</span></span><br></pre></td></tr></table></figure><p>– 处理序列的 nextval 函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="keyword">nextval</span>;  </span><br><span class="line">DELIMITER $  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> <span class="keyword">nextval</span> (seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>))  </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">INTEGER</span>  </span><br><span class="line">CONTAINS <span class="keyword">SQL</span>  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line">   <span class="keyword">UPDATE</span> <span class="keyword">sequence</span>  </span><br><span class="line">   <span class="keyword">SET</span>          current_value = current_value + <span class="keyword">increment</span>  </span><br><span class="line">   <span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;  </span><br><span class="line">   RETURN currval(seq_name);  </span><br><span class="line"><span class="keyword">END</span>$  </span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">nextval</span>(<span class="string">'seq_hisnode'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> PAN_WF_HISTORYNODE <span class="keyword">values</span>()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;什么是自增长？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自增长只能用于表中的其中一个字段。&lt;/li&gt;
&lt;li&gt;自增长只能被分配给固定表的固定的某一字段，不能被多个表共用。&lt;/li&gt;
&lt;li&gt;自增长会把一个未指定或NULL值的字段自动填上。&lt;/li&gt;
&lt;/
      
    
    </summary>
    
      <category term="MySQL 学习" scheme="http://yoursite.com/categories/MySQL-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MySQL 学习" scheme="http://yoursite.com/tags/MySQL-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Spring-4--AOP</title>
    <link href="http://yoursite.com/2019/03/25/Spring-4--AOP/"/>
    <id>http://yoursite.com/2019/03/25/Spring-4--AOP/</id>
    <published>2019-03-25T10:24:29.034Z</published>
    <updated>2019-03-25T02:23:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h3 id="1、为什么需要-AOP？"><a href="#1、为什么需要-AOP？" class="headerlink" title="1、为什么需要 AOP？"></a>1、为什么需要 AOP？</h3><p>需求案例：<br>需求1-日志：在程序执行期间追踪正在发生的活动。<br>需求2-验证：希望计算器只能处理正数的运算。</p><h4 id="1-1、不使用-AOP-时的代码实现。"><a href="#1-1、不使用-AOP-时的代码实现。" class="headerlink" title="1-1、不使用 AOP 时的代码实现。"></a>1-1、不使用 AOP 时的代码实现。</h4><p><img src="https://i.loli.net/2019/03/25/5c98a77ff16eb.jpg" alt="类图"></p><p><img src="https://i.loli.net/2019/03/25/5c98a78074ac0.jpg" alt="代码实现"></p><p><img src="https://i.loli.net/2019/03/25/5c98a780e4843.jpg" alt="问题分析"></p><hr><h4 id="1-2、使用动态代理解决问题分析"><a href="#1-2、使用动态代理解决问题分析" class="headerlink" title="1-2、使用动态代理解决问题分析"></a>1-2、使用动态代理解决问题分析</h4><p><strong>代理设计模式的原理：使用一个代理将对象包装起来, 然后用该代理对象取代原始对象. 任何对原始对象的调用都要通过代理. 代理对象决定是否以及何时将方法调用转到原始对象上。</strong></p><ul><li>0、接口实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArithmeticCalculatorImpl</span> <span class="keyword">implements</span> <span class="title">ArithmeticCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = i + j;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = i - j;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = i * j;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = i / j;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1、新建处理日志的代理类 ArithmeticCalculatorLoggingProxy，将原始对象包装起来。（<strong>匿名内部类的方式实现</strong>）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArithmeticCalculatorLoggingProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要代理的对象</span></span><br><span class="line"><span class="keyword">private</span> ArithmeticCalculator target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArithmeticCalculatorLoggingProxy</span><span class="params">(ArithmeticCalculator target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回代理对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArithmeticCalculator <span class="title">getLoggingProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">ArithmeticCalculator proxy = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">ClassLoader loader = target.getClass().getClassLoader();</span><br><span class="line">Class [] interfaces = <span class="keyword">new</span> Class[]&#123;ArithmeticCalculator.class&#125;;</span><br><span class="line">InvocationHandler h = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * proxy: 代理对象。 一般不使用该对象</span></span><br><span class="line"><span class="comment"> * method: 正在被调用的方法</span></span><br><span class="line"><span class="comment"> * args: 调用方法传入的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">String methodName = method.getName();</span><br><span class="line"><span class="comment">//打印日志</span></span><br><span class="line">System.out.println(<span class="string">"[before] The method "</span> + methodName + <span class="string">" begins with "</span> + Arrays.asList(args));</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用目标方法</span></span><br><span class="line">Object result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//前置通知</span></span><br><span class="line">result = method.invoke(target, args);</span><br><span class="line"><span class="comment">//返回通知, 可以访问到方法的返回值</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">//异常通知, 可以访问到方法出现的异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置通知. 因为方法可以能会出异常, 所以访问不到方法的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印日志</span></span><br><span class="line">System.out.println(<span class="string">"[after] The method ends with "</span> + result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * loader: 代理对象使用的类加载器。 </span></span><br><span class="line"><span class="comment"> * interfaces: 指定代理对象的类型. 即代理代理对象中可以有哪些方法. </span></span><br><span class="line"><span class="comment"> * h: 当具体调用代理对象的方法时, 应该如何进行响应, 实际上就是调用 InvocationHandler 的 invoke 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">proxy = (ArithmeticCalculator) Proxy.newProxyInstance(loader, interfaces, h);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（<strong>实现 InvocationHandler 接口的方式实现（推荐）</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理类的实现：InvocationHandler接口（invoke方法）+Proxy类（newProxyInstance方法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArithmeticCalculatorLoggingProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> ArithmeticCalculator target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArithmeticCalculatorLoggingProxy</span><span class="params">(ArithmeticCalculator target)</span> </span>&#123;</span><br><span class="line"><span class="comment">//super();</span></span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArithmeticCalculator <span class="title">getLoggingProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArithmeticCalculator proxy = <span class="keyword">null</span>;</span><br><span class="line">        ClassLoader loader = target.getClass().getClassLoader();</span><br><span class="line">        Class[] interfaces = <span class="keyword">new</span> Class[]&#123;ArithmeticCalculator.class&#125;;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Proxy 类：</span></span><br><span class="line"><span class="comment">         * loader: 代理对象使用的类加载器。</span></span><br><span class="line"><span class="comment">         * interfaces: 指定被代理对象的一组接口. 即被代理对象实现了哪些接口。指定后该代理对象实例就会实现被代理对象接口的所有方法。</span></span><br><span class="line"><span class="comment">         * h: 当具体调用代理对象的方法时, 应该如何进行响应, 实际上就是调用 InvocationHandler 的 invoke 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        proxy = (ArithmeticCalculator) Proxy.newProxyInstance(loader, interfaces, <span class="keyword">new</span> ArithmeticCalculatorLoggingProxy(target));<span class="comment">//h:参数，该类实现了此接口有继承关系。</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"代理对象实例："</span>+proxy.getClass().getName());<span class="comment">//代理对象实例</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * proxy: 代理对象。 一般不使用该对象</span></span><br><span class="line"><span class="comment">     * method: 正在被调用的方法</span></span><br><span class="line"><span class="comment">     * args: 调用方法传入的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        <span class="comment">//打印日志</span></span><br><span class="line">        System.out.println(<span class="string">"[before] The method "</span> + methodName + <span class="string">" begins with "</span> + Arrays.asList(args));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用目标方法</span></span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//前置通知</span></span><br><span class="line">            result = method.invoke(target, args);<span class="comment">//返回通知, 可以访问到方法的返回值</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            e.printStackTrace();<span class="comment">//异常通知, 可以访问到方法出现的异常</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后置通知. 因为方法可以能会出异常, 所以访问不到方法的返回值</span></span><br><span class="line">        <span class="comment">//打印日志</span></span><br><span class="line">        System.out.println(<span class="string">"[after] The method ends with "</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="1-3、动态代理原理分析"><a href="#1-3、动态代理原理分析" class="headerlink" title="1-3、动态代理原理分析"></a>1-3、动态代理原理分析</h4><ul><li>1、Java 动态代理创建出来的动态代理类。<br><strong>上面我们利用Proxy类的newProxyInstance方法创建了一个动态代理对象，查看该方法的源码，发现它只是封装了创建动态代理类的步骤(红色标准部分)：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实，我们最应该关注的是 Class&lt;?&gt; cl = getProxyClass0(loader, intfs);这句，这里产生了代理类，后面代码中的构造器也是通过这里产生的类来获得，可以看出，这个类的产生就是整个动态代理的关键，由于是动态生成的类文件，我这里不具体进入分析如何产生的这个类文件，只需要知道这个类文件时缓存在java虚拟机中的，我们可以通过下面的方法将其打印到文件里面，一睹真容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateProxyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">byte</span>[] classFile = ProxyGenerator.generateProxyClass(<span class="string">"$Proxy4"</span>, ArithmeticCalculatorImpl.class.getInterfaces());</span><br><span class="line">       String path = <span class="string">"E:\\PersonWorkSpace\\JavaEESpace\\spring-2\\src\\com\\atguigu\\spring\\dynamicProxy\\ArithmeticCalculatorImpl.class"</span>;</span><br><span class="line">       <span class="keyword">try</span>(FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(path)) &#123;</span><br><span class="line">           fos.write(classFile);</span><br><span class="line">           fos.flush();</span><br><span class="line">           System.out.println(<span class="string">"代理类class文件写入成功"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           System.out.println(<span class="string">"写文件错误"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>对这个class文件进行反编译，我们看看jdk为我们生成了什么样的内容：<br><strong>生成的代理类 实现了被代理类的接口。代理类调用接口方法时，会利用反射转发到invoke 去调用方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy4</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">ArithmeticCalculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m6;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m5;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy4(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> var1, <span class="keyword">int</span> var2)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m6, <span class="keyword">new</span> Object[]&#123;var1, var2&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> var1, <span class="keyword">int</span> var2)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1, var2&#125;);<span class="comment">//该代理类调用方法时转发到 invoke 方法反射调用。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> var1, <span class="keyword">int</span> var2)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m5, <span class="keyword">new</span> Object[]&#123;var1, var2&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> var1, <span class="keyword">int</span> var2)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, <span class="keyword">new</span> Object[]&#123;var1, var2&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m6 = Class.forName(<span class="string">"com.atguigu.spring.dynamicProxy.ArithmeticCalculator"</span>).getMethod(<span class="string">"mul"</span>, Integer.TYPE, Integer.TYPE);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.atguigu.spring.dynamicProxy.ArithmeticCalculator"</span>).getMethod(<span class="string">"add"</span>, Integer.TYPE, Integer.TYPE);</span><br><span class="line">            m5 = Class.forName(<span class="string">"com.atguigu.spring.dynamicProxy.ArithmeticCalculator"</span>).getMethod(<span class="string">"sub"</span>, Integer.TYPE, Integer.TYPE);</span><br><span class="line">            m4 = Class.forName(<span class="string">"com.atguigu.spring.dynamicProxy.ArithmeticCalculator"</span>).getMethod(<span class="string">"div"</span>, Integer.TYPE, Integer.TYPE);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考博客：<br><a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html。" target="_blank" rel="noopener">https://www.cnblogs.com/gonjan-blog/p/6685611.html。</a><br><a href="http://www.cnblogs.com/xiaoluo501395377/p/3383130.html。" target="_blank" rel="noopener">http://www.cnblogs.com/xiaoluo501395377/p/3383130.html。</a></p><hr><h4 id="1-4、总结"><a href="#1-4、总结" class="headerlink" title="1-4、总结"></a>1-4、总结</h4><p>生成的代理类：$Proxy0 extends Proxy implements Person，我们看到代理类继承了Proxy类，所以也就决定了java动态代理只能对接口进行代理，Java的继承机制注定了这些动态代理类们无法实现对class的动态代理。<br>上面的动态代理的例子，其实就是AOP的一个简单实现了，在目标对象的方法执行之前和执行之后进行了处理，对方法耗时统计。Spring的AOP实现其实也是用了Proxy和InvocationHandler这两个东西的。</p><hr><hr><h3 id="2、AOP-简介"><a href="#2、AOP-简介" class="headerlink" title="2、AOP 简介"></a>2、AOP 简介</h3><ul><li>1、AOP(Aspect-Oriented Programming, 面向切面编程)。</li><li>2、AOP 的主要编程对象是切面(aspect), 而切面模块化横切关注点。</li><li>3、在应用 AOP 编程时, 仍然需要定义公共功能, 但可以明确的定义这个功能在哪里, 以什么方式应用, 并且不必修改受影响的类. 这样一来横切关注点就被模块化到特殊的对象(切面)里。</li><li>4、AOP 的好处:<br>每个事物逻辑位于一个位置, 代码不分散, 便于维护和升级<br>业务模块更简洁, 只包含核心业务代码</li></ul><hr><hr><h3 id="3、AOP-术语"><a href="#3、AOP-术语" class="headerlink" title="3、AOP 术语"></a>3、AOP 术语</h3><h4 id="3-1、切面-Aspect"><a href="#3-1、切面-Aspect" class="headerlink" title="3-1、切面(Aspect)"></a>3-1、切面(Aspect)</h4><p>切面就是横切面，代表的是一个普遍存在的共有功能。例如，日志、验证、统计成员方法运行时间。都可作为一个切面来处理。<br>例：代理对象$proxy0 已经将日志切面与业务逻辑add 方法进行了合成。（先调invoke 打印日志，再反射调用 add 方法。）</p><h4 id="3-2、通知-Advice"><a href="#3-2、通知-Advice" class="headerlink" title="3-2、通知 (Advice)"></a>3-2、通知 (Advice)</h4><p>切面要完成的工作，例如：日志切面要完成打印日志的任务，则通知即是打印日志。前置通知在 add 方法反射执行前打印日志，后置通知在 add 方法反射执行后打印通知。</p><ul><li>五种类型的通知注解<br>@Before: 前置通知, 在方法执行之前执行。<br>@After: 后置通知, 在方法执行之后执行 。<br>@AfterRunning: 返回通知, 在方法返回结果之后执行。<br>@AfterThrowing: 异常通知, 在方法抛出异常之后。<br>@Around: 环绕通知, 围绕着方法执行。</li></ul><h4 id="3-3、目标-Target"><a href="#3-3、目标-Target" class="headerlink" title="3-3、目标 (Target)"></a>3-3、目标 (Target)</h4><h4 id="3-4、代理-Proxy"><a href="#3-4、代理-Proxy" class="headerlink" title="3-4、代理 (Proxy)"></a>3-4、代理 (Proxy)</h4><h4 id="3-5、连接点（Joinpoint）"><a href="#3-5、连接点（Joinpoint）" class="headerlink" title="3-5、连接点（Joinpoint）"></a>3-5、连接点（Joinpoint）</h4><p>程序执行的某个特定位置：如类某个方法调用前、调用后、方法抛出异常后等。<br>例如 ArithmethicCalculator#add()方法。</p><h4 id="3-6、切点（pointcut）"><a href="#3-6、切点（pointcut）" class="headerlink" title="3-6、切点（pointcut）"></a>3-6、切点（pointcut）</h4><p>每个类都拥有多个连接点：例如 ArithmethicCalculator 的所有方法实际上都是连接点。<br>AOP 通过切点定位到特定的连接点。切点即指类和方法。AOP 使用类和方法作为连接点的查询条件。定位连接点。</p><hr><h3 id="4、在Spring-中启用-AspectJ-AOP框架。"><a href="#4、在Spring-中启用-AspectJ-AOP框架。" class="headerlink" title="4、在Spring 中启用 AspectJ AOP框架。"></a>4、在Spring 中启用 AspectJ AOP框架。</h3><ul><li>1、要在 Spring 应用中使用 AspectJ 注解, 必须在 classpath 下包含 AspectJ 类库: aopalliance.jar、aspectj.weaver.jar 和 spring-aspects.jar</li><li>2、将 aop Schema 添加到 <beans> 根元素中.</beans></li><li>3、要在 Spring IOC 容器中启用 AspectJ 注解支持, 只要在 Bean 配置文件中定义一个空的 XML 元素 &lt; aop:aspectj-autoproxy &gt;</li><li>4、当 Spring IOC 容器侦测到 Bean 配置文件中的 &lt; aop:aspectj-autoproxy&gt; 元素时, 会自动为与 AspectJ 切面匹配的 Bean 创建代理。</li></ul><hr><h4 id="4-1、用-AspectJ-注解声明切面"><a href="#4-1、用-AspectJ-注解声明切面" class="headerlink" title="4-1、用 AspectJ 注解声明切面"></a>4-1、用 AspectJ 注解声明切面</h4><ul><li>1、要在 Spring 中声明 AspectJ 切面, 只需要在 IOC 容器中将切面声明为 Bean 实例. 当在 Spring IOC 容器中初始化 AspectJ 切面之后, Spring IOC 容器就会为那些与 AspectJ 切面相匹配的 Bean 创建代理.。</li><li>2、在 AspectJ 注解中, 切面只是一个带有 @Aspect 注解的 Java 类. 。</li><li>3、通知是标注有某种注解的简单的 Java 方法.。</li><li>4、AspectJ 支持 5 种类型的通知注解:<br>@Before: 前置通知, 在方法执行之前执行。<br>@After: 后置通知, 在方法执行之后执行 。<br>@AfterRunning: 返回通知, 在方法返回结果之后执行。<br>@AfterThrowing: 异常通知, 在方法抛出异常之后。<br>@Around: 环绕通知, 围绕着方法执行。</li></ul><hr><h4 id="4-2、前置通知"><a href="#4-2、前置通知" class="headerlink" title="4-2、前置通知"></a>4-2、前置通知</h4><p><img src="https://i.loli.net/2019/03/25/5c98a7815cf38.jpg" alt="前置通知"><br><strong>利用方法签名编写 AspectJ 切入点表达式</strong></p><p><img src="https://i.loli.net/2019/03/25/5c98a781c9ebc.jpg" alt="切点表达式"></p><ul><li>方法签名：方法签名由方法名称和一个参数列表（方法的参数的顺序和类型）组成；注意，方法签名不包括方法的返回类型。不包括返回值和访问修饰符</li><li>切点表达式：</li><li>合并切点表达式</li></ul><p><img src="https://i.loli.net/2019/03/25/5c98a7821fc2d.jpg" alt="合并切点表达式"></p><ul><li>让通知访问当前连接点的细节</li></ul><p><img src="https://i.loli.net/2019/03/25/5c98a7826fdad.jpg" alt="通知访问连接点的细节"></p><hr><h4 id="4-3、后置通知"><a href="#4-3、后置通知" class="headerlink" title="4-3、后置通知"></a>4-3、后置通知</h4><p><img src="https://i.loli.net/2019/03/25/5c98a782bf959.jpg" alt="后置通知"></p><hr><h4 id="4-4、返回通知"><a href="#4-4、返回通知" class="headerlink" title="4-4、返回通知"></a>4-4、返回通知</h4><p><img src="https://i.loli.net/2019/03/25/5c98a7831bbab.jpg" alt="返回通知"></p><ul><li>返回通知中访问连接点的返回值</li></ul><p><img src="https://i.loli.net/2019/03/25/5c98a78370d6c.jpg" alt="返回通知访问连接点的返回值"></p><hr><h4 id="4-5、异常通知"><a href="#4-5、异常通知" class="headerlink" title="4-5、异常通知"></a>4-5、异常通知</h4><p><img src="https://i.loli.net/2019/03/25/5c98aa1b58cb0.jpg" alt="异常通知"></p><hr><h4 id="4-6、环绕通知"><a href="#4-6、环绕通知" class="headerlink" title="4-6、环绕通知"></a>4-6、环绕通知</h4><p><img src="https://i.loli.net/2019/03/25/5c98aa1ba90c2.jpg" alt="环绕通知"></p><p><img src="https://i.loli.net/2019/03/25/5c98aa1c0d2b4.jpg" alt="环绕通知示例"></p><hr><h4 id="4-7、指定切面的优先级"><a href="#4-7、指定切面的优先级" class="headerlink" title="4-7、指定切面的优先级"></a>4-7、指定切面的优先级</h4><p><img src="https://i.loli.net/2019/03/25/5c98aa1c577c7.jpg" alt="指定切面优先级"></p><hr><h4 id="4-8、重用切入点定义"><a href="#4-8、重用切入点定义" class="headerlink" title="4-8、重用切入点定义"></a>4-8、重用切入点定义</h4><p>见 合并切入点</p><p><img src="https://i.loli.net/2019/03/25/5c98aa1ca8654.jpg" alt="重用切入点"></p><p><img src="https://i.loli.net/2019/03/25/5c98aa1d055aa.jpg" alt="示例"></p><hr><h4 id="4-9、引入通知"><a href="#4-9、引入通知" class="headerlink" title="4-9、引入通知"></a>4-9、引入通知</h4><p><strong>引入通知是一种特殊的通知类型. 它通过为接口提供实现类, 允许对象动态地实现接口, 就像对象已经在运行时扩展了实现类一样</strong></p><h4 id="4-10、用XML-声明切面、切点、通知（包括引入通知）"><a href="#4-10、用XML-声明切面、切点、通知（包括引入通知）" class="headerlink" title="4-10、用XML 声明切面、切点、通知（包括引入通知）"></a>4-10、用XML 声明切面、切点、通知（包括引入通知）</h4><hr><h3 id="5、Spring-对JDBC-的支持"><a href="#5、Spring-对JDBC-的支持" class="headerlink" title="5、Spring 对JDBC 的支持"></a>5、Spring 对JDBC 的支持</h3><h4 id="5-1、Spring-xml-中配置-JDBC-模板类和-c3p0-数据源"><a href="#5-1、Spring-xml-中配置-JDBC-模板类和-c3p0-数据源" class="headerlink" title="5-1、Spring xml 中配置 JDBC 模板类和 c3p0 数据源"></a>5-1、Spring xml 中配置 JDBC 模板类和 c3p0 数据源</h4><p>org.springframework.jdbc.core.JdbcTemplate</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.atguigu.spring"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 导入资源文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置 C3P0 数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.user&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.jdbcUrl&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClass&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.initPoolSize&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.maxPoolSize&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置 Spirng 的 JdbcTemplate --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-2、jdbcTemplate-模板方法测试"><a href="#5-2、jdbcTemplate-模板方法测试" class="headerlink" title="5-2、jdbcTemplate 模板方法测试"></a>5-2、jdbcTemplate 模板方法测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ApplicationContext ctx = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"><span class="keyword">private</span> EmployeeDao employeeDao;</span><br><span class="line"><span class="keyword">private</span> DepartmentDao departmentDao;</span><br><span class="line"><span class="keyword">private</span> NamedParameterJdbcTemplate namedParameterJdbcTemplate;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">jdbcTemplate = (JdbcTemplate) ctx.getBean(<span class="string">"jdbcTemplate"</span>);</span><br><span class="line">employeeDao = ctx.getBean(EmployeeDao.class);</span><br><span class="line">departmentDao = ctx.getBean(DepartmentDao.class);</span><br><span class="line">namedParameterJdbcTemplate = ctx.getBean(NamedParameterJdbcTemplate.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取单个列的值, 或做统计查询</span></span><br><span class="line"><span class="comment"> * 使用 queryForObject(String sql, Class&lt;Long&gt; requiredType) </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryForObject2</span><span class="params">()</span></span>&#123;</span><br><span class="line">String sql = <span class="string">"SELECT count(id) FROM employees"</span>;</span><br><span class="line"><span class="keyword">long</span> count = jdbcTemplate.queryForObject(sql, Long.class);</span><br><span class="line"></span><br><span class="line">System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查到实体类的集合</span></span><br><span class="line"><span class="comment"> * 注意调用的不是 queryForList 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryForList</span><span class="params">()</span></span>&#123;</span><br><span class="line">String sql = <span class="string">"SELECT id, last_name lastName, email FROM employees WHERE id &gt; ?"</span>;</span><br><span class="line">RowMapper&lt;Employee&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Employee.class);</span><br><span class="line">List&lt;Employee&gt; employees = jdbcTemplate.query(sql, rowMapper,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(employees);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库中获取一条记录, 实际得到对应的一个对象</span></span><br><span class="line"><span class="comment"> * 注意不是调用 queryForObject(String sql, Class&lt;Employee&gt; requiredType, Object... args) 方法!</span></span><br><span class="line"><span class="comment"> * 而需要调用 queryForObject(String sql, RowMapper&lt;Employee&gt; rowMapper, Object... args)</span></span><br><span class="line"><span class="comment"> * 1. 其中的 RowMapper 指定如何去映射结果集的行, 常用的实现类为 BeanPropertyRowMapper</span></span><br><span class="line"><span class="comment"> * 2. 使用 SQL 中列的别名完成列名和类的属性名的映射. 例如 last_name lastName</span></span><br><span class="line"><span class="comment"> * 3. 不支持级联属性. JdbcTemplate 到底是一个 JDBC 的小工具, 而不是 ORM 框架</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryForObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">String sql = <span class="string">"SELECT id, last_name lastName, email, dept_id as \"department.id\" FROM employees WHERE id = ?"</span>;</span><br><span class="line">RowMapper&lt;Employee&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Employee.class);</span><br><span class="line">Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(employee);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行批量更新: 批量的 INSERT, UPDATE, DELETE</span></span><br><span class="line"><span class="comment"> * 最后一个参数是 Object[] 的 List 类型: 因为修改一条记录需要一个 Object 的数组, 那么多条不就需要多个 Object 的数组吗</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatchUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">String sql = <span class="string">"INSERT INTO employees(last_name, email, dept_id) VALUES(?,?,?)"</span>;</span><br><span class="line"></span><br><span class="line">List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="string">"AA"</span>, <span class="string">"aa@atguigu.com"</span>, <span class="number">1</span>&#125;);</span><br><span class="line">batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="string">"BB"</span>, <span class="string">"bb@atguigu.com"</span>, <span class="number">2</span>&#125;);</span><br><span class="line">batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="string">"CC"</span>, <span class="string">"cc@atguigu.com"</span>, <span class="number">3</span>&#125;);</span><br><span class="line">batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="string">"DD"</span>, <span class="string">"dd@atguigu.com"</span>, <span class="number">3</span>&#125;);</span><br><span class="line">batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="string">"EE"</span>, <span class="string">"ee@atguigu.com"</span>, <span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line">jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行 INSERT, UPDATE, DELETE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">String sql = <span class="string">"UPDATE employees SET last_name = ? WHERE id = ?"</span>;</span><br><span class="line">jdbcTemplate.update(sql, <span class="string">"Jack"</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">DataSource dataSource = ctx.getBean(DataSource.class);</span><br><span class="line">System.out.println(dataSource.getConnection());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3、NamedParameterJdbcTemplate-具名参数模板类。"><a href="#5-3、NamedParameterJdbcTemplate-具名参数模板类。" class="headerlink" title="5-3、NamedParameterJdbcTemplate 具名参数模板类。"></a>5-3、NamedParameterJdbcTemplate 具名参数模板类。</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 NamedParameterJdbcTemplate, 该对象可以使用具名参数, 其没有无参数的构造器, 所以必须为其构造器指定参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"namedParameterJdbcTemplate"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用具名参数时, 可以使用 update(String sql, SqlParameterSource paramSource) 方法进行更新操作</span></span><br><span class="line"><span class="comment"> * 1. SQL 语句中的参数名和类的属性一致!</span></span><br><span class="line"><span class="comment"> * 2. 使用 SqlParameterSource 的 BeanPropertySqlParameterSource 实现类作为参数. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNamedParameterJdbcTemplate2</span><span class="params">()</span></span>&#123;</span><br><span class="line">String sql = <span class="string">"INSERT INTO employees(last_name, email, dept_id) "</span></span><br><span class="line">+ <span class="string">"VALUES(:lastName,:email,:dpetId)"</span>;</span><br><span class="line"></span><br><span class="line">Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.setLastName(<span class="string">"XYZ"</span>);</span><br><span class="line">employee.setEmail(<span class="string">"xyz@sina.com"</span>);</span><br><span class="line">employee.setDpetId(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">SqlParameterSource paramSource = <span class="keyword">new</span> BeanPropertySqlParameterSource(employee);</span><br><span class="line">namedParameterJdbcTemplate.update(sql, paramSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以为参数起名字. </span></span><br><span class="line"><span class="comment"> * 1. 好处: 若有多个参数, 则不用再去对应位置, 直接对应参数名, 便于维护</span></span><br><span class="line"><span class="comment"> * 2. 缺点: 较为麻烦. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNamedParameterJdbcTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">String sql = <span class="string">"INSERT INTO employees(last_name, email, dept_id) VALUES(:ln,:email,:deptid)"</span>;</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; paramMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">paramMap.put(<span class="string">"ln"</span>, <span class="string">"FF"</span>);</span><br><span class="line">paramMap.put(<span class="string">"email"</span>, <span class="string">"ff@atguigu.com"</span>);</span><br><span class="line">paramMap.put(<span class="string">"deptid"</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">namedParameterJdbcTemplate.update(sql, paramMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6、Spring-对事务的管理"><a href="#6、Spring-对事务的管理" class="headerlink" title="6、Spring 对事务的管理"></a>6、Spring 对事务的管理</h3><h4 id="6-1、声明式事务"><a href="#6-1、声明式事务" class="headerlink" title="6-1、声明式事务"></a>6-1、声明式事务</h4><ul><li>1、编程式事务管理<br>将事务管理代码嵌入到业务方法中来控制事务的提交和回滚。（正常方式）</li></ul><p>-2、声明式事务管理<br>将事务管理代码从业务方法中分离出来, 以声明的方式来实现事务管理。Spring 通过 Spring AOP 框架支持声明式事务管理。通过使用注解+配置事务管理器。</p><hr><h4 id="6-2、事务的传播行为"><a href="#6-2、事务的传播行为" class="headerlink" title="6-2、事务的传播行为"></a>6-2、事务的传播行为</h4><h4 id="6-3、事务的隔离级别"><a href="#6-3、事务的隔离级别" class="headerlink" title="6-3、事务的隔离级别"></a>6-3、事务的隔离级别</h4><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&quot;1、为什么需要-AOP？&quot;&gt;&lt;a href=&quot;#1、为什么需要-AOP？&quot; class=&quot;headerlink&quot; title=&quot;1、为什么需要 AOP？&quot;&gt;&lt;/a&gt;1、为什么需要 AOP？&lt;/h3&gt;&lt;p&gt;需求案例：&lt;br&gt;需求1-日志：在
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-3--IOC&amp;DI</title>
    <link href="http://yoursite.com/2019/03/25/Spring-3--IOC&amp;DI/"/>
    <id>http://yoursite.com/2019/03/25/Spring-3--IOC&amp;DI/</id>
    <published>2019-03-25T10:24:29.032Z</published>
    <updated>2019-03-25T02:23:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h3 id="1、IOC-amp-DI-概述"><a href="#1、IOC-amp-DI-概述" class="headerlink" title="1、IOC&amp;DI 概述"></a>1、IOC&amp;DI 概述</h3><h4 id="1-1、IOC-控制反转"><a href="#1-1、IOC-控制反转" class="headerlink" title="1-1、IOC-控制反转"></a>1-1、IOC-控制反转</h4><p>IOC(Inversion of Control)：其思想是反转资源获取的方向. 传统的资源查找方式要求组件向容器发起请求查找资源. 作为回应, 容器适时的返回资源. 而应用了 IOC 之后, 则是容器主动地将资源推送给它所管理的组件, 组件所要做的仅是选择一种合适的方式来接受资源. 这种行为也被称为查找的被动形式。</p><hr><h4 id="1-2、DI-依赖注入"><a href="#1-2、DI-依赖注入" class="headerlink" title="1-2、DI-依赖注入"></a>1-2、DI-依赖注入</h4><p>DI(Dependency Injection) — IOC 的另一种表述方式：即组件以一些预先定义好的方式(例如: setter 方法)接受来自如容器的资源注入. 相对于 IOC 而言，这种表述更直接。</p><hr><h4 id="1-3、在-Spring-IOC-容器中配置-Bean"><a href="#1-3、在-Spring-IOC-容器中配置-Bean" class="headerlink" title="1-3、在 Spring IOC 容器中配置 Bean"></a>1-3、在 Spring IOC 容器中配置 Bean</h4><ul><li>1、在 Spring IOC 容器读取 Bean 配置创建 Bean 实例之前, 必须对它进行实例化. 只有在容器实例化后, 才可以从 IOC 容器里获取 Bean 实例并使用。</li><li><p>2、Spring 提供了两种类型的 IOC 容器实现。</p><ul><li>BeanFactory: IOC 容器的基本实现：</li></ul><ul><li>ApplicationContext: 提供了更多的高级特性. 是 BeanFactory 的子接口。</li></ul></li></ul><hr><h3 id="2、配置-Bean"><a href="#2、配置-Bean" class="headerlink" title="2、配置 Bean"></a>2、配置 Bean</h3><h4 id="2-1、配置形式"><a href="#2-1、配置形式" class="headerlink" title="2-1、配置形式"></a>2-1、配置形式</h4><ul><li><strong>基于 XML 文件的配置方式</strong></li><li>基于注解的方式（实际开发中主要使用该方式）</li></ul><hr><h4 id="2-2、Bean-的配置方式"><a href="#2-2、Bean-的配置方式" class="headerlink" title="2-2、Bean 的配置方式"></a>2-2、Bean 的配置方式</h4><ul><li><strong>通过全类名（反射）</strong></li><li>通过工厂方法（静态工厂方法&amp;实例工厂方法）</li><li>FactoryBean</li></ul><hr><h4 id="2-3、IOC-容器-BeanFactory-amp-ApplicationContext-概述"><a href="#2-3、IOC-容器-BeanFactory-amp-ApplicationContext-概述" class="headerlink" title="2-3、IOC 容器 BeanFactory &amp; ApplicationContext 概述"></a>2-3、IOC 容器 BeanFactory &amp; ApplicationContext 概述</h4><ul><li>BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；ApplicationContext 面向使用 Spring 框架的开发者，几乎所有的应用场合都直接使用 ApplicationContext 而非底层的 BeanFactory</li><li>ApplicationContext 接口</li></ul><p><img src="https://i.loli.net/2019/03/25/5c98a73020db2.jpg" alt="ApplicationContext 类图"></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext 的主要实现类：</span><br><span class="line">ClassPathXmlApplicationContext：从 类路径下加载配置文件</span><br><span class="line">FileSystemXmlApplicationContex<span class="variable">t:</span> 从文件系统中加载配置文件</span><br><span class="line"></span><br><span class="line">ConfigurableApplicationContext 扩展于 ApplicationContext，新增加两个主要方法：refresh() 和 <span class="keyword">close</span>()， 让 ApplicationContext 具有启动、刷新和关闭上下文的能力。</span><br><span class="line"></span><br><span class="line">ApplicationContext 在初始化上下文时就实例化所有单例的 Bean。</span><br><span class="line"></span><br><span class="line">WebApplicationContext 是专门为 WEB 应用而准备的，它允许从相对于 WEB 根目录的路径中完成初始化工作。</span><br></pre></td></tr></table></figure><p>从容器中 获取 Bean</p><p><img src="https://i.loli.net/2019/03/25/5c98a730f067c.jpg" alt="getBean()方法"></p><hr><h4 id="2-4、依赖注入的方式"><a href="#2-4、依赖注入的方式" class="headerlink" title="2-4、依赖注入的方式"></a>2-4、依赖注入的方式</h4><ul><li>属性注入（注入细节）<ul><li>字面值</li><li>引用其他 Bean</li><li>内部Bean</li><li>注入参数：（null 值和级联属性）</li><li>集合属性&amp; utility scheme 定义集合</li><li>使用 P 命名空间</li></ul></li><li>构造器注入</li><li>泛型依赖注入</li></ul><p>1、Beans<br>com.atguigu.spring.helloworld.HelloWorld<br>com.atguigu.spring.ref.Dao<br>com.atguigu.spring.ref.Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String user;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"HelloWorld's constructor..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">(String user)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.user = user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(String user)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"setUser:"</span> + user);</span><br><span class="line"><span class="keyword">this</span>.user = user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hello: "</span> + user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.spring.ref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String dataSource = <span class="string">"dbcp"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(String dataSource)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"save by "</span> + dataSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Dao's Constructor..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"[dataSource]:"</span>+dataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.spring.ref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Dao dao;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDao</span><span class="params">(Dao dao)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.dao = dao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dao <span class="title">getDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> dao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Service's save"</span>);</span><br><span class="line">dao.save();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Spring xml配置Beans</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1、属性注入：配置一个 bean 通过 setter 方法 为属性赋值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorld1"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.helloworld.HelloWorld"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"Jerry"</span>/&gt;</span><span class="comment">&lt;!-- 为属性赋值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2、构造器注入：通过构造器注入属性值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorld3"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.helloworld.HelloWorld"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"Mike"</span>/&gt;</span><span class="comment">&lt;!-- 要求: 在 Bean 中必须有对应的构造器.  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2-1、若一个 bean 有多个构造器, 如何通过构造器来为 bean 的属性赋值 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可以根据 index 和 value 进行更加精确的定位. (了解) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.helloworld.Car"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"KUGA"</span> <span class="attr">index</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"ChangAnFord"</span> <span class="attr">index</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"250000"</span> <span class="attr">type</span>=<span class="string">"float"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--3、属性注入细节：字面值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car2"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.helloworld.Car"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"ChangAnMazda"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[&lt;ATARZA&gt;]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!-- 若字面值中包含特殊字符, 则可以使用 CDATA 来进行赋值. (了解) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"180"</span> <span class="attr">type</span>=<span class="string">"int"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4、属性注入细节：引用其他 bean 配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dao5"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.ref.Dao"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"service"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.ref.Service"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dao"</span> <span class="attr">ref</span>=<span class="string">"dao5"</span>/&gt;</span><span class="comment">&lt;!-- 通过 ref 属性值指定当前属性指向哪一个 bean! --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 5、属性注入细节：声明使用内部 bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"service2"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.ref.Service"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dao"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.ref.Dao"</span>&gt;</span><span class="comment">&lt;!-- 内部 bean, 类似于匿名内部类对象. 不能被外部的 bean 来引用, 也没有必要设置 id 属性 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">value</span>=<span class="string">"c3p0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--6、属性注入细节：注入参数之级联属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"action"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.ref.Action"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"service"</span> <span class="attr">ref</span>=<span class="string">"service2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"service.dao.dataSource"</span> <span class="attr">value</span>=<span class="string">"DBCP2"</span>/&gt;</span><span class="comment">&lt;!-- 设置级联属性(了解) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dao2"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.ref.Dao"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 为 Dao 的 dataSource 属性赋值为 null, 若某一个 bean 的属性值不是 null, 使用时需要为其设置为 null(了解) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 7、属性注入细节：装配集合属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.helloworld.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"Jack"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cars"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span><span class="comment">&lt;!-- 使用 list 元素来装配集合属性 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"car"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"car2"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 7-1、声明集合类型的 bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">"cars"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"car"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"car2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--7-2、引用外部声明的集合--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user2"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.helloworld.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"Rose"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cars"</span> <span class="attr">ref</span>=<span class="string">"cars"</span>/&gt;</span><span class="comment">&lt;!-- 引用外部声明的 list --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--8、属性注入细节：定义 P 命名空间--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user3"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.helloworld.User"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:cars-ref</span>=<span class="string">"cars"</span> <span class="attr">p:userName</span>=<span class="string">"Titannic"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">         bean 的配置能够继承吗 ? 使用 parent 来完成继承</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user4"</span> <span class="attr">parent</span>=<span class="string">"user"</span> <span class="attr">p:userName</span>=<span class="string">"Bob"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user6"</span> <span class="attr">parent</span>=<span class="string">"user"</span> <span class="attr">p:userName</span>=<span class="string">"维多利亚"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 测试 depents-on --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user5"</span> <span class="attr">parent</span>=<span class="string">"user"</span> <span class="attr">p:userName</span>=<span class="string">"Backham"</span> <span class="attr">depends-on</span>=<span class="string">"user6"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、测试 Main </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.ref.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*测试未使用Spring 前对象的实例化操作*/</span></span><br><span class="line">HelloWorld helloWorld = <span class="keyword">new</span> HelloWorld();</span><br><span class="line">helloWorld.setUser(<span class="string">"Tom"</span>);</span><br><span class="line">helloWorld.hello();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试使用 Spring 容器 后 对象实例化的操作*/</span></span><br><span class="line">ClassPathXmlApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);<span class="comment">//创建 Spring 的 IOC 容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、测试 通过 setter 方法注入属性值</span></span><br><span class="line">HelloWorld helloWorld1= (HelloWorld) ctx.getBean(<span class="string">"helloWorld1"</span>);</span><br><span class="line">helloWorld1.hello();</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据类型来获取 bean 的实例: 要求在  IOC 容器中只有一个与之类型匹配的 bean, 若有多个则会抛出异常.</span></span><br><span class="line"><span class="comment">// 一般情况下, 该方法可用, 因为一般情况下, 在一个 IOC 容器中一个类型对应的 bean 也只有一个.</span></span><br><span class="line"><span class="comment">//HelloWorld helloWorld1 = ctx.getBean(HelloWorld.class);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、测试通过构造器为属性赋值</span></span><br><span class="line">HelloWorld helloWorld3 = (HelloWorld)ctx.getBean(<span class="string">"helloWorld3"</span>);</span><br><span class="line">helloWorld3.hello();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2-1、测试 bean 有多个构造器, 如何通过构造器来为 bean 的属性赋值*/</span></span><br><span class="line">Car car = (Car) ctx.getBean(<span class="string">"car"</span>);</span><br><span class="line">System.out.println(car);<span class="comment">//Car [company=ChangAnFord, brand=KUGA, maxSpeed=0, price=250000.0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*3、属性注入细节：字面值*/</span></span><br><span class="line">Car car2= (Car) ctx.getBean(<span class="string">"car2"</span>);</span><br><span class="line">System.out.println(car2);<span class="comment">//Car [company=ChangAnMazda, brand=&lt;ATARZA&gt;, maxSpeed=180, price=0.0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 属性注入细节：引用其他 Bean+级联属性设置</span></span><br><span class="line">Service service2= (Service) ctx.getBean(<span class="string">"service2"</span>);</span><br><span class="line">System.out.print(<span class="string">"service2:"</span>+service2.getDao().toString());<span class="comment">//由于级联属性的设置，输出结果为：[dataSource]:DBCP2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7、属性注入细节：装配集合属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="2-5、自动装配"><a href="#2-5、自动装配" class="headerlink" title="2-5、自动装配"></a>2-5、自动装配</h4><ul><li>XML 配置里的 Bean 自动装配。</li><li>XML 配置里的 Bean 自动装配的缺点。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1、自动装配: 只声明 bean, 而把 bean 之间的关系交给 IOC 容器来完成 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  </span></span><br><span class="line"><span class="comment">byType: 根据类型进行自动装配. 但要求 IOC 容器中只有一个类型对应的 bean, 若有多个则无法完成自动装配.</span></span><br><span class="line"><span class="comment">byName: 若属性名和某一个 bean 的 id 名一致, 即可完成自动装配. 若没有 id 一致的, 则无法完成自动装配</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在使用 XML 配置时, 自动装配用的不多. 但在基于 注解 的配置时, 自动装配使用的较多.  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dao"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.ref.Dao"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">value</span>=<span class="string">"C3P0"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：实际项目中很少使用xml方式的自动装配，在基于 注解 的配置时, 自动装配使用的较多，此处XML 配置方式的自动装配仅做了解。</p><hr><h4 id="2-6、Bean-之间的关系"><a href="#2-6、Bean-之间的关系" class="headerlink" title="2-6、Bean 之间的关系"></a>2-6、Bean 之间的关系</h4><ul><li>继承</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Spring</span> 允许继承 <span class="keyword">bean </span>的配置, 被继承的 <span class="keyword">bean </span>称为父 <span class="keyword">bean. </span>继承这个父 <span class="keyword">Bean </span>的 <span class="keyword">Bean </span>称为子 <span class="keyword">Bean</span></span><br><span class="line"><span class="keyword">子 </span><span class="keyword">Bean </span>从父 <span class="keyword">Bean </span>中继承配置, 包括 <span class="keyword">Bean </span>的属性配置</span><br><span class="line">子 <span class="keyword">Bean </span>也可以覆盖从父 <span class="keyword">Bean </span>继承过来的配置</span><br><span class="line">父 <span class="keyword">Bean </span>可以作为配置模板, 也可以作为 <span class="keyword">Bean </span>实例. 若只想把父 <span class="keyword">Bean </span>作为模板, 可以设置 &lt;<span class="keyword">bean&gt; </span>的abstract 属性为 true, 这样 Spring 将不会实例化这个 <span class="keyword">Bean</span></span><br><span class="line"><span class="keyword">并不是 </span>&lt;<span class="keyword">bean&gt; </span>元素里的所有属性都会被继承. 比如: autowire, abstract 等.</span><br><span class="line">也可以忽略父 <span class="keyword">Bean </span>的 class 属性, 让子 <span class="keyword">Bean </span>指定自己的类, 而共享相同的属性配置. 但此时 abstract 必须设为 true</span><br></pre></td></tr></table></figure><ul><li>依赖</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Spring</span> 允许用户通过 depends-on 属性设定 <span class="keyword">Bean </span>前置依赖的<span class="keyword">Bean，前置依赖的 </span><span class="keyword">Bean </span>会在本 <span class="keyword">Bean </span>实例化之前创建好</span><br><span class="line">如果前置依赖于多个 <span class="keyword">Bean，则可以通过逗号，空格或的方式配置 </span><span class="keyword">Bean </span>的名称</span><br></pre></td></tr></table></figure><hr><h4 id="2-7、Bean-的作用域"><a href="#2-7、Bean-的作用域" class="headerlink" title="2-7、Bean 的作用域"></a>2-7、Bean 的作用域</h4><p>在 Spring 中, 可以在 <bean> 元素的 scope 属性里设置 Bean 的作用域。</bean></p><ul><li>singleton &amp; prototype</li></ul><p>beans-auto.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1、自动装配: 只声明 bean, 而把 bean 之间的关系交给 IOC 容器来完成 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  </span></span><br><span class="line"><span class="comment">byType: 根据类型进行自动装配. 但要求 IOC 容器中只有一个类型对应的 bean, 若有多个则无法完成自动装配.</span></span><br><span class="line"><span class="comment">byName: 若属性名和某一个 bean 的 id 名一致, 即可完成自动装配. 若没有 id 一致的, 则无法完成自动装配</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在使用 XML 配置时, 自动装配用的不多. 但在基于 注解 的配置时, 自动装配使用的较多.  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dao"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.ref.Dao"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">value</span>=<span class="string">"C3P0"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2、默认情况下 bean 是单例的! 即为 singleton--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 但有的时候, bean 就不能使单例的. 例如: Struts2 的 Action 就不是单例的! 可以通过 scope 属性来指定 bean 的作用域 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  </span></span><br><span class="line"><span class="comment">prototype: 原型的. 每次调用 getBean 方法都会返回一个新的 bean. 且在第一次调用 getBean 方法时才创建实例</span></span><br><span class="line"><span class="comment">singleton: 单例的. 每次调用 getBean 方法都会返回同一个 bean. 且在 IOC 容器初始化时即创建 bean 的实例. 默认值 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dao2"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.ref.Dao"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"service"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.ref.Service"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"action"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.ref.Action"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>测试 Main</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans-auto.xml"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试 bean 的作用域</span></span><br><span class="line">Dao dao1 = (Dao) ctx.getBean(<span class="string">"dao2"</span>);</span><br><span class="line">Dao dao2 = (Dao) ctx.getBean(<span class="string">"dao2"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(dao1 == dao2);<span class="comment">//false 非单例 Bean</span></span><br></pre></td></tr></table></figure><ul><li>WEB 环境作用域</li></ul><hr><h4 id="2-8、使用外部属性文件"><a href="#2-8、使用外部属性文件" class="headerlink" title="2-8、使用外部属性文件"></a>2-8、使用外部属性文件</h4><ul><li>在配置文件里配置 Bean 时, 有时需要在 Bean 的配置里混入系统部署的细节信息(例如: 文件路径, 数据源配置信息等). 而这些部署细节实际上需要和 Bean 配置相分离。</li><li>Spring 提供了一个 PropertyPlaceholderConfigurer 的 BeanFactory 后置处理器, 这个处理器允许用户将 Bean 配置的部分内容外移到属性文件中. 可以在 Bean 配置文件里使用形式为 ${var} 的变量, PropertyPlaceholderConfigurer 从属性文件里加载属性, 并使用这些属性来替换变量.</li><li>Spring 还允许在属性文件中使用 ${propName}，以实现属性之间的相互引用。</li><li>Spring 2.5 之后不要再配置 PropertyPlaceholderConfigurer 类，简化为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">``` xml</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置数据源 --&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">&lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.jdbcUrl&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property name=&quot;initialPoolSize&quot; value=&quot;$&#123;jdbc.initPoolSize&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;maxPoolSize&quot; value=&quot;$&#123;jdbc.maxPoolSize&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><p>测试 Main</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ClassPathXmlApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans-auto.xml"</span>);</span><br><span class="line"><span class="comment">//测试使用外部属性文件</span></span><br><span class="line">DataSource dataSource = (DataSource) ctx.getBean(<span class="string">"dataSource"</span>);</span><br><span class="line">System.out.println(dataSource.getConnection());</span><br></pre></td></tr></table></figure><hr><h4 id="2-9、SpEL（Spring-表达式语言）"><a href="#2-9、SpEL（Spring-表达式语言）" class="headerlink" title="2-9、SpEL（Spring 表达式语言）"></a>2-9、SpEL（Spring 表达式语言）</h4><ul><li><p>SpEL 简介</p><ul><li>Spring 表达式语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。</li><li>语法类似于 EL：SpEL 使用 #{…} 作为定界符，所有在大框号中的字符都将被认为是 SpEL。</li><li>SpEL 为 bean 的属性进行动态赋值提供了便利。</li><li>通过 SpEL 可以实现：    <ul><li>通过 bean 的 id 对 bean 进行引用。</li><li>调用方法以及引用对象中的属性。</li><li>计算表达式的值。</li><li>正则表达式的匹配。</li></ul></li></ul></li><li><p>SpEL：字面量</p></li></ul><p><img src="https://i.loli.net/2019/03/25/5c98a7317c807.jpg" alt="字面量的表示"></p><ul><li>SpEL：引用 Bean、属性和方法</li></ul><p><img src="https://i.loli.net/2019/03/25/5c98a7323dc80.jpg" alt="引用 Bean、属性和方法"></p><ul><li>SpEL 支持的运算符号</li></ul><p><img src="https://i.loli.net/2019/03/25/5c98a732c825e.jpg" alt="支持的运算符号1"></p><p><img src="https://i.loli.net/2019/03/25/5c98a73345bd7.jpg" alt="支持的运算符号2"></p><p>动态赋值<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 4、测试 SpEL: 可以为属性进行动态的赋值(了解) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"girl"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.helloworld.User"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"周迅"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"boy"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.helloworld.User"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span><span class="comment">&lt;!--User 类中定义了init、destroy方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"高胜远"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"wifeName"</span> <span class="attr">value</span>=<span class="string">"#&#123;girl.userName&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>测试 main</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans-auto.xml"</span>);</span><br><span class="line"><span class="comment">//测试 spEL</span></span><br><span class="line">User boy = (User) ctx.getBean(<span class="string">"boy"</span>);</span><br><span class="line">System.out.println(boy.getUserName() + <span class="string">":"</span> + boy.getWifeName());</span><br></pre></td></tr></table></figure><hr><h4 id="2-10、IOC-容器中-Bean-的生命周期"><a href="#2-10、IOC-容器中-Bean-的生命周期" class="headerlink" title="2-10、IOC 容器中 Bean 的生命周期"></a>2-10、IOC 容器中 Bean 的生命周期</h4><ul><li>1、Spring 配置 Bean 的后置通知</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 5、配置 bean 后置处理器: 不需要配置 id 属性, IOC 容器会识别到他是一个 bean 后置处理器, 并调用其方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.ref.MyBeanPostProcessor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.ref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.helloworld.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法在 init 方法之后被调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object arg0, String arg1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(arg1.equals(<span class="string">"boy"</span>))&#123;</span><br><span class="line">System.out.println(<span class="string">"postProcessAfterInitialization..."</span> + arg0 + <span class="string">","</span> + arg1);</span><br><span class="line">User user = (User) arg0;</span><br><span class="line">user.setUserName(<span class="string">"李大齐"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arg0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法在 init 方法之前被调用</span></span><br><span class="line"><span class="comment">//可以工作返回的对象来决定最终返回给 getBean 方法的对象是哪一个, 属性值是什么</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg0: 实际要返回的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg1: bean 的 id 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object arg0, String arg1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(arg1.equals(<span class="string">"boy"</span>))</span><br><span class="line">System.out.println(<span class="string">"postProcessBeforeInitialization..."</span> + arg0 + <span class="string">","</span> + arg1);</span><br><span class="line"><span class="keyword">return</span> arg0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试 Main<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans-auto.xml"</span>);</span><br><span class="line"><span class="comment">//测试 spEL</span></span><br><span class="line">User boy = (User) ctx.getBean(<span class="string">"boy"</span>);</span><br><span class="line">System.out.println(boy.getUserName() + <span class="string">":"</span> + boy.getWifeName());</span><br></pre></td></tr></table></figure></p><ul><li>2、Spring IOC 容器对 Bean 的生命周期进行管理的过程:</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通过构造器或工厂方法创建 <span class="keyword">Bean </span>实例。</span><br><span class="line">为 <span class="keyword">Bean </span>的属性设置值和对其他 <span class="keyword">Bean </span>的引用。</span><br><span class="line">将 <span class="keyword">Bean </span>实例传递给 <span class="keyword">Bean </span>后置处理器的 postProcessBeforeInitialization 方法。</span><br><span class="line">调用 <span class="keyword">Bean </span>的初始化方法。</span><br><span class="line">将 <span class="keyword">Bean </span>实例传递给 <span class="keyword">Bean </span>后置处理器的 postProcessAfterInitialization方法。</span><br><span class="line"><span class="keyword">Bean </span>可以使用了。</span><br><span class="line">当容器关闭时, 调用 <span class="keyword">Bean </span>的销毁方法。</span><br></pre></td></tr></table></figure><ul><li>3、工厂方法&amp;FactroyBean 方式配置 Bean</li></ul><p>beans-auto.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 6、通过工厂方法的方式来配置 bean --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 6-1. 通过静态工厂方法: 一个类中有一个静态方法, 可以返回一个类的实例(了解) --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在 class 中指定静态工厂方法的全类名, 在 factory-method 中指定静态工厂方法的方法名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dateFormat"</span> <span class="attr">class</span>=<span class="string">"java.text.DateFormat"</span> <span class="attr">factory-method</span>=<span class="string">"getDateInstance"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="comment">&lt;!-- 可以通过 constructor-arg 子节点为静态工厂方法指定参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 6-2. 实例工厂方法: 先需要创建工厂对象, 再调用工厂的非静态方法返回实例(了解) --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ①. 创建工厂对应的 bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleDateFormat"</span> <span class="attr">class</span>=<span class="string">"java.text.SimpleDateFormat"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"yyyy-MM-dd hh:mm:ss"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ②. 有实例工厂方法来创建 bean 实例 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- factory-bean 指向工厂 bean, factory-method 指定工厂方法(了解) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"datetime"</span> <span class="attr">factory-bean</span>=<span class="string">"simpleDateFormat"</span> <span class="attr">factory-method</span>=<span class="string">"parse"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通过 constructor-arg 执行调用工厂方法需要传入的参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"1990-12-12 12:12:12"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 7、配置通过 FactroyBean 的方式来创建 bean 的实例(了解) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.spring.ref.UserBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>测试 Main</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试工厂方法配置 Bean</span></span><br><span class="line"><span class="comment">//DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.FULL);</span></span><br><span class="line">DateFormat dateFormat = (DateFormat) ctx.getBean(<span class="string">"dateFormat"</span>);</span><br><span class="line">System.out.println(dateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line"></span><br><span class="line">Date date = (Date) ctx.getBean(<span class="string">"datetime"</span>);</span><br><span class="line">System.out.println(date);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试通过 FactroyBean 来配置 Bean</span></span><br><span class="line">User user = (User) ctx.getBean(<span class="string">"user"</span>);</span><br><span class="line">System.out.println(user);</span><br><span class="line"></span><br><span class="line">ctx.close();</span><br></pre></td></tr></table></figure><hr><h4 id="2-11、Spring4-x-新特性-泛型依赖注入"><a href="#2-11、Spring4-x-新特性-泛型依赖注入" class="headerlink" title="2-11、Spring4.x 新特性 泛型依赖注入"></a>2-11、Spring4.x 新特性 泛型依赖注入</h4><p><img src="https://i.loli.net/2019/03/25/5c98a7338adda.jpg" alt="泛型依赖注入"></p><hr><h4 id="2-12、整合多个配置文件"><a href="#2-12、整合多个配置文件" class="headerlink" title="2-12、整合多个配置文件"></a>2-12、整合多个配置文件</h4><p><img src="https://i.loli.net/2019/03/25/5c98a7340b6b6.jpg" alt="整合多个配置文件"></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&quot;1、IOC-amp-DI-概述&quot;&gt;&lt;a href=&quot;#1、IOC-amp-DI-概述&quot; class=&quot;headerlink&quot; title=&quot;1、IOC&amp;amp;DI 概述&quot;&gt;&lt;/a&gt;1、IOC&amp;amp;DI 概述&lt;/h3&gt;&lt;h4 id=&quot;
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-2--开发环境搭建</title>
    <link href="http://yoursite.com/2019/03/25/Spring-2--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/03/25/Spring-2--开发环境搭建/</id>
    <published>2019-03-25T07:33:39.279Z</published>
    <updated>2019-03-24T23:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h3 id="1、Spring-框架的核心jar-包"><a href="#1、Spring-框架的核心jar-包" class="headerlink" title="1、Spring 框架的核心jar 包"></a>1、Spring 框架的核心jar 包</h3><p><img src="https://github.com/ppjuice/xiaoshujiangTC/raw/master/小书匠/1548137955928.png" alt="Spring框架jar 包"><br>除此之外，还有其他一些 jar 包。</p><hr><h3 id="2、Spring-的-HelloWorld"><a href="#2、Spring-的-HelloWorld" class="headerlink" title="2、Spring 的 HelloWorld"></a>2、Spring 的 HelloWorld</h3><ul><li>1、引入jar 包</li><li>2、编写 com.ppjuice.helloworld.HelloWorld 类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ppjuice.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成员方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is hello...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空参构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3、配置 ApplicationContext .xml 文件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&quot;1、Spring-框架的核心jar-包&quot;&gt;&lt;a href=&quot;#1、Spring-框架的核心jar-包&quot; class=&quot;headerlink&quot; title=&quot;1、Spring 框架的核心jar 包&quot;&gt;&lt;/a&gt;1、Spring 框架的核心ja
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-1--什么是Spring？</title>
    <link href="http://yoursite.com/2019/03/25/Spring-1--%E4%BB%80%E4%B9%88%E6%98%AFSpring%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/03/25/Spring-1--什么是Spring？/</id>
    <published>2019-03-25T07:33:39.277Z</published>
    <updated>2019-03-24T23:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h3 id="1、什么是-Spring？"><a href="#1、什么是-Spring？" class="headerlink" title="1、什么是 Spring？"></a>1、什么是 Spring？</h3><ul><li>Spring 是一个 IOC(DI) 和 AOP 容器框架，开源框架。</li><li>轻量级：Spring 是非侵入性的 - 基于 Spring 开发的应用中的对象可以不依赖于 Spring 的 API。</li><li>依赖注入(DI — dependency injection、IOC)。</li><li>面向切面编程(AOP — aspect oriented programming)。</li><li>容器: Spring 是一个容器, 因为它包含并且管理应用对象的生命周期。</li><li>框架: Spring 实现了使用简单的组件配置组合成一个复杂的应用. 在 Spring 中可以使用 XML 和 Java 注解组合这些对象。</li><li>一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库 （实际上 Spring 自身也提供了展现层的 SpringMVC 和 持久层的 Spring JDBC）。</li></ul><hr><h3 id="2、如何学好-Spring？"><a href="#2、如何学好-Spring？" class="headerlink" title="2、如何学好 Spring？"></a>2、如何学好 Spring？</h3><ul><li>Spring核心是IoC容器，所以一定要透彻理解什么是IoC容器，以及如何配置及使用容器，其他所有技术都是基于容器实现的；</li><li>理解好IoC后，接下来是面向切面编程，首先还是明确概念，基本配置，最后是实现原理。</li><li>接下来就是数据库事务管理，其实Spring管理事务是通过面向切面编程实现的，所以基础很重要，IoC容器和面向切面编程搞定后，其余都是基于这俩东西的实现。</li></ul><hr><h3 id="3、Spring-基础"><a href="#3、Spring-基础" class="headerlink" title="3、Spring 基础"></a>3、Spring 基础</h3><h4 id="3-1、Spring-架构图"><a href="#3-1、Spring-架构图" class="headerlink" title="3-1、Spring 架构图"></a>3-1、Spring 架构图</h4><p><img src="https://github.com/ppjuice/xiaoshujiangTC/raw/master/小书匠/1548130458018.png" alt="Spring架构图"></p><hr><h4 id="3-2、各架构模块介绍"><a href="#3-2、各架构模块介绍" class="headerlink" title="3-2、各架构模块介绍"></a>3-2、各架构模块介绍</h4><ul><li><strong>1、核心容器：包括Core、Beans、Context、EL模块。</strong><ul><li><strong>Core模块</strong>：封装了框架依赖的最底层部分，包括资源访问、类型转换及一些常用工具类。</li><li><strong>Beans模块</strong>：提供了框架的基础部分，包括反转控制和依赖注入。其中Bean Factory是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程；所有应用程序对象及对象间关系由框架管理，从而真正把你从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由BeanFactory来维护。</li><li><strong>Context模块</strong>：以Core和Beans为基础，集成Beans模块功能并添加资源绑定、数据验证、国际化、Java EE支持、容器生命周期、事件传播等；核心接口是ApplicationContext。</li><li><strong>EL模块</strong>：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从Spring 容器获取Bean，它也支持列表投影、选择和一般的列表聚合等。</li></ul></li></ul><hr><ul><li><strong>2、AOP、Aspects模块</strong><ul><li><strong>AOP模块</strong>：Spring AOP模块提供了符合 AOP Alliance规范的面向方面的编程（aspect-oriented programming）实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中；这样各专其职，降低业务逻辑和通用功能的耦合。</li><li><strong>Aspects模块</strong>：提供了对AspectJ的集成，AspectJ提供了比Spring ASP更强大的功能。<br>数据访问/集成模块：该模块包括了JDBC、ORM、OXM、JMS和事务管理。</li></ul></li></ul><hr><ul><li><strong>3、data access/intergration 数据访问、数据整合模块</strong><ul><li><strong>事务模块</strong>：该模块用于Spring管理事务，只要是Spring管理对象都能得到Spring管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事物管理。</li><li><strong>JDBC模块</strong>：提供了一个JBDC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring管理事务的好处。</li><li><strong>ORM模块</strong>：提供与流行的“对象-关系”映射框架的无缝集成，包括Hibernate、JPA、Ibatiss等。而且可以使用Spring事务管理，无需额外控制事务。</li><li><strong>OXM模块</strong>：提供了一个对Object/XML映射实现，将java对象映射成XML数据，或者将XML数据映射成java对象，Object/XML映射实现包括JAXB、Castor、XMLBeans和XStream。</li><li><strong>JMS模块</strong>：用于JMS(Java Messaging Service)，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用JMS，JMS用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</li></ul></li></ul><hr><ul><li><strong>4、Web 模块</strong><ul><li><strong>Web/Remoting模块</strong>：Web/Remoting模块包含了Web、Web-Servlet、Web-Struts、Web-Porlet模块。</li><li><strong>Web模块</strong>：提供了基础的web功能。例如多文件上传、集成IoC容器、远程过程访问（RMI、Hessian、Burlap）以及Web Service支持，并提供一个RestTemplate类来提供方便的Restful services访问。</li><li><strong>Web-Servlet模块</strong>：提供了一个Spring MVC Web框架实现。Spring MVC框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的JSP标签，完全无缝与Spring其他技术协作。</li><li><strong>Web-Struts模块</strong>：提供了与Struts无缝集成，Struts1.x 和Struts2.x都支持。</li><li><strong>Test模块</strong>： Spring支持Junit和TestNG测试框架，而且还额外提供了一些基于Spring的测试功能，比如在测试Web框架时，模拟Http请求的功能。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&quot;1、什么是-Spring？&quot;&gt;&lt;a href=&quot;#1、什么是-Spring？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是 Spring？&quot;&gt;&lt;/a&gt;1、什么是 Spring？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Spring 
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub page 搭建个人博客</title>
    <link href="http://yoursite.com/2019/03/25/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo+%20github%20page%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/03/25/如何使用Hexo+ github page搭建博客？/</id>
    <published>2019-03-25T04:12:59.560Z</published>
    <updated>2019-03-25T05:43:23.033Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><ul><li><p>1、如何使用 github 搭建博客？<br>参考链接：</p><ul><li><a href="https://www.cnblogs.com/jackyroc/p/7681938.html" target="_blank" rel="noopener">https://www.cnblogs.com/jackyroc/p/7681938.html</a></li></ul></li><li><p>2、hexo 本地目录各文件以及文件夹的作用？</p><pre><code>主要看 _config.yml 文件。</code></pre></li><li>3、假如自己有多台设备，如何同步管理博客？<br> 参考链接： <ul><li><a href="https://juejin.im/post/5acf22e6f265da23994eeac9" target="_blank" rel="noopener">https://juejin.im/post/5acf22e6f265da23994eeac9</a></li></ul></li><li>4、hexo next 主题 Hexo-NexT配置超炫网页效果<pre><code>参考链接：</code></pre><ul><li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html</a></li><li><a href="https://juejin.im/post/5bcd2d395188255c3b7dc1db#heading-0" target="_blank" rel="noopener">https://juejin.im/post/5bcd2d395188255c3b7dc1db#heading-0</a></li></ul></li><li>5、hexo 如何发布文章？<ul><li><a href="https://www.jianshu.com/p/265b2c653e6f" target="_blank" rel="noopener">https://www.jianshu.com/p/265b2c653e6f</a></li><li><a href="https://www.zengyilun.com/HexoEditor/" target="_blank" rel="noopener">https://www.zengyilun.com/HexoEditor/</a></li><li><a href="https://www.cnblogs.com/xingyunblog/p/8681205.html" target="_blank" rel="noopener">https://www.cnblogs.com/xingyunblog/p/8681205.html</a></li></ul></li><li><p>6、个人定制？</p><pre><code>主题推荐：</code></pre><ul><li><a href="https://blog.csdn.net/qincidong/article/details/82415271" target="_blank" rel="noopener">https://blog.csdn.net/qincidong/article/details/82415271</a></li><li><a href="http://tengj.top/categories/hexo%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97/" target="_blank" rel="noopener">http://tengj.top/categories/hexo%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97/</a></li><li><a href="https://www.titanjun.top/" target="_blank" rel="noopener">https://www.titanjun.top/</a></li><li><p><a href="https://www.haomwei.com/" target="_blank" rel="noopener">https://www.haomwei.com/</a></p><p>主题的配置文件修改后可热部署，Hexo 的配置文件不可。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、如何使用 github 搭建博客？&lt;br&gt;参考链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/jackyroc/p/7681938.html&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>第3章-线性表</title>
    <link href="http://yoursite.com/2019/03/25/%E7%AC%AC3%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/03/25/第3章-线性表/</id>
    <published>2019-03-25T02:51:43.036Z</published>
    <updated>2019-03-24T18:50:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p><img src="https://i.loli.net/2019/03/25/5c983b29bd6f0.jpg" alt="线性表"></p><h3 id="1、线性表定义"><a href="#1、线性表定义" class="headerlink" title="1、线性表定义"></a>1、线性表定义</h3><p>零个或多个数据元素的有限序列。</p><p>1、第一元素无前驱、最后一个元素无后继。<br>2、每个元素有且仅有一个前驱、后继。<br>3、相同数据元素。</p><hr><h3 id="2、线性表的抽象数据类型"><a href="#2、线性表的抽象数据类型" class="headerlink" title="2、线性表的抽象数据类型"></a>2、线性表的抽象数据类型</h3><hr><h3 id="3、线性表的顺序存储结构（数组实现）"><a href="#3、线性表的顺序存储结构（数组实现）" class="headerlink" title="3、线性表的顺序存储结构（数组实现）"></a>3、线性表的顺序存储结构（数组实现）</h3><p>线性表的两种物理存储结构（顺序存储结构、链式存储结构）</p><ul><li>1、顺序存储结构：指的是用一段地址连续的存储单元依次存储线性表的数据元素。</li><li><p>2、插入</p></li><li><p>3、删除</p></li></ul><p>优点：<br>可以快速存取表中的任意元素值。<br>无需为表示表中元素之间的逻辑关系而增加额外的存储空间。</p><p>缺点：<br>插入和删除操作需要移动大量元素；<br>线性表长度发生变化时，难以确定存储长度。<br>造成存储空间的碎片。</p><hr><h3 id="4、线性表的链式存储结构"><a href="#4、线性表的链式存储结构" class="headerlink" title="4、线性表的链式存储结构"></a>4、线性表的链式存储结构</h3><p>链式存储结构：</p><h4 id="4-1、单链表"><a href="#4-1、单链表" class="headerlink" title="4-1、单链表"></a>4-1、单链表</h4><ul><li>1、为什么使用单链表？<br>数组实现的顺序存储在插入和删除操作时需要移动大量的元素，且存储空间的容量难以确定。</li><li>2、单链表的插入、删除、修改、查找<br>实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dataStruct.singleLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线性表（链表）--节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pengguozhen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年4月2日 上午11:41:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node head;<span class="comment">// 指向链表头节点的引用变量</span></span><br><span class="line"><span class="keyword">private</span> Node tail;<span class="comment">// 指向链表尾节点的引用变量</span></span><br><span class="line"><span class="keyword">int</span> size;<span class="comment">// 链表中当前总节点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;<span class="comment">// 生成链表对象是一个空表</span></span><br><span class="line">head = <span class="keyword">null</span>;</span><br><span class="line">tail = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;<span class="comment">// 返回链表的长度</span></span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>查询--指定位置的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getElement</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="comment">// 1、获取指定位置的元素</span></span><br><span class="line"><span class="keyword">return</span> findNodeByIndex(index).data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findNodeByIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="comment">// 查找 指定索引位置的节点</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"线性表索引越界"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span> &amp;&amp; head.next == <span class="keyword">null</span>) &#123;<span class="comment">// 如果要插入位置的前一个节点为头结点并且头结点的next 域为null，直接返回头结点。</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">Node current = head;<span class="comment">// 从头节点开始下移遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size &amp; current.next != <span class="keyword">null</span>; i++, current = current.next) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == index) &#123;</span><br><span class="line"><span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>查询--指定元素的位置(查找数据域存放的是element的节点位置)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findIndexByElement</span><span class="params">(T element)</span> </span>&#123;<span class="comment">// 2、查找 指定元素的位置(查找数据域存放的是element的节点位置)</span></span><br><span class="line">Node current = head;<span class="comment">// 从第一个节点开始查找对比数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size &amp; current.next != <span class="keyword">null</span>; i++, current = current.next) &#123;</span><br><span class="line"><span class="keyword">if</span> (current.data.equals(element))</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>插入--在指定位置之前插入一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment"> * 在java中有这么一条规则，声明在方法中的变量在使用时必须要初始化;全局变量如果不赋值会有默认值。</span></span><br><span class="line"><span class="comment"> * 例如：int size; 本例中 size 的初始值为 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, T element)</span> </span>&#123;<span class="comment">// 插入 在指定索引位置插入一个元素</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"线性表索引越界"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>)<span class="comment">// 如果链表为空，直接调用add方法</span></span><br><span class="line">&#123;</span><br><span class="line">add(element);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="comment">// 链表不为空时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>)<span class="comment">// 在链表头插入</span></span><br><span class="line">&#123;</span><br><span class="line">addAtHead(element);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node prev = findNodeByIndex(index - <span class="number">1</span>);<span class="comment">// 找到要插入位置的前一个节点</span></span><br><span class="line">prev.next = <span class="keyword">new</span> Node(element, prev.next);<span class="comment">// 插入后prev的next指向新节点，新节点的next指向原来prev的下一个节点</span></span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 尾插法 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T element)</span> </span>&#123;<span class="comment">// 插入 尾插法在每次在链表尾添加新节点</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">head = <span class="keyword">new</span> Node(element, <span class="keyword">null</span>);</span><br><span class="line">tail = head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(element, <span class="keyword">null</span>);</span><br><span class="line">tail.next = newNode;</span><br><span class="line">tail = newNode;</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 头插法 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(T element)</span> </span>&#123; <span class="comment">// 插入 头插法在链表头部加入新节点</span></span><br><span class="line"><span class="comment">// 在头部插入新节点，就是让新节点的next指向原来的head,让新节点作为链表的头节点</span></span><br><span class="line">head = <span class="keyword">new</span> Node(element, head);</span><br><span class="line"><span class="comment">// newNode.next = head;</span></span><br><span class="line"><span class="comment">// head = newNode;</span></span><br><span class="line"><span class="comment">// 如果插入之前是空链表</span></span><br><span class="line"><span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">tail = head;</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>删除--指定位置的节点 并返回删除节点中的元素值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">delete</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">Node deleteNode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"线性表索引越界"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>)<span class="comment">// 删除头节点</span></span><br><span class="line">&#123;</span><br><span class="line">deleteNode = head;</span><br><span class="line">head = head.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node prev = findNodeByIndex(index - <span class="number">1</span>);<span class="comment">// 获取要删除的节点的前一个节点</span></span><br><span class="line">deleteNode = prev.next;<span class="comment">// 要删除的节点就是prev的next指向的节点</span></span><br><span class="line">prev.next = deleteNode.next;<span class="comment">// 删除以后prev的next指向被删除节点之前所指向的next</span></span><br><span class="line"></span><br><span class="line">deleteNode.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> deleteNode.data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>删除--链表中最后一个元素  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> delete(size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>清除链表中所有的元素  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">head = <span class="keyword">null</span>;</span><br><span class="line">tail = <span class="keyword">null</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表的输出 重写toString方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"["</span>);<span class="comment">// 使用StringBuilder类</span></span><br><span class="line"><span class="keyword">for</span> (Node current = head; current != <span class="keyword">null</span>; current = current.next)<span class="comment">// 从head开始遍历</span></span><br><span class="line">&#123;</span><br><span class="line">sb.append(current.data.toString() + <span class="string">","</span>);<span class="comment">// 把节点的数据拼接起来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len = sb.length();</span><br><span class="line"><span class="keyword">return</span> sb.delete(len - <span class="number">1</span>, len).append(<span class="string">"]"</span>).toString();<span class="comment">// 把最后一个元素的，删除然后加上]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>判断链表是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>内部节点类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pengguozhen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年4月2日 下午12:10:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>// 节点类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> T data;<span class="comment">// 数据项</span></span><br><span class="line"><span class="keyword">private</span> Node next;<span class="comment">// 引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;<span class="comment">// 空参构造器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data, Node next)</span> </span>&#123;<span class="comment">// 初始化节点信息</span></span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dataStruct.singleLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">list.add(<span class="string">"aa"</span>);<span class="comment">// 链表头插入</span></span><br><span class="line">list.addAtHead(<span class="string">"cc"</span>);<span class="comment">// 链表尾插入</span></span><br><span class="line">list.insert(<span class="number">2</span>, <span class="string">"bb"</span>);<span class="comment">// 在指定任意位置插入</span></span><br><span class="line">System.out.println(list.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="4-2、静态链表"><a href="#4-2、静态链表" class="headerlink" title="4-2、静态链表"></a>4-2、静态链表</h4><ul><li>1、为什么使用静态链表？<br>为没有指针（引用）的编程语言提供链式存储结构实现的思想。</li></ul><h4 id="4-3、循环链表"><a href="#4-3、循环链表" class="headerlink" title="4-3、循环链表"></a>4-3、循环链表</h4><h4 id="4-4、双向链表"><a href="#4-4、双向链表" class="headerlink" title="4-4、双向链表"></a>4-4、双向链表</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/25/5c983b29bd6f0.jpg&quot; alt=&quot;线性表&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1、线性表定义&quot;&gt;&lt;a href=&quot;#1、线性表定义&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>第2章-算法</title>
    <link href="http://yoursite.com/2019/03/25/%E7%AC%AC2%E7%AB%A0-%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/25/第2章-算法/</id>
    <published>2019-03-25T02:51:43.028Z</published>
    <updated>2019-03-24T18:50:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>摘自大话数据结构</p><h3 id="1、算法和数据结构的关系"><a href="#1、算法和数据结构的关系" class="headerlink" title="1、算法和数据结构的关系"></a>1、算法和数据结构的关系</h3><ul><li>重要的数据结构就那么几种、只有配合上算法才能学习到数据结构的用处。</li><li>算法：解决特定问题的步骤描述，在计算机中表现为指令的有限序列，每个指令代表一种操作。</li></ul><hr><h3 id="2、算法的特性"><a href="#2、算法的特性" class="headerlink" title="2、算法的特性"></a>2、算法的特性</h3><ul><li><p>输入、输出<br>算法具有零个或多个输入、至少有一个输出。算法一定有输出、如果没有输出。算法没有意义，便不需要算法。输出形式可以是打印，也可以是返回一个或多个值。</p></li><li><p>有穷性<br>指算法不会无穷循环，而没有结果。</p></li><li>确定性<br>执行的每一步都必须确定，相同的输入只能有唯一的输出结果。</li><li>可行性<br>每一步都是可以执行的。</li></ul><hr><h3 id="3、算法设计的要求"><a href="#3、算法设计的要求" class="headerlink" title="3、算法设计的要求"></a>3、算法设计的要求</h3><p>好的算法：</p><ul><li>正确性</li><li>可读性</li><li>健壮性</li><li>高效率和低存储量</li></ul><hr><h3 id="4、算法效率的度量"><a href="#4、算法效率的度量" class="headerlink" title="4、算法效率的度量"></a>4、算法效率的度量</h3><p>时间复杂度（大O表示法）–渐进时间复杂度</p><p>时间复杂度：O（f（n））表示随问题规模n 的增长速度。是一个增长率。即时间复杂度表示随着输入大小 n 的增长，算法时间的增长速度（程序执行次数函数的增长率）；</p><p>一般情况下 ，随着 n 的增大 O（n）增长最慢的为最优算法。</p><hr><h3 id="5、渐进时间复杂度的计算"><a href="#5、渐进时间复杂度的计算" class="headerlink" title="5、渐进时间复杂度的计算"></a>5、渐进时间复杂度的计算</h3><h4 id="5-1、由执行次数T-n-推导-大O-T-n"><a href="#5-1、由执行次数T-n-推导-大O-T-n" class="headerlink" title="5-1、由执行次数T(n) 推导 大O(T(n) )"></a>5-1、由执行次数T(n) 推导 大O(T(n) )</h4><p>推导方法：</p><ul><li>1、计算出算法执行次数的函数T(n)。</li><li><p>2、常数项不影响函数的增长速度，c 代表常数。<br>  T(n)=c 时，T(n)&gt;&gt;O(n)=O(1)，<br>  T(n) !=c 时，将常数项省略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一个 Hello, World 的例子中 T(n) = <span class="number">2</span>，所以我们说那个函数(算法)的时间复杂度为 O(<span class="number">1</span>)。</span><br><span class="line">T(n) = n + <span class="number">29</span>，此时时间复杂度为 O(n)。</span><br></pre></td></tr></table></figure></li><li><p>3、函数高次项对于函数的增长速度影像是最大的，n<sup>3</sup>的增长速度是远超 n<sup>2</sup> 的，同时 n<sup>2</sup> 的增长速度是远超 n 的。 同时因为要求的精度不高，所以我们直接忽略低此项。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如</span><br><span class="line">T(n) = n^<span class="number">3</span> + n^<span class="number">2</span> + <span class="number">29</span>，此时时间复杂度为 O(n^<span class="number">3</span>)。</span><br></pre></td></tr></table></figure><ul><li>4、因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如</span><br><span class="line">T(n) = <span class="number">3</span>n^<span class="number">3</span>，此时时间复杂度为 O(n^<span class="number">3</span>)。</span><br></pre></td></tr></table></figure><p><strong>综合起来：如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。为了方便描述，下文称此为 大O推导法。</strong></p><h4 id="5-2、由算法分析出执行次数-T-n"><a href="#5-2、由算法分析出执行次数-T-n" class="headerlink" title="5-2、由算法分析出执行次数 T(n)"></a>5-2、由算法分析出执行次数 T(n)</h4><p><strong>由执行次数推导出 大O 并不困难，困难的是如何从算法中分析出 执行次数 T（n）。</strong><br><strong>基本策略：由内到外、从最深层分析。如果遇到函数调用，要深入函数进行分析。</strong><br>四个便利法则：</p><ul><li>1、对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个循环的时间复杂度为 O(n×m)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;         <span class="comment">// 循环次数为 n</span></span><br><span class="line">        printf(<span class="string">"Hello, World!\n"</span>);      <span class="comment">// 循环体时间复杂度为 O(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2、对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c…，则这个循环的时间复杂度为 O(n×a×b×c…)。分析的时候应该由里向外分析这些循环。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;         <span class="comment">// 循环次数为 n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;       <span class="comment">// 循环次数为 n</span></span><br><span class="line">            printf(<span class="string">"Hello, World!\n"</span>);      <span class="comment">// 循环体时间复杂度为 O(1)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3、对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一部分时间复杂度为 O(n^2)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            printf(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二部分时间复杂度为 O(n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        printf(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>4、对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一条路径时间复杂度为 O(n^2)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                printf(<span class="string">"输入数据大于等于零\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 第二条路径时间复杂度为 O(n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            printf(<span class="string">"输入数据小于零\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3、常见的-大O-时间复杂度。"><a href="#5-3、常见的-大O-时间复杂度。" class="headerlink" title="5-3、常见的 大O 时间复杂度。"></a>5-3、常见的 大O 时间复杂度。</h4><ul><li>1、常数阶<br>O（1）</li><li>2、线性阶<br>O（n）</li><li>3、对数阶<br>O（logn）</li><li>4、平方阶<br>O（n<sup>2</sup>）</li></ul><hr><h3 id="6、最坏时间与平均情况"><a href="#6、最坏时间与平均情况" class="headerlink" title="6、最坏时间与平均情况"></a>6、最坏时间与平均情况</h3><ul><li>1、最坏时间：最坏情况运行时间的一种保证，我们提到的时间都是最坏情况的运行时间。</li><li>2、平均情况：平均运行时间是最有意义的，它是期望的运行时间。（很难通过分析得到，一般通过数据实验后估算出来。）</li></ul><p>总结：对算法的分析：1、根据运行计算平均运行时间。2、分析最坏时间。<br>一般算法分析时指的是最坏运行时间。</p><hr><h3 id="7、算法空间复杂度"><a href="#7、算法空间复杂度" class="headerlink" title="7、算法空间复杂度"></a>7、算法空间复杂度</h3><p>使用存储空间来换取运行时间</p><hr><h3 id="8、时间复杂度计算–练习"><a href="#8、时间复杂度计算–练习" class="headerlink" title="8、时间复杂度计算–练习"></a>8、时间复杂度计算–练习</h3><ul><li>1、基础题<br>求该方法的时间复杂度<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            printf(<span class="string">"Hello World\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>参考答案：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当 i = 0 时，内循环执行 n 次运算，当 i = 1 时，内循环执行 n - 1 次运算……当 i = n - 1 时，内循环执行 1 次运算。</span><br><span class="line">所以，执行次数 T(n) = n + (n - 1) + (n - 2)……+ 1 = n(n + 1) / 2 = n^2 / 2 + n / 2。</span><br><span class="line">根据上文说的 大O推导法 可以知道，此时时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">等差数列 </span><br><span class="line">通项公式：an=a1+(n-1)*d。</span><br><span class="line">求和公式：Sn=a1*n+[n*(n-1)*d]/2。</span><br></pre></td></tr></table></figure><ul><li>2、进阶题<br>求该方法的时间复杂度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">        printf(<span class="string">"%i\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考答案：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假设循环次数为 t，则循环条件满足 2^t <span class="tag">&lt; <span class="attr">n</span>。</span></span><br><span class="line"><span class="tag">可以得出，执行次数<span class="attr">t</span> = <span class="string">log(2)(n)，即</span> <span class="attr">T</span>(<span class="attr">n</span>) = <span class="string">log(2)(n)，可见时间复杂度为</span> <span class="attr">O</span>(<span class="attr">log</span>(<span class="attr">2</span>)(<span class="attr">n</span>))，即 <span class="attr">O</span>(<span class="attr">log</span> <span class="attr">n</span>)。</span></span><br></pre></td></tr></table></figure><ul><li>3、再次进阶<br>求该方法的时间复杂度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> aFunc(n - <span class="number">1</span>) + aFunc(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考答案：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">显然运行次数，T(0) = T(1) = 1，同时 T(n) = T(n - 1) + T(n - 2) + 1，这里的 1 是其中的加法算一次执行。</span><br><span class="line">显然 T(n) = T(n - 1) + T(n - 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n &gt;= 1 时 T(n) <span class="tag">&lt; (<span class="attr">5</span>/<span class="attr">3</span>)^<span class="attr">n</span>，同时当 <span class="attr">n</span> &gt;</span> 4 时 T(n) &gt;= (3/2)^n。</span><br><span class="line">所以该方法的时间复杂度可以表示为 O((5/3)^n)，简化后为 O(2^n)。</span><br><span class="line">可见这个方法所需的运行时间是以指数的速度增长的。如果大家感兴趣，可以试下分别用 1，10，100 的输入大小来测试下算法的运行时间，相信大家会感受到时间复杂度的无穷魅力。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;摘自大话数据结构&lt;/p&gt;
&lt;h3 id=&quot;1、算法和数据结构的关系&quot;&gt;&lt;a href=&quot;#1、算法和数据结构的关系&quot; class=&quot;headerlink&quot; title=&quot;1、算法和数据结构的关系&quot;&gt;&lt;/a&gt;1、算法和数据结构的关系&lt;/h3&gt;&lt;ul&gt;
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>第1章-数据结构绪论</title>
    <link href="http://yoursite.com/2019/03/25/%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/"/>
    <id>http://yoursite.com/2019/03/25/第1章-数据结构绪论/</id>
    <published>2019-03-25T02:51:43.021Z</published>
    <updated>2019-03-24T18:50:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]<br><strong>该笔记摘抄于 《大话数据结构》<br>工作中所需要的栈、队列、链表、散列表等结构；查找、排序等算法在开发语言的工具包中都有完美实现，为什么还要学习数据结构弄懂其算法实现的原理？</strong></p><h3 id="1、数据结构起源"><a href="#1、数据结构起源" class="headerlink" title="1、数据结构起源"></a>1、数据结构起源</h3><ul><li><p>从计算机是用来进行数据计算的到现实中的问题需要一些科学有效的手段（表、树、图等数据结构）才能处理。</p></li><li><p>数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。<br>注：<code>这句话应该意思是，数据结构不是研究数值和数值计算的，而是研究对象（对象不止是数值，也可能是类对象或者其他），研究这些对象之间的关系（比如有什么共同点，比如顺序如何），以及操作（比如排序，插入等）</code>。</p></li><li><p>程序设计的实质是对确定的问题选择一种好的结构、加上设计一种好的算法。<strong>即程序设计=数据结构+算法。</strong></p></li></ul><hr><h3 id="2、基本概念和术语"><a href="#2、基本概念和术语" class="headerlink" title="2、基本概念和术语"></a>2、基本概念和术语</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据结构基本概念</span></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数据 – 程序的操作对象，用于描述客观事物</span></span><br><span class="line"><span class="comment">数据的特点：</span></span><br><span class="line"><span class="comment">可以输入到计算机</span></span><br><span class="line"><span class="comment">可以被计算机程序处理</span></span><br><span class="line"><span class="comment">数据是一个抽象的概念，将其进行分类后得到程序设计语言中的类型。如：int，float，char等等</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数据项：一个数据元素由若干数据项组成</span></span><br><span class="line"><span class="comment">数据元素：组成数据对象的基本单位</span></span><br><span class="line"><span class="comment">数据对象：性质相同的数据元素的集合（类似于数组一般）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数据元素之间不是独立的，存在特定的关系，这些关系即结构</span></span><br><span class="line"><span class="comment">数据结构指数据对象中数据元素之间的关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个结构体类型</span></span><br><span class="line">struct Teacher   <span class="comment">//一种数据类型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>    name[<span class="number">32</span>];<span class="comment">//数据项</span></span><br><span class="line">    <span class="keyword">char</span>    tile[<span class="number">32</span>];<span class="comment">//数据项</span></span><br><span class="line">    <span class="keyword">int</span>        age;<span class="comment">//数据项</span></span><br><span class="line">    <span class="keyword">char</span>    addr[<span class="number">128</span>];<span class="comment">//数据项</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    struct Teacher t1; <span class="comment">//数据元素</span></span><br><span class="line">    struct Teacher tArray[<span class="number">30</span>]; <span class="comment">//数据对象</span></span><br><span class="line">    memset(&amp;t1, <span class="number">0</span>, sizeof(t1));</span><br><span class="line"></span><br><span class="line">    strcpy(t1.name, <span class="string">"name"</span>); <span class="comment">//数据项</span></span><br><span class="line">    strcpy(t1.addr, <span class="string">"addr"</span>); <span class="comment">//数据项</span></span><br><span class="line">    strcpy(t1.tile, <span class="string">"addr"</span>); <span class="comment">//数据项</span></span><br><span class="line">    t1.age = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3、逻辑结构与物理结构"><a href="#3、逻辑结构与物理结构" class="headerlink" title="3、逻辑结构与物理结构"></a>3、逻辑结构与物理结构</h3><p>数据结构分为逻辑结构与物理结构</p><h4 id="3-1、逻辑结构"><a href="#3-1、逻辑结构" class="headerlink" title="3-1、逻辑结构"></a>3-1、逻辑结构</h4><p><strong>是指数据对象中数据元素之间的关系。</strong><br>分为四种。</p><pre><code>- 集合结构</code></pre><p><img src="https://www.github.com/pengguozhen/xiaoshujiangTC/raw/master/小书匠/1550666857719.png" alt="集合"></p><pre><code>- 线性结构</code></pre><p><img src="https://www.github.com/pengguozhen/xiaoshujiangTC/raw/master/小书匠/1550666942223.png" alt="线性结构"></p><pre><code>- 树</code></pre><p><img src="https://www.github.com/pengguozhen/xiaoshujiangTC/raw/master/小书匠/1550666972834.png" alt="树形结构"></p><pre><code>- 图</code></pre><p><img src="https://www.github.com/pengguozhen/xiaoshujiangTC/raw/master/小书匠/1550667025595.png" alt="图形结构"></p><h4 id="3-2、物理结构（存储结构）"><a href="#3-2、物理结构（存储结构）" class="headerlink" title="3-2、物理结构（存储结构）"></a>3-2、物理结构（存储结构）</h4><p>数据的逻辑结构在计算机中的存储形式。实际上是指如何把数据元素存储到计算机存储器中的</p><p><strong>数据元素的存储结构形式有两种</strong>：<br>    顺序存储结构：如数组<br>    链式存储结构：如链表，是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以不是连续的。</p><p>注：逻辑结构是面向问题的、物理结构是面向计算机的，基本的目标就是将数据及其逻辑关系存储到计算机的内存中。</p><h3 id="4、抽象数据类型"><a href="#4、抽象数据类型" class="headerlink" title="4、抽象数据类型"></a>4、抽象数据类型</h3><h4 id="4-1、数据类型"><a href="#4-1、数据类型" class="headerlink" title="4-1、数据类型"></a>4-1、数据类型</h4><p>计算机需要对数据进行分类，就分出来很多数据的类型。比如 int，float 等。</p><h4 id="4-2、抽象数据类型"><a href="#4-2、抽象数据类型" class="headerlink" title="4-2、抽象数据类型"></a>4-2、抽象数据类型</h4><ul><li>1、为什么需要抽象数据类型？<br>无论什么计算机、什么语言都会面临类似的整数运算，我们可以考虑将其抽象出来。抽象是抽取出事物具有的普遍性本质，是对事物的一个概括，是一种思考问题的方式。</li><li>2、定义<br>抽象数据类型（ADT）是指一个数学模型及定义在该模型上的一组操作。它仅取决于其逻辑特征，而与计算机内部如何表示和实现无关。比如刚才说得整型，各个计算机，不管大型机、小型机、PC、平板电脑甚至智能手机，都有“整型”类型，也需要整形运算，那么整型其实就是一个抽象数据类型。</li></ul><p>Java 中 接本数据类型、引用类型</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;br&gt;&lt;strong&gt;该笔记摘抄于 《大话数据结构》&lt;br&gt;工作中所需要的栈、队列、链表、散列表等结构；查找、排序等算法在开发语言的工具包中都有完美实现，为什么还要学习数据结构弄懂其算法实现的原理？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1、数据结构起源&quot;&gt;
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Hexo</title>
    <link href="http://yoursite.com/2019/02/14/hello-world/"/>
    <id>http://yoursite.com/2019/02/14/hello-world/</id>
    <published>2019-02-14T09:09:29.792Z</published>
    <updated>2019-03-25T04:12:46.423Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
