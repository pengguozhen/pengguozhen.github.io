<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ta的笑很甜</title>
  
  <subtitle>你好</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://pengguozhen.github.io/"/>
  <updated>2019-10-15T06:26:52.768Z</updated>
  <id>http://pengguozhen.github.io/</id>
  
  <author>
    <name>Ta 的笑很甜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Maven使用手册</title>
    <link href="http://pengguozhen.github.io/Maven%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html"/>
    <id>http://pengguozhen.github.io/Maven使用手册.html</id>
    <published>2019-10-15T06:26:52.767Z</published>
    <updated>2019-10-15T06:26:52.768Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]<br><strong>Maven</strong> </p><p><strong>导言：生产环境下开发不再是一个项目一个工程，而是每一个模块创建一个工程，而多个模块整合在一起就需要使用到像 Maven 这样的构建工具。</strong> </p><hr><h5 id="一、为什么使用Maven-（Why）"><a href="#一、为什么使用Maven-（Why）" class="headerlink" title="一、为什么使用Maven?（Why）"></a>一、为什么使用Maven?（Why）</h5><h6 id="1-1、真的需要吗？"><a href="#1-1、真的需要吗？" class="headerlink" title="1.1、真的需要吗？"></a>1.1、真的需要吗？</h6><blockquote><p>1、Maven 是干什么用的？这是很多同学在刚开始接触 Maven 时最大的问题。之所以会提出这个问题，是因为即使不使用 Maven 我们仍然可以进行 B/S 结构项目的开发。从表述层、业务逻辑层到持久化层再到数据库都有成熟的解决方案——不使用 Maven 我们一样可以开发项目啊？ </p></blockquote><p> <img src="https://i.loli.net/2019/05/16/5cdd0f529ad3d24829.jpg" alt="分层"></p><blockquote><p>2、这里给大家纠正一个误区，Maven 并不是直接用来辅助编码的，它战斗的岗位并不是以上各层。所以我们有必要通过企业开发中的实际需求来看一看哪些方面是我们现有技术的不足。</p></blockquote><h6 id="1-2、究竟为什么？"><a href="#1-2、究竟为什么？" class="headerlink" title="1.2、究竟为什么？"></a>1.2、究竟为什么？</h6><p>为什么要使用 Maven？它能帮助我们解决什么问题？ </p><blockquote><p>①、添加第三方 jar 包<br>在今天的 JavaEE 开发领域，有大量的第三方框架和工具可以供我们使用。要使用这些 jar 包最简单的方法就是复制粘贴到 WEB-INF/lib 目录下。但是这会导致每次创建一个新的工程就需要将 jar 包重复复制到 lib 目录下，从而造成工作区中存在大量重复的文件，让我们的工程显得很臃肿。<br>而使用 Maven 后每个 jar 包本身只在本地仓库中保存一份，需要 jar 包的工程只需要以坐标的方式简单的引用一下就可以了。不仅极大的节约了存储空间，让项目更轻巧，更避免了重复文件太多而造成的混乱。</p></blockquote><blockquote><p>②、jar 包之间的依赖关系<br>jar 包往往不是孤立存在的，很多 jar 包都需要在其他 jar 包的支持下才能够正常工作，我们称之为 jar 包之间的依赖关系。最典型的例子是：commons-fileupload-1.3.jar 依赖于 commons-io-2.0.1.jar，如果没有 IO 包，FileUpload 包就不能正常工作。<br>那么问题来了，你知道你所使用的所有 jar 包的依赖关系吗？当你拿到一个新的从未使用过的 jar 包，你如何得知他需要哪些 jar 包的支持呢？如果不了解这个情况，导入的 jar 包不够，那么现有的程序将不能正常工作。再进一步，当你的项目中需要用到上百个 jar 包时，你还会人为的，手工的逐一确认它们依赖的其他 jar 包吗？这简直是不可想象的。<br>而引入 Maven 后，Maven 就可以替我们自动的将当前 jar 包所依赖的其他所有 jar 包全部导入进来，无需人工参与，节约了我们大量的时间和精力。用实际例子来说明就是：通过 Maven 导入 commons-fileupload-1.3.jar 后，commons-io-2.0.1.jar 会被自动导入，程序员不必了解这个依赖关系。  </p></blockquote><blockquote><p>③、获取第三方 jar 包<br>JavaEE 开发中需要使用到的 jar 包种类繁多，几乎每个 jar 包在其本身的官网上的获取方式都不尽相同。为了查找一个 jar 包找遍互联网，身心俱疲，没有经历过的人或许体会不到这种折磨。不仅如此，费劲心血找的 jar 包里有的时候并没有你需要的那个类，又或者又同名的类没有你要的方法——以不规范的方式获取的 jar 包也往往是不规范的。<br>使用 Maven 我们可以享受到一个完全统一规范的 jar 包管理体系。你只需要在你的项目中以坐标的方式依赖一个 jar 包，Maven 就会自动从中央仓库进行下载，并同时下载这个 jar 包所依赖的其他 jar 包 ——规范、完整、准确！一次性解决所有问题！<br>Tips：在这里我们顺便说一下，统一的规范几乎可以说成是程序员的最高信仰。如果没有统一的规范，就意味着每个具体的技术都各自为政，需要以诸多不同的特殊的方式加入到项目中；好不容易加入进来还会和其他技术格格不入，最终受苦的是我们。而任何一个领域的统一规范都能够极大的降低程序员的工作难度，减少工作量。例如：USB 接口可以外接各种设备，如果每个设备都有自己独特的接口，那么不仅制造商需要维护各个接口的设计方案，使用者也需要详细了解每个设备对应的接口，无疑是非常繁琐的。 </p></blockquote><blockquote><p>④、将项目拆分成多个工程模块<br>随着 JavaEE 项目的规模越来越庞大，开发团队的规模也与日俱增。一个项目上千人的团队持续开发很多年对于 JavaEE 项目来说再正常不过。那么我们想象一下：几百上千的人开发的项目是同一个 Web 工程。那么架构师、项目经理该如何划分项目的模块、如何分工呢？这么大的项目已经不可能通过 package 结构来划分模块，必须将项目拆分成多个工程协同开发。多个模块工程中有的是 Java 工程，有的是 Web 工程。<br>那么工程拆分后又如何进行互相调用和访问呢？这就需要用到 Maven 的依赖管理机制。大家请看我们的 Survey 调查项目拆分的情况：<br>上层模块依赖下层，所以下层模块中定义的 API 都可以为上层所调用和访问。</p></blockquote><hr><h5 id="二、什么是-Maven-What"><a href="#二、什么是-Maven-What" class="headerlink" title="二、什么是 Maven (What)?"></a>二、什么是 Maven (What)?</h5><h6 id="2-1、Maven-简介"><a href="#2-1、Maven-简介" class="headerlink" title="2.1、Maven 简介"></a>2.1、Maven 简介</h6><blockquote><p>1、简介：Maven 是 Apache 软件基金会组织维护的一款自动化构建工具，专注服务于 Java 平台的项目构建和依赖管理。Maven 这个单词的本意是：专家，内行。读音是[‘meɪv(ə)n]或[‘mevn]。</p></blockquote><h6 id="2-2、什么是构建"><a href="#2-2、什么是构建" class="headerlink" title="2.2、什么是构建"></a>2.2、什么是构建</h6><blockquote><p>1、构建：构建并不是创建，创建一个工程并不等于构建一个项目。要了解构建的含义我们应该由浅入深的从以下三个层面来看： </p></blockquote><blockquote><p>①、纯 Java 代码<br>大家都知道，我们 Java 是一门编译型语言，.java 扩展名的源文件需要编译成.class 扩展名的字节码文件才能够执行。所以编写任何 Java 代码想要执行的话就必须经过编译得到对应的.class 文件。 </p></blockquote><blockquote><p>②、Web 工程<br>当我们需要通过浏览器访问 Java 程序时就必须将包含 Java 程序的 Web 工程编译的结果“拿”到服务器上的指定目录下，并启动服务器才行。这个“拿”的过程我们叫<strong>部署</strong>。<br>我们可以将未编译的 Web 工程比喻为一只生的鸡，编译好的 Web 工程是一只煮熟的鸡，编译部署的过程就是将鸡炖熟。 </p></blockquote><p>Web 工程和其编译结果的目录结构对比见下图： </p><p><img src="https://i.loli.net/2019/05/16/5cdd0fa574c9841603.jpg" alt="编译目录与web目录对比"></p><blockquote><p>③、实际项目<br>在实际项目中整合第三方框架，Web 工程中除了 Java 程序和 JSP 页面、图片等静态资源之外，还包括第三方框架的 jar 包以及各种各样的配置文件。所有这些资源都必须按照正确的目录结构部署到服务器上，项目才可以运行。<br>所以综上所述：<strong>构建就是以我们编写的 Java 代码、框架配置文件、国际化等其他资源文件、JSP 页面和图片等静态资源作为“原材料”，去“生产”出一个可以运行的项目的过程。</strong><br>那么项目构建的全过程中都包含哪些环节呢？ </p></blockquote><h6 id="2-3、-构建过程的几个主要环节"><a href="#2-3、-构建过程的几个主要环节" class="headerlink" title="2.3、 构建过程的几个主要环节"></a>2.3、 构建过程的几个主要环节</h6><blockquote><ul><li>①、清理：删除以前的编译结果，为重新编译做好准备。 </li><li>②、编译：将 Java 源程序编译为字节码文件。 </li><li>③、测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。 </li><li>④、报告：在每一次测试后以标准的格式记录和展示测试结果。 </li><li>⑤、打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web 工程对应 war 包。 </li><li>⑥、安装：在 Maven 环境下特指将打包的结果——jar 包或 war 包安装到本地仓库中。 </li><li>⑦、部署：将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。 </li></ul></blockquote><h6 id="2-4-、自动化构建"><a href="#2-4-、自动化构建" class="headerlink" title="2.4 、自动化构建"></a>2.4 、自动化构建</h6><blockquote><p>1、情景描述：其实上述环节我们在 Eclipse 中都可以找到对应的操作，只是不太标准。那么既然 IDE 已经可以进行构建了我们为什么还要使用 Maven 这样的构建工具呢？我们来看一个小故事：这是阳光明媚的一天。托马斯向往常一样早早的来到了公司，冲好一杯咖啡，进入了自己的邮箱——很不幸，QA 小组发来了一封邮件，报告了他昨天提交的模块的测试结果——有 BUG。“好吧，反正也不是第一次”，托马斯摇摇头，进入 IDE，运行自己的程序，编译、打包、部署到服务器上，然后按照邮件中的操作路径进行测试。“嗯，没错，这个地方确实有问题”，托马斯说道。于是托马斯开始尝试修复这个 BUG，当他差不多有眉目的时候已经到了午饭时间。<br>下午继续工作。BUG 很快被修正了，接着托马斯对模块重新进行了编译、打包、部署，测试之后确认没有问题了，回复了 QA 小组的邮件。<br>一天就这样过去了，明媚的阳光化作了美丽的晚霞，托马斯却觉得生活并不像晚霞那样美好啊。<br>让我们来梳理一下托马斯这一天中的工作内容 :</p></blockquote><p> <img src="https://i.loli.net/2019/05/16/5cdd0fe29a92645589.jpg" alt="托马斯1"></p><blockquote><p>2、问题：从中我们发现，托马斯的很大一部分时间花在了“编译、打包、部署、测试”这些程式化的工作上面，而真正需要由“人”的智慧实现的分析问题和编码却只占了很少一部分。<br>能否将这些程式化的工作交给机器自动完成呢？——当然可以！这就是自动化构建 ？</p></blockquote><p><img src="https://i.loli.net/2019/05/16/5cdd1001629fa48188.jpg" alt="托马斯2"></p><p> <img src="https://i.loli.net/2019/05/16/5cdd10250fb8049283.jpg" alt="托马斯3"></p><blockquote><p>3、Maven 的作用：此时 Maven 的意义就体现出来了，它可以自动的从构建过程的起点一直执行到终点： </p></blockquote><p><img src="https://i.loli.net/2019/05/16/5cdd103ba7f7741267.jpg" alt="maven"></p><h6 id="2-5-Maven-核心概念"><a href="#2-5-Maven-核心概念" class="headerlink" title="2.5 Maven 核心概念"></a>2.5 Maven 核心概念</h6><blockquote><p>1、Maven 的几大核心概念：Maven 能够实现自动化构建是和它的内部原理分不开的，这里我们从 Maven 的九个核心概念入手，看看 Maven 是如何实现自动化构建的 。</p><ul><li>①、POM </li><li>②、约定的目录结构 </li><li>③、坐标 </li><li>④、依赖管理 </li><li>⑤、仓库管理 </li><li>⑥、生命周期 </li><li>⑦、插件和目标 </li><li>⑧、继承 </li><li>⑨、聚合 </li></ul></blockquote><hr><h5 id="三、How-如何使用-Maven"><a href="#三、How-如何使用-Maven" class="headerlink" title="三、How? 如何使用 Maven"></a>三、How? 如何使用 Maven</h5><blockquote><p>Maven 的核心程序中仅仅定义了抽象的生命周期，而具体的操作则是由 Maven 的插件来完成的。可是Maven 的插件并不包含在 Maven 的核心程序中，在首次使用时需要联网下载。<br>下载得到的插件会被保存到本地仓库中。本地仓库默认的位置是：~.m2\repository。<br>如果不能联网可以使用我们提供的 RepMaven.zip 解压得到。</p></blockquote><h6 id="3-2、约定的目录结构"><a href="#3-2、约定的目录结构" class="headerlink" title="3.2、约定的目录结构"></a>3.2、约定的目录结构</h6><blockquote><p>1、约定优于配置：约定的目录结构对于 Maven 实现自动化构建而言是必不可少的一环，就拿自动编译来说，Maven 必须能找到 Java 源文件，下一步才能编译，而编译之后也必须有一个准确的位置保持编译得到的字节码文件。<br>我们在开发中如果需要让第三方工具或框架知道我们自己创建的资源在哪，那么基本上就是两种方式： </p><ul><li>①通过配置的形式明确告诉它 。</li><li>②基于第三方工具或框架的约定 。<br>Maven 对工程目录结构的要求就属于后面的一种。<br><img src="https://i.loli.net/2019/05/16/5cdd105f1541493261.jpg" alt="Maven约定目录"></li></ul></blockquote><blockquote><p>2、约定目录详细说明：</p></blockquote><table><thead><tr><th>目录</th><th>目的</th></tr></thead><tbody><tr><td>${basedir}</td><td>存放pom.xml和所有的子目录</td></tr><tr><td>${basedir}/src/main/java</td><td>项目的java源代码</td></tr><tr><td>${basedir}/src/main/resources</td><td>项目的资源，比如说property文件，springmvc.xml</td></tr><tr><td>${basedir}/src/test/java</td><td>项目的测试类，比如说Junit代码</td></tr><tr><td>${basedir}/src/test/resources</td><td>测试用的资源</td></tr><tr><td>${basedir}/src/main/webapp/WEB-INF</td><td>web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面</td></tr><tr><td>${basedir}/target</td><td>打包输出目录</td></tr><tr><td>${basedir}/target/classes</td><td>编译输出目录</td></tr><tr><td>${basedir}/target/test-classes</td><td>测试编译输出目录</td></tr><tr><td>Test.java</td><td>Maven只会自动运行符合该命名规则的测试类</td></tr><tr><td>~/.m2/repository</td><td>Maven默认的本地仓库目录位置</td></tr></tbody></table><blockquote><p>3、总结：现在 JavaEE 开发领域普遍认同一个观点：约定&gt;配置&gt;编码。意思就是能用配置解决的问题就不编码，能基于约定的就不进行配置。而 Maven 正是因为指定了特定文件保存的目录才能够对我们的 Java 工程进行自动化构建。 </p></blockquote><hr><h5 id="四、POM"><a href="#四、POM" class="headerlink" title="四、POM"></a>四、POM</h5><blockquote><p>1、POM 定义：Project Object Model：项目对象模型。将 Java 工程的相关信息封装为对象作为便于操作和管理的模型。 Maven 工程的核心配置。可以说学习 Maven 就是学习 pom.xml 文件中的配置。 </p></blockquote><h6 id="4-1、坐标"><a href="#4-1、坐标" class="headerlink" title="4-1、坐标"></a>4-1、坐标</h6><blockquote><ul><li>1、几何中的坐标<br>[1]、在一个平面中使用 x、y 两个向量可以唯一的确定平面中的一个点。<br>[2]、在空间中使用 x、y、z 三个向量可以唯一的确定空间中的一个点。 </li></ul></blockquote><blockquote><ul><li>2、Maven 的坐标<br>使用如下三个向量在 Maven 的仓库中唯一的确定一个 Maven 工程。<br>[1]、groupid：公司或组织的域名倒序+当前项目名称<br>[2]、artifactId：当前项目的模块名称<br>[3]、version：当前模块的版本 </li></ul></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>3、如何通过坐标到仓库中查找 jar 包？<br>[1]、将 gav 三个向量连起来<br>com.atguigu.maven+Hello+0.0.1-SNAPSHOT<br>[2]、以连起来的字符串作为目录结构到仓库中查找<br>com/atguigu/maven/Hello/0.0.1-SNAPSHOT/Hello-0.0.1-SNAPSHOT.jar<br><strong>※注意：我们自己的 Maven 工程必须执行安装操作才会进入仓库。安装的命令是：mvn install</strong> </li></ul></blockquote><hr><h5 id="五、依赖"><a href="#五、依赖" class="headerlink" title="五、依赖"></a>五、依赖</h5><p>Maven 中最关键的部分，我们使用 Maven 最主要的就是使用它的依赖管理功能。要理解和掌握 Maven 的依赖管理，我们只需要解决一下几个问题： </p><h6 id="5-1、依赖的目的是什么"><a href="#5-1、依赖的目的是什么" class="headerlink" title="5-1、依赖的目的是什么"></a>5-1、依赖的目的是什么</h6><blockquote><p>1、依赖目的：当 A jar 包用到了 B jar包中的某些类时，A 就对 B 产生了依赖，这是概念上的描述。<br>那么如何在项目中以依赖的方式引入一个我们需要的 jar 包呢？答案非常简单，就是使用 dependency 标签指定被依赖 jar 包的坐标就可以了。 </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="5-2、依赖的范围"><a href="#5-2、依赖的范围" class="headerlink" title="5-2、依赖的范围"></a>5-2、依赖的范围</h6><blockquote><p>1、依赖的作用范围：大家注意到上面的依赖信息中除了目标 jar 包的坐标还有一个 scope 设置，这是依赖的范围。依赖的范围有几个可选值，我们用得到的是：compile、test、provided 三个。 （compile（主程序、测试程序、参与部署）&gt;provided（主程序、测试程序）&gt;test（测试程序））。</p><ul><li>[1]、从项目结构角度理解 compile 和 test 的区别<br><img src="https://i.loli.net/2019/05/16/5cdd108b2f89492045.jpg" alt="依赖范围"><br>结合具体例子：对于 HelloFriend 来说，Hello 就是服务于主程序的，junit 是服务于测试程序的。<br>HelloFriend 主程序需要 Hello 是非常明显的，测试程序由于要调用主程序所以也需要 Hello，所以 compile 范围依赖对主程序和测试程序都应该有效。<br>HelloFriend 的测试程序部分需要 junit 也是非常明显的，而主程序是不需要的，所以 test 范围依赖仅仅对于主程序有效。 </li></ul></blockquote><blockquote><ul><li>[2]、从开发和运行这两个不同阶段理解 compile 和 provided 的区别<br><img src="https://i.loli.net/2019/05/16/5cdd10a7296e568065.jpg" alt="enter description here"></li></ul></blockquote><blockquote><ul><li>[3]、有效性总结 :</li></ul></blockquote><table><thead><tr><th></th><th>compile</th><th>test</th><th>provided</th></tr></thead><tbody><tr><td>主程序</td><td>√</td><td>×</td><td>√</td></tr><tr><td>测试程序</td><td>√</td><td>√</td><td>√</td></tr><tr><td>参与部署</td><td>√</td><td>×</td><td>×</td></tr></tbody></table><h6 id="5-3、依赖的传递性"><a href="#5-3、依赖的传递性" class="headerlink" title="5-3、依赖的传递性"></a>5-3、依赖的传递性</h6><blockquote><p>1、依赖的传递：A 依赖 B，B 依赖 C，A 能否使用C呢？那要看 B 依赖 C 的范围是不是 compile，如果是则可用，否则不可用。 </p></blockquote><p><img src="https://i.loli.net/2019/05/14/5cda39cb852fe88049.jpg" alt="依赖的传递性"></p><h6 id="5-4、依赖的排除"><a href="#5-4、依赖的排除" class="headerlink" title="5-4、依赖的排除"></a>5-4、依赖的排除</h6><blockquote><p>1、依赖的排除：如果我们在当前工程中引入了一个依赖是 A，而 A 又依赖了 B，那么 Maven 会自动将 A 依赖的 B 引入当前工程，但是个别情况下 B 有可能是一个不稳定版，或对当前工程有不良影响。这时我们可以在引入 A 的时候将 B 排除。 </p></blockquote><blockquote><p>[1]、情景举例<br> <img src="https://i.loli.net/2019/05/16/5cdd10dda179412292.jpg" alt="依赖的排除"></p></blockquote><blockquote><p>[2]、配置方式 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;HelloFriend&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; </span><br><span class="line">&lt;type&gt;jar&lt;/type&gt; </span><br><span class="line">&lt;scope&gt;compile&lt;/scope&gt; </span><br><span class="line">&lt;exclusions&gt; </span><br><span class="line">&lt;exclusion&gt; </span><br><span class="line">&lt;groupId&gt;commons-logging&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;commons-logging&lt;/artifactId&gt; </span><br><span class="line">&lt;/exclusion&gt; </span><br><span class="line">&lt;/exclusions&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><p>[3]、排除后的效果<br> <img src="https://i.loli.net/2019/05/16/5cdd10f117e8740700.jpg" alt="依赖排除效果"></p></blockquote><h6 id="5-5、统一管理所依赖-jar-包的版本"><a href="#5-5、统一管理所依赖-jar-包的版本" class="headerlink" title="5-5、统一管理所依赖 jar 包的版本"></a>5-5、统一管理所依赖 jar 包的版本</h6><blockquote><p>1、统一管理 jar 包版本：对同一个框架的一组jar包最好使用相同的版本。为了方便升级框架，可以将 jar 包的版本信息统一提取出来。 </p></blockquote><p>[1]、统一声明版本号<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--其中 atguigu.spring.version 部分是自定义属性标签。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">atguigu.spring.version</span>&gt;</span>4.1.1.RELEASE<span class="tag">&lt;/<span class="name">atguigu.spring.version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>[2]、引用前面声明的版本号 （EL 表达式引用变量）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;atguigu.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>[3]、其他用法 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自定义编码属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="5-6、依赖的原则：解决-jar-包冲突"><a href="#5-6、依赖的原则：解决-jar-包冲突" class="headerlink" title="5-6、依赖的原则：解决 jar 包冲突"></a>5-6、依赖的原则：解决 jar 包冲突</h6><p>[1]、路径最短者优先<br> <img src="https://i.loli.net/2019/05/16/5cdd11179914065450.jpg" alt="路径最短者优先"></p><p>[2]、路径相同时先声明者优先<br><img src="https://i.loli.net/2019/05/16/5cdd1122da95d41741.jpg" alt="路径相同时先声明者优先 "><br>    这里“声明”的先后顺序指的是 dependency 标签配置的先后顺序。 </p><hr><h5 id="六、仓库"><a href="#六、仓库" class="headerlink" title="六、仓库"></a>六、仓库</h5><h6 id="6-1、分类"><a href="#6-1、分类" class="headerlink" title="6-1、分类"></a>6-1、分类</h6><p>[1]、本地仓库：为当前本机电脑上的所有 Maven 工程服务。<br>[2]、远程仓库 </p><ul><li>(1)、私服：架设在当前局域网环境下，为当前局域网范围内的所有 Maven 工程服务。<br><img src="https://i.loli.net/2019/05/16/5cdd1138bc48d56294.jpg" alt="私服"></li><li>(2)、中央仓库：架设在 Internet 上，为全世界所有 Maven 工程服务。 </li><li>(3)、中央仓库的镜像：架设在各个大洲，为中央仓库分担流量。减轻中央仓库的压力，同时更快的响应用户请求。 <h6 id="6-2、仓库中的文件"><a href="#6-2、仓库中的文件" class="headerlink" title="6-2、仓库中的文件"></a>6-2、仓库中的文件</h6></li><li>[1]、Maven 的插件 。</li><li>[2]、我们自己开发的项目的模块 。</li><li>[3]、第三方框架或工具的 jar 包 。</li></ul><p><strong>※不管是什么样的 jar 包，在仓库中都是按照坐标生成目录结构，所以可以通过统一的方式查询或依赖。</strong> </p><hr><h5 id="六、生命周期"><a href="#六、生命周期" class="headerlink" title="六、生命周期"></a>六、生命周期</h5><h6 id="6-1、什么是-Maven-的生命周期？"><a href="#6-1、什么是-Maven-的生命周期？" class="headerlink" title="6.1、什么是 Maven 的生命周期？"></a>6.1、什么是 Maven 的生命周期？</h6><blockquote><p>1、Maven 生命周期简介：Maven 生命周期定义了各个构建环节的执行顺序，有了这个清单，Maven 就可以自动化的执行构建命令了。 </p></blockquote><blockquote><p>2、Maven 有三套相互独立的生命周期，分别是：  </p><ul><li>①、Clean Lifecycle 在进行真正的构建之前进行一些清理工作。 </li><li>②、Default Lifecycle 构建的核心部分，编译，测试，打包，安装，部署等等。 </li><li>③、Site Lifecycle 生成项目报告，站点，发布站点。<br>它们是相互独立的，你可以仅仅调用 clean 来清理工作目录，仅仅调用 site 来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。<br>每套生命周期都由一组阶段 (Phase) 组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行 mvn clean，这个 clean 是 Clean 生命周期的一个阶段。有 Clean 生命周期，也有 clean 阶段。 </li></ul></blockquote><ul><li><p><strong>1、Clean 生命周期</strong><br>Clean 生命周期一共包含了三个阶段：<br>①、pre-clean 执行一些需要在 clean 之前完成的工作  。<br>②、clean 移除所有上一次构建生成的文件  。<br>③、post-clean 执行一些需要在 clean 之后立刻完成的工作  。</p></li><li><p><strong>2、Site 生命周期</strong><br>①、pre-site 执行一些需要在生成站点文档之前完成的工作 。<br>②、site 生成项目的站点文档 。<br>③、post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 。<br>④、site-deploy 将生成的站点文档部署到特定的服务器上 。<br>这里经常用到的是 site 阶段和 site-deploy 阶段，用以生成和发布 Maven 站点，这可是 Maven 相当强大的功能，Manager 比较喜欢，文档及统计数据自动生成，很好看。 </p></li><li><p><strong>3、Default 生命周期</strong><br>Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段： validate generate-sources process-sources<br>generate-resources<br>process-resources 复制并处理资源文件，至目标目录，准备打包。<br>compile 编译项目的源代码。<br>process-classes generate-test-sources process-test-sources<br>generate-test-resources<br>process-test-resources 复制并处理资源文件，至目标测试目录。<br>test-compile 编译测试源代码。<br>process-test-classes<br>test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。<br>prepare-package<br>package 接受编译好的代码，打包成可发布的格式，如 JAR。<br>pre-integration-test integration-test post-integration-test verify<br>install 将包安装至本地仓库，以让其它项目依赖。<br>deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享或部署到服务器上运行。 </p></li></ul><h6 id="6-2、-生命周期与自动化构建"><a href="#6-2、-生命周期与自动化构建" class="headerlink" title="6.2、 生命周期与自动化构建"></a>6.2、 生命周期与自动化构建</h6><blockquote><p>运行任何一个阶段的时候，它前面的所有阶段都会被运行，例如我们运行 mvn install 的时候，代码会被编译，测试，打包。这就是 Maven 为什么能够自动执行构建过程的各个环节的原因。此外，Maven 的插件机制是完全依赖 Maven 的生命周期的，因此理解生命周期至关重要。<br>插件和目标 ：</p><ul><li>1、Maven 的核心仅仅定义了抽象的生命周期，具体的任务都是交由插件完成的</li><li>2、每个插件都能实现多个功能，每个功能就是一个插件目标。 </li><li>3、Maven 的生命周期与插件目标相互绑定，以完成某个具体的构建任务。<br>例如：compile 就是插件 maven-compiler-plugin 的一个目标；pre-clean 是插件 maven-clean-plugin 的一个目标。 </li></ul></blockquote><hr><h5 id="七、继承"><a href="#七、继承" class="headerlink" title="七、继承"></a>七、继承</h5><h6 id="7-1、为什么需要继承机制？"><a href="#7-1、为什么需要继承机制？" class="headerlink" title="7.1、为什么需要继承机制？"></a>7.1、为什么需要继承机制？</h6><blockquote><p>1、问题描述：由于非 compile 范围的依赖信息是不能在“依赖链”中传递的，所以有需要的工程只能单独配置。例如： 以下工程 pom 配置（以 junit jar 包依赖为例）</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Hello 工程--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--HelloFriend 工程--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--MakeFriend --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>此时如果项目需要将各个模块的 junit 版本统一为 4.9，那么到各个工程中手动修改无疑是非常不可取的。<br>使用继承机制就可以将这样的依赖信息统一提取到父工程模块中进行统一管理。<br>创建父工程创建父工程和创建一般的 Java 工程操作一致，<strong>唯一需要注意的是：打包方式处要设置为 pom。</strong><br>在子工程中引用父工程 </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--1、子工程内引用父工程，进行继承--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--父工程坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 指定从当前子工程的pom.xml文件出发，查找父工程的pom.xml的路径 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../Parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--2、 此时如果子工程的 groupId 和 version 如果和父工程重复则可以删除。 在父工程中管理依赖将 Parent 项目中的 dependencies 标签，用 dependencyManagement 标签括起来  --&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span> </span><br><span class="line"> <span class="comment">&lt;!--3、在子项目中重新指定需要的依赖，删除范围和版本号  --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h5 id="八、聚合"><a href="#八、聚合" class="headerlink" title="八、聚合"></a>八、聚合</h5><h6 id="8-1、为什么要使用聚合？"><a href="#8-1、为什么要使用聚合？" class="headerlink" title="8.1、为什么要使用聚合？"></a>8.1、为什么要使用聚合？</h6><blockquote><p>1、情景描述：将多个工程拆分为模块后，需要手动逐个安装到仓库后依赖才能够生效。修改源码后也需要逐个手动进行 clean 操作。而使用了聚合之后就可以批量进行 Maven 工程的安装、清理工作。 </p></blockquote><h6 id="8-2、如何配置聚合？"><a href="#8-2、如何配置聚合？" class="headerlink" title="8.2、如何配置聚合？"></a>8.2、如何配置聚合？</h6><blockquote><p>1、聚合配置：在总的聚合工程中使用 modules/module 标签组合，指定模块工程的相对路径即可 。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">module</span>&gt;</span>../Hello<span class="tag">&lt;/<span class="name">module</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">module</span>&gt;</span>../HelloFriend<span class="tag">&lt;/<span class="name">module</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">module</span>&gt;</span>../MakeFriends<span class="tag">&lt;/<span class="name">module</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Maven 库站我们可以到 <a href="http://mvnrepository.com/" target="_blank" rel="noopener">http://mvnrepository.com/</a> 搜索需要的 jar 包的依赖信息。</strong> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;br&gt;&lt;strong&gt;Maven&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;导言：生产环境下开发不再是一个项目一个工程，而是每一个模块创建一个工程，而多个模块整合在一起就需要使用到像 Maven 这样的构建工具。&lt;/strong&gt; &lt;/p&gt;
&lt;hr&gt;
&lt;
      
    
    </summary>
    
      <category term="开发工具相关" scheme="http://pengguozhen.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Maven使用手册" scheme="http://pengguozhen.github.io/tags/Maven%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>二、VMware 中 Linux 网络配置及环境初始化</title>
    <link href="http://pengguozhen.github.io/%E4%BA%8C%E3%80%81VMware%20%E4%B8%AD%20Linux%20%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96.html"/>
    <id>http://pengguozhen.github.io/二、VMware 中 Linux 网络配置及环境初始化.html</id>
    <published>2019-09-25T05:57:42.140Z</published>
    <updated>2019-09-25T05:57:42.140Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h5 id="一、linux-网络连接问题"><a href="#一、linux-网络连接问题" class="headerlink" title="一、linux 网络连接问题"></a>一、linux 网络连接问题</h5><p>弹出界面eth0：错误：激活连接失败：Device not managed by NetworkManager or unavailable<br>参考：<a href="https://my.oschina.net/u/2324318/blog/1814002" target="_blank" rel="noopener">https://my.oschina.net/u/2324318/blog/1814002</a></p><h5 id="二、linux-配置静态ip，方便-xshell-远程"><a href="#二、linux-配置静态ip，方便-xshell-远程" class="headerlink" title="二、linux 配置静态ip，方便 xshell 远程"></a>二、linux 配置静态ip，方便 xshell 远程</h5><h6 id="2-1、修改网络配置文件"><a href="#2-1、修改网络配置文件" class="headerlink" title="2-1、修改网络配置文件"></a>2-1、修改网络配置文件</h6><p>参考：<a href="https://blog.csdn.net/attend_/article/details/79025172" target="_blank" rel="noopener">https://blog.csdn.net/attend_/article/details/79025172</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">EVICE=eth0</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">UUID=d3349997-0d0c-48c4-be1c-189f960ebfdd</span><br><span class="line">ONBOOT=yes</span><br><span class="line">NM_CONTROLLED=yes</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=192.168.2.129</span><br><span class="line">GATEWAY=192.168.2.1</span><br><span class="line">DNS1=222.168.160.70</span><br><span class="line">DNS2=114.114.114.114</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=yes</span><br><span class="line">IPV6INIT=noNAME="System eth0"</span><br><span class="line">HWADDR=00:0c:29:b3:31:cd</span><br><span class="line">LAST_CONNECT=1556613678</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">USERCTL=no</span><br><span class="line">PEERDNS=yes</span><br></pre></td></tr></table></figure><h6 id="2-2、静态ip-配置好后，重启网络服务"><a href="#2-2、静态ip-配置好后，重启网络服务" class="headerlink" title="2-2、静态ip 配置好后，重启网络服务"></a>2-2、静态ip 配置好后，重启网络服务</h6><p>centos7 网卡出现问题。不能重启网络服务<br>参考：<a href="https://www.cnblogs.com/wudonghang/p/c0cd315470b06ef0f455855fe36c222c.html" target="_blank" rel="noopener">https://www.cnblogs.com/wudonghang/p/c0cd315470b06ef0f455855fe36c222c.html</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl network restart</span><br></pre></td></tr></table></figure><h6 id="2-3、关闭防火墙"><a href="#2-3、关闭防火墙" class="headerlink" title="2-3、关闭防火墙"></a>2-3、关闭防火墙</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">防火墙相关</span><br><span class="line"></span><br><span class="line">启动： </span><br><span class="line">systemctl start firewalld</span><br><span class="line"></span><br><span class="line">查看状态： </span><br><span class="line">systemctl status firewalld </span><br><span class="line"></span><br><span class="line">禁用，禁止开机启动： </span><br><span class="line">systemctl disable firewalld</span><br><span class="line"></span><br><span class="line">停止运行： </span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><h6 id="2-4、编辑-虚拟网络编辑器内-NAT-设置子网ip-和网关"><a href="#2-4、编辑-虚拟网络编辑器内-NAT-设置子网ip-和网关" class="headerlink" title="2-4、编辑-虚拟网络编辑器内 NAT 设置子网ip 和网关"></a>2-4、编辑-虚拟网络编辑器内 NAT 设置子网ip 和网关</h6><p>(网关为windows ipv4 默认网关例如 192.168.2.1，子网ip 192.168.2.0 必须和网关在同一网段，2 为网段)。</p><h6 id="2-5、虚拟机无法ping-通主机ip，但是可以ping-通网关"><a href="#2-5、虚拟机无法ping-通主机ip，但是可以ping-通网关" class="headerlink" title="2-5、虚拟机无法ping 通主机ip，但是可以ping 通网关"></a>2-5、虚拟机无法ping 通主机ip，但是可以ping 通网关</h6><p>参考文章：<a href="https://blog.csdn.net/sinat_25306771/article/details/52761926" target="_blank" rel="noopener">https://blog.csdn.net/sinat_25306771/article/details/52761926</a></p><h6 id="2-6、网络已通，ssh无法连接服务器-？"><a href="#2-6、网络已通，ssh无法连接服务器-？" class="headerlink" title="2-6、网络已通，ssh无法连接服务器 ？"></a>2-6、网络已通，ssh无法连接服务器 ？</h6><blockquote><p>1、vmnet8 使用动态分配的ip 与虚拟机ip 不在同一网段导致ssh 不能连接。；<br>2、和配置文件的MAC地址不匹配，这个也好解决，使用ip addr（或ifconfig）查看mac地址；<br>3、查看 NAT 模式下是否勾选将主机虚拟适配器连接到此网络。windows vmnet8 设置：<br><img src="./pic-1569376149666.png" alt="" title="pic-1569376149666.png">参考：<a href="https://www.jianshu.com/p/ee44f0cd7743" target="_blank" rel="noopener">https://www.jianshu.com/p/ee44f0cd7743</a></p></blockquote><h5 id="三、如何为linux-换镜像仓库，yum安装找不到镜像仓库？-设置镜像仓库"><a href="#三、如何为linux-换镜像仓库，yum安装找不到镜像仓库？-设置镜像仓库" class="headerlink" title="三、如何为linux 换镜像仓库，yum安装找不到镜像仓库？ 设置镜像仓库"></a>三、如何为linux 换镜像仓库，yum安装找不到镜像仓库？ 设置镜像仓库</h5><p>参考：<a href="https://blog.csdn.net/inslow/article/details/54177191" target="_blank" rel="noopener">https://blog.csdn.net/inslow/article/details/54177191</a></p><h5 id="四、yum-安装mysql-不成功镜像仓库导致。。建议官网下载压缩包解压安装。"><a href="#四、yum-安装mysql-不成功镜像仓库导致。。建议官网下载压缩包解压安装。" class="headerlink" title="四、yum 安装mysql 不成功镜像仓库导致。。建议官网下载压缩包解压安装。"></a>四、yum 安装mysql 不成功镜像仓库导致。。建议官网下载压缩包解压安装。</h5><p>参考：<a href="http://orchome.com/238" target="_blank" rel="noopener">http://orchome.com/238</a><a href="https://blog.csdn.net/pengzhenjie36/article/details/75053059" target="_blank" rel="noopener">https://blog.csdn.net/pengzhenjie36/article/details/75053059</a></p><h5 id="五、RPM-包安装方式的MySQL卸载"><a href="#五、RPM-包安装方式的MySQL卸载" class="headerlink" title="五、RPM 包安装方式的MySQL卸载"></a>五、RPM 包安装方式的MySQL卸载</h5><p>参考：<a href="https://www.jianshu.com/p/7b8c4dea6829" target="_blank" rel="noopener">https://www.jianshu.com/p/7b8c4dea6829</a></p><h5 id="六、更新yum-源（使用yum-下载安装软件，yum-仓库使用源一定要配置好）"><a href="#六、更新yum-源（使用yum-下载安装软件，yum-仓库使用源一定要配置好）" class="headerlink" title="六、更新yum 源（使用yum 下载安装软件，yum 仓库使用源一定要配置好）"></a>六、更新yum 源（使用yum 下载安装软件，yum 仓库使用源一定要配置好）</h5><p>参考：<a href="https://blog.csdn.net/u013850277/article/details/79240695" target="_blank" rel="noopener">https://blog.csdn.net/u013850277/article/details/79240695</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h5 id=&quot;一、linux-网络连接问题&quot;&gt;&lt;a href=&quot;#一、linux-网络连接问题&quot; class=&quot;headerlink&quot; title=&quot;一、linux 网络连接问题&quot;&gt;&lt;/a&gt;一、linux 网络连接问题&lt;/h5&gt;&lt;p&gt;弹出界面eth0：
      
    
    </summary>
    
      <category term="Linux 学习" scheme="http://pengguozhen.github.io/categories/Linux-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux 学习" scheme="http://pengguozhen.github.io/tags/Linux-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>一、Linux操作手册</title>
    <link href="http://pengguozhen.github.io/%E4%B8%80%E3%80%81Linux%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C.html"/>
    <id>http://pengguozhen.github.io/一、Linux操作手册.html</id>
    <published>2019-09-25T01:02:24.265Z</published>
    <updated>2019-09-25T01:02:24.266Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h5 id="一、Linux-简介"><a href="#一、Linux-简介" class="headerlink" title="一、Linux 简介"></a>一、Linux 简介</h5><hr><h5 id="二、关于操作系统的选型"><a href="#二、关于操作系统的选型" class="headerlink" title="二、关于操作系统的选型"></a>二、关于操作系统的选型</h5><hr><h5 id="三、Linux-安装-Ubuntu-Server-16-04-X64"><a href="#三、Linux-安装-Ubuntu-Server-16-04-X64" class="headerlink" title="三、Linux-安装 Ubuntu Server 16.04 X64"></a>三、Linux-安装 Ubuntu Server 16.04 X64</h5><hr><h5 id="四、服务器远程控制及网络配置。"><a href="#四、服务器远程控制及网络配置。" class="headerlink" title="四、服务器远程控制及网络配置。"></a>四、服务器远程控制及网络配置。</h5><h6 id="4-1、配置网络"><a href="#4-1、配置网络" class="headerlink" title="4-1、配置网络"></a>4-1、配置网络</h6><p>参考：<a href="https://app.yinxiang.com/shard/s68/nl/15711850/0d438b05-6250-4e78-966b-d14063c11486" target="_blank" rel="noopener">VMware 中 Linux 网络配置及环境初始化</a></p><blockquote><p>安装 ssh</p></blockquote><hr><h5 id="五、目录结构说明"><a href="#五、目录结构说明" class="headerlink" title="五、目录结构说明"></a>五、目录结构说明</h5><p><img src="https://i.loli.net/2019/08/27/ypsn5DcH9G7uI2F.png" alt="目录结构"></p><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>bin</td><td>存放二进制可执行文件(ls,cat,mkdir等)</td></tr><tr><td>boot</td><td>存放用于系统引导时使用的各种文件</td></tr><tr><td>dev</td><td>用于存放设备文件</td></tr><tr><td>etc</td><td>存放系统配置文件</td></tr><tr><td>home</td><td>存放所有用户文件的根目录</td></tr><tr><td>lib</td><td>存放跟文件系统中的程序运行所需要的共享库及内核模块</td></tr><tr><td>mnt</td><td>系统管理员安装临时文件系统的安装点</td></tr><tr><td>opt</td><td>额外安装的可选应用程序包所放置的位置</td></tr><tr><td>proc</td><td>虚拟文件系统，存放当前内存的映射</td></tr><tr><td>root</td><td>超级用户目录</td></tr><tr><td>sbin</td><td>存放二进制可执行文件，只有root才能访问</td></tr><tr><td>tmp</td><td>用于存放各种临时文件</td></tr><tr><td>usr</td><td>用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录</td></tr><tr><td>var</td><td>用于存放运行时需要改变数据的文件</td></tr></tbody></table><hr><h5 id="六、操作文件目录命令"><a href="#六、操作文件目录命令" class="headerlink" title="六、操作文件目录命令"></a>六、操作文件目录命令</h5><table><thead><tr><th>命令</th><th>说明</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>ls</td><td>显示文件和目录列表</td><td>ls [-alrtAFR] [name…]</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-l</td><td>列出文件的详细信息</td></tr><tr><td></td><td></td><td></td><td>-a</td><td>列出当前目录所有文件，包含隐藏文件</td></tr><tr><td>mkdir</td><td>创建目录</td><td>mkdir [-p] dirName</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-p</td><td>父目录不存在情况下先生成父目录</td></tr><tr><td>cd</td><td>切换目录</td><td>cd [dirName]</td><td></td><td></td></tr><tr><td>touch</td><td>生成一个空文件</td><td></td><td></td><td></td></tr><tr><td>echo</td><td>生成一个带内容文件</td><td>echo abcd &gt; 1.txt，echo 1234 &gt;&gt; 1.txt</td><td></td><td></td></tr><tr><td>cat</td><td>显示文本文件内容</td><td>cat [-AbeEnstTuv] [–help] [–version] fileName</td><td></td><td></td></tr><tr><td>cp</td><td>复制文件或目录</td><td>cp [options] source dest</td><td></td><td></td></tr><tr><td>rm</td><td>删除文件</td><td>rm [options] name…</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-f</td><td>强制删除文件或目录</td></tr><tr><td></td><td></td><td></td><td>-r</td><td>同时删除该目录下的所有文件</td></tr><tr><td>mv</td><td>移动文件或目录</td><td>mv [options] source dest</td><td></td><td></td></tr><tr><td>find</td><td>在文件系统中查找指定的文件</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-name</td><td>文件名</td></tr><tr><td>grep</td><td>在指定的文本文件中查找指定的字符串</td><td></td><td></td><td></td></tr><tr><td>tree</td><td>用于以树状图列出目录的内容</td><td></td><td></td><td></td></tr><tr><td>pwd</td><td>显示当前工作目录</td><td></td><td></td><td></td></tr><tr><td>ln</td><td>建立软链接</td><td></td><td></td><td></td></tr><tr><td>more</td><td>分页显示文本文件内容</td><td></td><td></td><td></td></tr><tr><td>head</td><td>显示文件开头内容</td><td></td><td></td><td></td></tr><tr><td>tail</td><td>显示文件结尾内容</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-f</td><td>跟踪输出</td></tr></tbody></table><hr><h5 id="七、系统管理命令"><a href="#七、系统管理命令" class="headerlink" title="七、系统管理命令"></a>七、系统管理命令</h5><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>stat</td><td>显示指定文件的相关信息,比ls命令显示内容更多</td></tr><tr><td>who</td><td>显示在线登录用户</td></tr><tr><td>hostname</td><td>显示主机名称</td></tr><tr><td>uname</td><td>显示系统信息</td></tr><tr><td>top</td><td>显示当前系统中耗费资源最多的进程</td></tr><tr><td>ps</td><td>显示瞬间的进程状态</td></tr><tr><td>du</td><td>显示指定的文件（目录）已使用的磁盘空间的总量</td></tr><tr><td>df</td><td>显示文件系统磁盘空间的使用情况</td></tr><tr><td>free</td><td>显示当前内存和交换空间的使用情况</td></tr><tr><td>ifconfig</td><td>显示网络接口信息</td></tr><tr><td>ping</td><td>测试网络的连通性</td></tr><tr><td>netstat</td><td>显示网络状态信息</td></tr><tr><td>clear</td><td>清屏</td></tr><tr><td>kill</td><td>杀死一个进程</td></tr></tbody></table><hr><h5 id="八、重启与压缩命令"><a href="#八、重启与压缩命令" class="headerlink" title="八、重启与压缩命令"></a>八、重启与压缩命令</h5><h6 id="重启命令"><a href="#重启命令" class="headerlink" title="重启命令"></a>重启命令</h6><blockquote><p>shutdown 命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。</p></blockquote><table><thead><tr><th>命令</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>shutdown</td><td>shutdown [-t seconds] [-rkhncfF] time [message]</td><td></td><td></td></tr><tr><td></td><td></td><td>-t seconds</td><td>设定在几秒钟之后进行关机程序</td></tr><tr><td></td><td></td><td>-k</td><td>并不会真的关机，只是将警告讯息传送给所有只用者</td></tr><tr><td></td><td></td><td>-r</td><td>关机后重新开机（重启）</td></tr><tr><td></td><td></td><td>-h</td><td>关机后停机</td></tr><tr><td></td><td></td><td>-n</td><td>不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机</td></tr><tr><td></td><td></td><td>-c</td><td>取消目前已经进行中的关机动作</td></tr><tr><td></td><td></td><td>-f</td><td>关机时，不做 fcsk 动作(检查 Linux 档系统)</td></tr><tr><td></td><td></td><td>-F</td><td>关机时，强迫进行 fsck 动作</td></tr><tr><td></td><td></td><td>time</td><td>设定关机的时间</td></tr><tr><td></td><td></td><td>message</td><td>传送给所有使用者的警告讯息</td></tr></tbody></table><h6 id="解压缩命令"><a href="#解压缩命令" class="headerlink" title="解压缩命令"></a>解压缩命令</h6><table><thead><tr><th>命令</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>tar</td><td>tar [-cxzjvf] 压缩打包文档的名称 欲打包目录</td><td></td><td></td></tr><tr><td></td><td></td><td>-c</td><td>建立一个归档文件的参数指令</td></tr><tr><td></td><td></td><td>-x</td><td>解开一个归档文件的参数指令</td></tr><tr><td></td><td></td><td>-z</td><td>是否需要用 gzip 压缩</td></tr><tr><td></td><td></td><td>-j</td><td>是否需要用 bzip2 压缩</td></tr><tr><td></td><td></td><td>-v</td><td>压缩的过程中显示文件</td></tr><tr><td></td><td></td><td>-f</td><td>使用档名，在 f 之后要立即接档名</td></tr><tr><td></td><td></td><td>-tf</td><td>查看归档文件里面的文件</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">实例：</span><br><span class="line">1、tar 命令打包</span><br><span class="line">tar -cvf 打包名 欲打包目录 </span><br><span class="line">tar -cvf xxx.tar filename</span><br><span class="line"></span><br><span class="line">2、tar 命令解包</span><br><span class="line">tar -xvf xxx.tar</span><br></pre></td></tr></table></figure><hr><h5 id="九、Linux-编辑器"><a href="#九、Linux-编辑器" class="headerlink" title="九、Linux 编辑器"></a>九、Linux 编辑器</h5><h6 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h6><blockquote><p>运行模式<br>编辑模式：等待编辑命令输入。<br>插入模式：编辑模式下，输入 i 进入插入模式，插入文本信息。<br>命令模式：在编辑模式下，输入 : 进行命令模式。</p></blockquote><blockquote><p>:命令<br>q 直接退出vi<br>:wq 保存后退出vi ，并可以新建文件<br>:q! 强制退出<br>:w file 将当前内容保存成某个文件<br>:set number 在编辑文件显示行号<br>:set nonumber    在编辑文件不显示行号</p></blockquote><hr><h5 id="十、Linux-软件包管理"><a href="#十、Linux-软件包管理" class="headerlink" title="十、Linux 软件包管理"></a>十、Linux 软件包管理</h5><h6 id="10-1、使用-Root-用户"><a href="#10-1、使用-Root-用户" class="headerlink" title="10-1、使用 Root 用户"></a>10-1、使用 Root 用户</h6><blockquote><p>在实际生产操作中，我们基本上都是使用超级管理员账户操作 Linux 系统，也就是 Root 用户，Linux 系统默认是关闭 Root 账户的，我们需要为 Root 用户设置一个初始密码以方便我们使用。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1、设置 Root 账户密码</span><br><span class="line">sudo passwd root</span><br><span class="line"></span><br><span class="line">2、切换到 Root</span><br><span class="line">su root</span><br><span class="line"></span><br><span class="line">3、设置远程允许远程登录 Root</span><br><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Authentication:</span><br><span class="line">LoginGraceTime 120</span><br><span class="line"><span class="meta">#</span>PermitRootLogin without-password     //注释此行</span><br><span class="line">PermitRootLogin yes                             //加入此行</span><br><span class="line">StrictModes yes</span><br><span class="line"></span><br><span class="line">重启服务</span><br><span class="line">service ssh restart</span><br></pre></td></tr></table></figure><h6 id="10-2、用户账户说明"><a href="#10-2、用户账户说明" class="headerlink" title="10-2、用户账户说明"></a>10-2、用户账户说明</h6><blockquote><p>普通用户：<br>普通用户在系统上的任务是进行普通操作。</p></blockquote><blockquote><p>超级管理员：<br>管理员在系统上的任务是对普通用户和整个系统进行管理。对系统具有绝对的控制权，能够对系统进行一切操作。用 root 表示，root 用户在系统中拥有最高权限，默认下 Ubuntu 用户的 root 用户是不能登录的。</p></blockquote><blockquote><p>安装时创建的系统用户：<br>此用户创建时被添加到 admin 组中，在 Ubuntu 中，admin 组中的用户默认是可以使用 sudo 命令来执行只有管理员才能执行的命令的。如果不使用 sudo 就是一个普通用户。</p></blockquote><h6 id="10-3、组账户说明"><a href="#10-3、组账户说明" class="headerlink" title="10-3、组账户说明"></a>10-3、组账户说明</h6><blockquote><p>私有组：<br>当创建一个用户时没有指定属于哪个组，Linux 就会建立一个与用户同名的私有组，此私有组只含有该用户。<br>标准组：<br>当创建一个用户时可以选定一个标准组，如果一个用户同时属于多个组时，登录后所属的组为主组，其他的为附加组。</p></blockquote><h6 id="10-4、账户系统文件说明"><a href="#10-4、账户系统文件说明" class="headerlink" title="10-4、账户系统文件说明"></a>10-4、账户系统文件说明</h6><blockquote><p>1、/etc/passwd<br>每一行代表一个账号，众多账号是系统正常运行所必须的，例如 bin，nobody 每行定义一个用户账户，此文件对所有用户可读。<br>每行账户包含如下信息：<br>root:x:0:0:root:/root:/bin/bash</p></blockquote><ul><li>用户名： 就是账号，用来对应 UID，root UID 是 0。</li><li>口令： 密码，早期 UNIX 系统密码存在此字段，由于此文件所有用户都可以读取，密码容易泄露，后来这个字段数据就存放到 /etc/shadow 中，这里只能看到 X。</li><li>用户标示号（UID）： 系统内唯一，root 用户的 UID 为 0，普通用户从 1000 开始，1-999 是系统的标准账户，500-65536 是可登陆账号。</li><li>组标示号（GID）： 与 /etc/group 相关用来规定组名和 GID 相对应。</li><li>注释： 注释账号</li><li>宿主目录（主文件夹）： 用户登录系统后所进入的目录 root 在 /root/itcast</li><li>命令解释器（shell）： 指定该用户使用的 shell ，默认的是 /bin/bash</li></ul><blockquote><p>2、/etc/shadow<br>为了增加系统的安全性，用户口令通常用 shadow passwords 保护。只有 root 可读。每行包含如下信息：<br>root:$6$Reu571.V$Ci/kd.OTzaSGU.TagZ5KjYx2MLzQv2IkZ24E1.yeTT3Pp4o/yniTjus/rRaJ92Z18MVy6suf1W5uxxurqssel.:17465:0:99999:7:::</p></blockquote><ul><li>账号名称： 需要和 /etc/passwd 一致。</li><li>密码： 经过加密，虽然加密，但不表示不会被破解，该文件默认权限如下：<ul><li>-rw——- 1 root root 1560 Oct 26 17:20 passwd-</li><li>只有root能都读写</li></ul></li><li>最近修改密码日期： 从1970-1-1起，到用户最后一次更改口令的天数。</li><li>密码最小时间间隔： 从1970-1-1起，到用户可以更改口令的天数。</li><li>密码最大时间间隔： 从1970-1-1起，必须更改的口令天数。</li><li>密码到期警告时间： 在口令过期之前几天通知。</li><li>密码到期后账号宽限时间。</li><li>密码到期禁用账户时间： 在用户口令过期后到禁用账户的天数。</li><li>保留。</li></ul><blockquote><p>3、/etc/group<br>用户组的配置文件 ：root:x:0:</p></blockquote><ul><li>用户组名称</li><li>用户组密码： 给用户组管理员使用，通常不用。</li><li>GID： 用户组的ID。</li><li>此用户支持的账号名称： 一个账号可以加入多个用户组，例如想要 itcast 加入 root 这个用户组，将该账号填入该字段即可 root❌0:root, icast 将用户进行分组是 Linux 对用户进行管理及控制访问权限的一种手段。一个中可以有多个用户，一个用户可以同时属于多个组。该文件对所有用户可读。</li></ul><blockquote><p>4、/etc/gshadow<br>该文件用户定义用户组口令，组管理员等信息只有root用户可读。<br>root:*::</p></blockquote><ul><li>用户组名。</li><li>密码列。</li><li>用户组管理员的账号。</li><li>用户组所属账号。</li></ul><h6 id="10-5、账户管理常用命令"><a href="#10-5、账户管理常用命令" class="headerlink" title="10-5、账户管理常用命令"></a>10-5、账户管理常用命令</h6><blockquote><p>1、增加用户<br>2、修改用户<br>3、删除用户<br>4、组账户维护<br>5、口令维护<br>6、用户和组状态</p></blockquote><hr><h5 id="十一、Linux-用户和组管理"><a href="#十一、Linux-用户和组管理" class="headerlink" title="十一、Linux 用户和组管理"></a>十一、Linux 用户和组管理</h5><h5 id="十二、Linux-文件权限管理"><a href="#十二、Linux-文件权限管理" class="headerlink" title="十二、Linux 文件权限管理"></a>十二、Linux 文件权限管理</h5><h5 id="十三、Linux-安装-Java"><a href="#十三、Linux-安装-Java" class="headerlink" title="十三、Linux 安装 Java"></a>十三、Linux 安装 Java</h5><h5 id="十四、Linux-安装-Tomcat"><a href="#十四、Linux-安装-Tomcat" class="headerlink" title="十四、Linux 安装 Tomcat"></a>十四、Linux 安装 Tomcat</h5><h5 id="十五、Linux-安装-MySQL"><a href="#十五、Linux-安装-MySQL" class="headerlink" title="十五、Linux 安装 MySQL"></a>十五、Linux 安装 MySQL</h5><h5 id="十六、部署应用到生产环境"><a href="#十六、部署应用到生产环境" class="headerlink" title="十六、部署应用到生产环境"></a>十六、部署应用到生产环境</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h5 id=&quot;一、Linux-简介&quot;&gt;&lt;a href=&quot;#一、Linux-简介&quot; class=&quot;headerlink&quot; title=&quot;一、Linux 简介&quot;&gt;&lt;/a&gt;一、Linux 简介&lt;/h5&gt;&lt;hr&gt;
&lt;h5 id=&quot;二、关于操作系统的选型&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="Linux 学习" scheme="http://pengguozhen.github.io/categories/Linux-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux 学习" scheme="http://pengguozhen.github.io/tags/Linux-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>一、MySQL 基础</title>
    <link href="http://pengguozhen.github.io/MySQL%E5%9F%BA%E7%A1%80.html"/>
    <id>http://pengguozhen.github.io/MySQL基础.html</id>
    <published>2019-04-28T03:47:29.898Z</published>
    <updated>2019-04-28T03:47:29.899Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h5 id="一、为什么要学习数据库"><a href="#一、为什么要学习数据库" class="headerlink" title="一、为什么要学习数据库"></a>一、为什么要学习数据库</h5><ul><li>1、持久化数据到本地。</li><li>2、可以实现结构化查询，方便管理。</li></ul><hr><h5 id="二、数据库的相关概念"><a href="#二、数据库的相关概念" class="headerlink" title="二、数据库的相关概念"></a>二、数据库的相关概念</h5><p><strong>DBMS、DB、SQL</strong></p><ul><li>1、DB：数据库，保存一组有组织的数据的容器。</li><li>2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据。</li><li>3、SQL:结构化查询语言，用于和DBMS通信的语言。</li></ul><hr><h5 id="三、数据库存储数据的特点"><a href="#三、数据库存储数据的特点" class="headerlink" title="三、数据库存储数据的特点"></a>三、数据库存储数据的特点</h5><ul><li>1、数据存放到表中，然后表再放到库中。</li><li>2、一个库中可以有多张表，每张表具有唯一的表名用来标识自己。</li><li>3、表中有一个或多个列，列又称为“字段”，相当于java中“属性”。</li><li>4、表中的每一行数据，相当于java中“对象”。</li></ul><hr><h5 id="四、初始-MySQL"><a href="#四、初始-MySQL" class="headerlink" title="四、初始 MySQL"></a>四、初始 MySQL</h5><h6 id="4-2、MySQL-产品的介绍"><a href="#4-2、MySQL-产品的介绍" class="headerlink" title="4-2、MySQL 产品的介绍"></a>4-2、MySQL 产品的介绍</h6><ul><li>1、MySQL 的背景<ul><li>前身属于瑞典的一家公司，MySQL AB。</li><li>08 年被 sun 公司收购。</li><li>09 年 sun 被 oracle 收购。</li></ul></li><li>2、MySQL 的优点<ul><li>1、开源、免费、成本低。</li><li>2、性能高、移植性也好。</li><li>3、体积小，便于安装。</li></ul></li></ul><h6 id="4-3、MySQL-产品的安装-★"><a href="#4-3、MySQL-产品的安装-★" class="headerlink" title="4-3、MySQL 产品的安装          ★"></a>4-3、MySQL 产品的安装          ★</h6><ul><li>1、属于c/s架构的软件，一般来讲安装服务端。<ul><li>企业版。</li><li>社区版(5.5、5.6、5.7、8.0)。</li></ul></li></ul><h6 id="4-4、MySQL-服务的启动和停止-★"><a href="#4-4、MySQL-服务的启动和停止-★" class="headerlink" title="4-4、MySQL 服务的启动和停止     ★"></a>4-4、MySQL 服务的启动和停止     ★</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方式一：计算机——右击管理——服务</span><br><span class="line"></span><br><span class="line">方式二：通过管理员身份运行</span><br><span class="line">net start 服务名（启动服务）</span><br><span class="line">net stop 服务名（停止服务）</span><br></pre></td></tr></table></figure><h6 id="4-5、MySQL-服务的登录和退出-★"><a href="#4-5、MySQL-服务的登录和退出-★" class="headerlink" title="4-5、MySQL 服务的登录和退出     ★"></a>4-5、MySQL 服务的登录和退出     ★</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">方式一：通过mysql自带的客户端</span><br><span class="line">只限于root用户</span><br><span class="line"></span><br><span class="line">方式二：通过windows自带的客户端</span><br><span class="line">登录：</span><br><span class="line">mysql 【-h主机名 -P端口号 】-u用户名 -p密码</span><br><span class="line"></span><br><span class="line">退出：</span><br><span class="line">exit或ctrl+C</span><br></pre></td></tr></table></figure><h6 id="4-6、MySQL-的常见命令和语法规范"><a href="#4-6、MySQL-的常见命令和语法规范" class="headerlink" title="4-6、MySQL 的常见命令和语法规范"></a>4-6、MySQL 的常见命令和语法规范</h6><p><strong>常见命令</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.查看当前所有的数据库。</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.打开指定的库。</span></span><br><span class="line"><span class="keyword">use</span> 库名</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.查看当前库的所有表。</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4.查看其它库的所有表。</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">from</span> 库名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.创建表。</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line"></span><br><span class="line">列名 列类型,</span><br><span class="line">列名 列类型，</span><br><span class="line">。。。</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 6.查看表结构。</span></span><br><span class="line">desc 表名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7.查看服务器的版本。</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">version</span>();<span class="comment">-- 方式一：登录到mysql服务端。</span></span><br><span class="line">mysql <span class="comment">-- version;或 mysql --V;-- 方式二：没有登录到mysql服务端。</span></span><br></pre></td></tr></table></figure></p><p><strong>语法规范</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>不区分大小写,但建议关键字大写，表名、列名小写。</span><br><span class="line"><span class="number">2.</span>每条命令最好用分号结尾。</span><br><span class="line"><span class="number">3.</span>每条命令根据需要，可以进行缩进 或换行。</span><br><span class="line"><span class="number">4.</span>注释。</span><br><span class="line">单行注释：#注释文字</span><br><span class="line">单行注释：-- 注释文字</span><br><span class="line">多行注释：<span class="comment">/* 注释文字  */</span></span><br></pre></td></tr></table></figure></p><h6 id="4-7、SQL-的语言分类。"><a href="#4-7、SQL-的语言分类。" class="headerlink" title="4-7、SQL 的语言分类。"></a>4-7、SQL 的语言分类。</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DQL（Data Query Language）：数据查询语言</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">DML(<span class="keyword">Data</span> Manipulate <span class="keyword">Language</span>):数据操作语言</span><br><span class="line"><span class="keyword">insert</span> 、<span class="keyword">update</span>、<span class="keyword">delete</span></span><br><span class="line"><span class="keyword">DDL</span>（<span class="keyword">Data</span> <span class="keyword">Define</span> Languge）：数据定义语言</span><br><span class="line"><span class="keyword">create</span>、<span class="keyword">drop</span>、<span class="keyword">alter</span></span><br><span class="line">TCL（<span class="keyword">Transaction</span> Control <span class="keyword">Language</span>）：事务控制语言</span><br><span class="line"><span class="keyword">commit</span>、<span class="keyword">rollback</span></span><br></pre></td></tr></table></figure><hr><h5 id="五、DQL语言的学习-★"><a href="#五、DQL语言的学习-★" class="headerlink" title="五、DQL语言的学习   ★"></a>五、DQL语言的学习   ★</h5><h6 id="5-1、基础查询-★"><a href="#5-1、基础查询-★" class="headerlink" title="5-1、基础查询        ★"></a>5-1、基础查询        ★</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="keyword">SELECT</span> 要查询的东西</span><br><span class="line">【<span class="keyword">FROM</span> 表名】;</span><br><span class="line"></span><br><span class="line">类似于Java中 :System.out.println(要打印的东西);</span><br><span class="line">特点：</span><br><span class="line">①通过<span class="keyword">select</span>查询完的结果 ，是一个虚拟的表格，不是真实存在。</span><br><span class="line">②要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数  。</span><br></pre></td></tr></table></figure><h6 id="5-2、条件查询-★"><a href="#5-2、条件查询-★" class="headerlink" title="5-2、条件查询         ★"></a>5-2、条件查询         ★</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">条件查询：根据条件过滤原始表的数据，查询到想要的数据</span><br><span class="line">语法：</span><br><span class="line">select </span><br><span class="line">要查询的字段|表达式|常量值|函数</span><br><span class="line">from </span><br><span class="line">表</span><br><span class="line">where </span><br><span class="line">条件 ;</span><br><span class="line"></span><br><span class="line">分类：</span><br><span class="line">一、条件表达式</span><br><span class="line">示例：salary&gt;10000</span><br><span class="line">条件运算符：</span><br><span class="line">&gt; &lt; &gt;= &lt;= = != &lt;&gt;</span><br><span class="line"></span><br><span class="line">二、逻辑表达式</span><br><span class="line">示例：salary&gt;10000 &amp;&amp; salary&lt;20000</span><br><span class="line"></span><br><span class="line">逻辑运算符：</span><br><span class="line"></span><br><span class="line">and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false</span><br><span class="line">or(||)：两个条件只要有一个成立，结果为true，否则为false</span><br><span class="line">not(!)：如果条件成立，则not后为false，否则为true</span><br><span class="line"></span><br><span class="line">三、模糊查询</span><br><span class="line">示例：last_name like &apos;a%&apos;</span><br></pre></td></tr></table></figure><h6 id="5-3、排序查询-★"><a href="#5-3、排序查询-★" class="headerlink" title="5-3、排序查询         ★"></a>5-3、排序查询         ★</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">select</span><br><span class="line">要查询的东西</span><br><span class="line">from</span><br><span class="line">表</span><br><span class="line">where </span><br><span class="line">条件</span><br><span class="line"></span><br><span class="line">order by 排序的字段|表达式|函数|别名 【asc|desc】</span><br></pre></td></tr></table></figure><h6 id="5-4、常见函数-★"><a href="#5-4、常见函数-★" class="headerlink" title="5-4、常见函数        ★"></a>5-4、常见函数        ★</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">一、单行函数</span><br><span class="line">1、字符函数</span><br><span class="line">concat拼接</span><br><span class="line">substr截取子串</span><br><span class="line">upper转换成大写</span><br><span class="line">lower转换成小写</span><br><span class="line">trim去前后指定的空格和字符</span><br><span class="line">ltrim去左边空格</span><br><span class="line">rtrim去右边空格</span><br><span class="line">replace替换</span><br><span class="line">lpad左填充</span><br><span class="line">rpad右填充</span><br><span class="line">instr返回子串第一次出现的索引</span><br><span class="line">length 获取字节个数</span><br><span class="line"></span><br><span class="line">2、数学函数</span><br><span class="line">round 四舍五入</span><br><span class="line">rand 随机数</span><br><span class="line">floor向下取整</span><br><span class="line">ceil向上取整</span><br><span class="line">mod取余</span><br><span class="line">truncate截断</span><br><span class="line">3、日期函数</span><br><span class="line">now当前系统日期+时间</span><br><span class="line">curdate当前系统日期</span><br><span class="line">curtime当前系统时间</span><br><span class="line">str_to_date 将字符转换成日期</span><br><span class="line">date_format将日期转换成字符</span><br><span class="line">4、流程控制函数</span><br><span class="line">if 处理双分支</span><br><span class="line">case语句 处理多分支</span><br><span class="line">情况1：处理等值判断</span><br><span class="line">情况2：处理条件判断</span><br><span class="line"></span><br><span class="line">5、其他函数</span><br><span class="line">version版本</span><br><span class="line">database当前库</span><br><span class="line">user当前连接用户</span><br></pre></td></tr></table></figure><h6 id="5-5、分组函数-★"><a href="#5-5、分组函数-★" class="headerlink" title="5-5、分组函数        ★"></a>5-5、分组函数        ★</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sum 求和</span><br><span class="line">max 最大值</span><br><span class="line">min 最小值</span><br><span class="line">avg 平均值</span><br><span class="line">count 计数</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">1、以上五个分组函数都忽略null值，除了count(*)</span><br><span class="line">2、sum和avg一般用于处理数值型</span><br><span class="line">max、min、count可以处理任何数据类型</span><br><span class="line">3、都可以搭配distinct使用，用于统计去重后的结果</span><br><span class="line">4、count的参数可以支持：</span><br><span class="line">字段、*、常量值，一般放1</span><br><span class="line"></span><br><span class="line">   建议使用 count(*)</span><br></pre></td></tr></table></figure><h6 id="5-6、分组查询-★"><a href="#5-6、分组查询-★" class="headerlink" title="5-6、分组查询           ★"></a>5-6、分组查询           ★</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">select 查询的字段，分组函数</span><br><span class="line">from 表</span><br><span class="line">group by 分组的字段</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">1、可以按单个字段分组</span><br><span class="line">2、和分组函数一同查询的字段最好是分组后的字段</span><br><span class="line">3、分组筛选</span><br><span class="line">针对的表位置关键字</span><br><span class="line">分组前筛选：原始表group by的前面where</span><br><span class="line">分组后筛选：分组后的结果集group by的后面having</span><br><span class="line"></span><br><span class="line">4、可以按多个字段分组，字段之间用逗号隔开</span><br><span class="line">5、可以支持排序</span><br><span class="line">6、having后可以支持别名</span><br></pre></td></tr></table></figure><h6 id="5-7、连接查询-★"><a href="#5-7、连接查询-★" class="headerlink" title="5-7、连接查询         ★"></a>5-7、连接查询         ★</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">笛卡尔乘积：如果连接条件省略或无效则会出现</span><br><span class="line">解决办法：添加上连接条件。</span><br></pre></td></tr></table></figure><p><strong>一、传统模式下的连接 ：等值连接——非等值连接。</strong></p><ul><li>1.等值连接的结果 = 多个表的交集。</li><li>2.n表连接，至少需要n-1个连接条件。</li><li>3.多个表不分主次，没有顺序要求。</li><li>4.一般为表起别名，提高阅读性和性能。</li></ul><p><strong>二、sql99语法：通过join关键字实现连接。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">含义：1999年推出的sql语法</span><br><span class="line">支持：</span><br><span class="line">等值连接、非等值连接 （内连接）</span><br><span class="line">外连接</span><br><span class="line">交叉连接</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line">select 字段，...</span><br><span class="line">from 表1</span><br><span class="line">【inner|left outer|right outer|cross】join 表2 on  连接条件</span><br><span class="line">【inner|left outer|right outer|cross】join 表3 on  连接条件</span><br><span class="line">【where 筛选条件】</span><br><span class="line">【group by 分组字段】</span><br><span class="line">【having 分组后的筛选条件】</span><br><span class="line">【order by 排序的字段或表达式】</span><br><span class="line"></span><br><span class="line">好处：语句上，连接条件和筛选条件实现了分离，简洁明了！</span><br></pre></td></tr></table></figure><p><strong>三、自连接</strong><br>案例：查询员工名和直接上级的名称</p><p>sql99</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN employees m ON e.`manager_id`=m.`employee_id`;</span><br></pre></td></tr></table></figure><p>sql92</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e,employees m </span><br><span class="line">WHERE e.`manager_id`=m.`employee_id`;</span><br></pre></td></tr></table></figure><h6 id="5-8、子查询-√"><a href="#5-8、子查询-√" class="headerlink" title="5-8、子查询       √"></a>5-8、子查询       √</h6><p><strong>含义：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询。</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1、子查询都放在小括号内</span><br><span class="line">2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧</span><br><span class="line">3、子查询优先于主查询执行，主查询使用了子查询的执行结果</span><br><span class="line">4、子查询根据查询结果的行数不同分为以下两类：</span><br><span class="line">① 单行子查询</span><br><span class="line">结果集只有一行</span><br><span class="line">一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= </span><br><span class="line">非法使用子查询的情况：</span><br><span class="line">a、子查询的结果为一组值</span><br><span class="line">b、子查询的结果为空</span><br><span class="line"></span><br><span class="line">② 多行子查询</span><br><span class="line">结果集有多行</span><br><span class="line">一般搭配多行操作符使用：any、all、in、not in</span><br><span class="line">in： 属于子查询结果中的任意一个就行</span><br><span class="line">any和all往往可以用其他查询代替</span><br></pre></td></tr></table></figure><h6 id="5-9、分页查询-★"><a href="#5-9、分页查询-★" class="headerlink" title="5-9、分页查询       ★"></a>5-9、分页查询       ★</h6><p><strong>应用场景：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句。</span><br></pre></td></tr></table></figure><p><strong>语法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select 字段|表达式,...</span><br><span class="line"><span class="keyword">from</span> 表</span><br><span class="line">【where 条件】</span><br><span class="line">【group by 分组字段】</span><br><span class="line">【having 条件】</span><br><span class="line">【order by 排序的字段】</span><br><span class="line">limit 【起始的条目索引，】条目数;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>起始条目索引从<span class="number">0</span>开始</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>limit子句放在查询语句的最后</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>公式：select * <span class="keyword">from</span>  表 limit （page<span class="number">-1</span>）*sizePerPage,sizePerPage</span><br><span class="line">假如:</span><br><span class="line">每页显示条目数sizePerPage</span><br><span class="line">要显示的页数 page</span><br></pre></td></tr></table></figure><h6 id="5-10、union联合查询-√"><a href="#5-10、union联合查询-√" class="headerlink" title="5-10、union联合查询    √"></a>5-10、union联合查询    √</h6><p><strong>引入：</strong><br>    union 联合、合并</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】</span><br><span class="line">.....</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、多条查询语句的查询的列数必须是一致的</span><br><span class="line">2、多条查询语句的查询的列的类型几乎相同</span><br><span class="line">3、union代表去重，union all代表不去重</span><br></pre></td></tr></table></figure><hr><h5 id="六、DML语言的学习-★"><a href="#六、DML语言的学习-★" class="headerlink" title="六、DML语言的学习    ★"></a>六、DML语言的学习    ★</h5><h6 id="6-2、插入语句"><a href="#6-2、插入语句" class="headerlink" title="6-2、插入语句"></a>6-2、插入语句</h6><p><strong>语法：</strong><br>    insert into 表名(字段名，…)<br>    values(值1，…);</p><p><strong>特点：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、字段类型和值类型一致或兼容，而且一一对应。</span><br><span class="line">2、可以为空的字段，可以不用插入值，或用null填充。</span><br><span class="line">3、不可以为空的字段，必须插入值。</span><br><span class="line">4、字段个数和值的个数必须一致。</span><br><span class="line">5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致。</span><br></pre></td></tr></table></figure><h6 id="6-3、修改语句"><a href="#6-3、修改语句" class="headerlink" title="6-3、修改语句"></a>6-3、修改语句</h6><p><strong>修改单表语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段=新值,字段=新值</span><br><span class="line">【<span class="keyword">where</span> 条件】</span><br></pre></td></tr></table></figure><p><strong>修改多表语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表<span class="number">1</span> 别名<span class="number">1</span>,表<span class="number">2</span> 别名<span class="number">2</span></span><br><span class="line"><span class="keyword">set</span> 字段=新值，字段=新值</span><br><span class="line"><span class="keyword">where</span> 连接条件</span><br><span class="line"><span class="keyword">and</span> 筛选条件</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 1、如何对一张表的数据进行批量更新？</li></ul><h6 id="6-4、删除语句"><a href="#6-4、删除语句" class="headerlink" title="6-4、删除语句"></a>6-4、删除语句</h6><p><strong>方式1：delete语句</strong> </p><p><strong>1、单表的删除： ★</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 【<span class="keyword">where</span> 筛选条件】</span><br></pre></td></tr></table></figure><p><strong>2、多表的删除：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> 别名<span class="number">1</span>，别名<span class="number">2</span></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> 别名<span class="number">1</span>，表<span class="number">2</span> 别名<span class="number">2</span></span><br><span class="line"><span class="keyword">where</span> 连接条件</span><br><span class="line"><span class="keyword">and</span> 筛选条件;</span><br></pre></td></tr></table></figure><p><strong>方式2：truncate语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名</span><br></pre></td></tr></table></figure><p><strong>两种方式的区别【面试题】</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>1.truncate不能加where条件，而delete可以加where条件。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>2.truncate的效率高一丢丢。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始。</span><br><span class="line"><span class="meta">#</span>delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>4.truncate删除不能回滚，delete删除可以回滚。</span><br></pre></td></tr></table></figure><hr><h5 id="七、DDL语言的学习"><a href="#七、DDL语言的学习" class="headerlink" title="七、DDL语言的学习"></a>七、DDL语言的学习</h5><h6 id="7-1、库和表的管理-√"><a href="#7-1、库和表的管理-√" class="headerlink" title="7-1、库和表的管理     √"></a>7-1、库和表的管理     √</h6><p><strong>库的管理：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一、创建库</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 库名</span><br><span class="line">二、删除库</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 库名</span><br></pre></td></tr></table></figure><p><strong>表的管理：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#1.创建表</span><br><span class="line">CREATE TABLE IF NOT EXISTS stuinfo(</span><br><span class="line">stuId INT,</span><br><span class="line">stuName VARCHAR(20),</span><br><span class="line">gender CHAR,</span><br><span class="line">bornDate DATETIME</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DESC studentinfo;</span><br><span class="line"></span><br><span class="line">#2.修改表 alter</span><br><span class="line">语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;</span><br><span class="line"></span><br><span class="line">#①修改字段名</span><br><span class="line">ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;</span><br><span class="line"></span><br><span class="line">#②修改表名</span><br><span class="line">ALTER TABLE stuinfo RENAME [TO]  studentinfo;</span><br><span class="line">#③修改字段类型和列级约束</span><br><span class="line">ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;</span><br><span class="line"></span><br><span class="line">#④添加字段</span><br><span class="line"></span><br><span class="line">ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;</span><br><span class="line">#⑤删除字段</span><br><span class="line">ALTER TABLE studentinfo DROP COLUMN email;</span><br><span class="line"></span><br><span class="line">#3.删除表</span><br><span class="line"></span><br><span class="line">DROP TABLE [IF EXISTS] studentinfo;</span><br></pre></td></tr></table></figure><h6 id="7-2、常见数据类型介绍-√"><a href="#7-2、常见数据类型介绍-√" class="headerlink" title="7-2、常见数据类型介绍  √"></a>7-2、常见数据类型介绍  √</h6><ul><li>整型：</li><li>小数：<ul><li>浮点型</li><li>定点型</li></ul></li><li>字符型：</li><li>日期型：</li><li>Blob类型：</li></ul><h6 id="7-3、常见约束-√"><a href="#7-3、常见约束-√" class="headerlink" title="7-3、常见约束        √"></a>7-3、常见约束        √</h6><ul><li>NOT NULL</li><li>DEFAULT</li><li>UNIQUE</li><li>CHECK</li><li>PRIMARY KEY</li><li>FOREIGN KEY</li></ul><hr><h5 id="八、TCL语言的学习"><a href="#八、TCL语言的学习" class="headerlink" title="八、TCL语言的学习"></a>八、TCL语言的学习</h5><p>事务和事务处理<br><strong>含义：</strong><br>通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态<br><strong>特点：</strong><br>（ACID）</p><ul><li>原子性：要么都执行，要么都回滚。</li><li>一致性：保证数据的状态操作前和操作后保持一致。（比如：钱的总额一定，分布式数据库中数据存储保持一致性。）</li><li>隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰。</li><li>持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改。<h6 id="8-1、事务的分类"><a href="#8-1、事务的分类" class="headerlink" title="8-1、事务的分类"></a>8-1、事务的分类</h6></li><li>隐式事务，没有明显的开启和结束事务的标志。</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比如</span><br><span class="line"><span class="keyword">insert</span>、<span class="keyword">update</span>、<span class="keyword">delete</span>语句本身就是一个事务。</span><br><span class="line">- 显式事务，具有明显的开启和结束事务的标志。</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、开启事务</span><br><span class="line">取消自动提交事务的功能</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、编写事务的一组逻辑操作单元（多条sql语句）</span><br><span class="line"><span class="keyword">insert</span></span><br><span class="line"><span class="keyword">update</span></span><br><span class="line"><span class="keyword">delete</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、提交事务或回滚事务</span><br></pre></td></tr></table></figure><h6 id="8-2、使用到的关键字"><a href="#8-2、使用到的关键字" class="headerlink" title="8-2、使用到的关键字"></a>8-2、使用到的关键字</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">savepoint</span>  断点</span><br><span class="line"><span class="keyword">commit</span> <span class="keyword">to</span> 断点</span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> 断点</span><br></pre></td></tr></table></figure><h6 id="8-3、事务的隔离级别"><a href="#8-3、事务的隔离级别" class="headerlink" title="8-3、事务的隔离级别"></a>8-3、事务的隔离级别</h6><ul><li>1、事务并发问题如何发生？<br>当多个事务同时操作同一个数据库的相同数据时。</li><li>2、事务的并发问题有哪些？<ul><li>脏读：一个事务读取到了另外一个事务未提交的数据。</li><li>不可重复读：同一个事务中，多次读取到的数据不一致。</li><li>幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据。</li></ul></li><li>3、如何避免事务的并发问题？</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通过设置事务的隔离级别</span><br><span class="line"><span class="number">1</span>、READ UNCOMMITTED。</span><br><span class="line"><span class="number">2</span>、READ COMMITTED 可以避免脏读。</span><br><span class="line"><span class="number">3</span>、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读。</span><br><span class="line"><span class="number">4</span>、SERIALIZABLE可以避免脏读、不可重复读和幻读。</span><br></pre></td></tr></table></figure><ul><li>4、设置隔离级别：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span>|<span class="keyword">global</span>  <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> 隔离级别名;</span><br></pre></td></tr></table></figure><ul><li>5、查看隔离级别：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@tx_isolation;</span><br></pre></td></tr></table></figure><hr><h5 id="九、视图的讲解-√"><a href="#九、视图的讲解-√" class="headerlink" title="九、视图的讲解           √"></a>九、视图的讲解           √</h5><ul><li><strong>含义</strong>：理解成一张虚拟的表。</li><li><strong>视图和表的区别</strong>：</li></ul><table><thead><tr><th></th><th>使用方式</th><th>占用物理空间</th></tr></thead><tbody><tr><td>视图</td><td>完全相同</td><td>不占用，仅仅保存的是sql逻辑</td></tr><tr><td>表</td><td>完全相同</td><td>占用</td></tr></tbody></table><ul><li><strong>视图的好处</strong>：<ul><li>1、sql语句提高重用性，效率高。</li><li>2、和表实现了分离，提高了安全性。<h6 id="9-1、视图的创建"><a href="#9-1、视图的创建" class="headerlink" title="9-1、视图的创建"></a>9-1、视图的创建</h6></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">CREATE VIEW  视图名</span><br><span class="line">AS</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure><h6 id="9-2、视图的增删改查"><a href="#9-2、视图的增删改查" class="headerlink" title="9-2、视图的增删改查"></a>9-2、视图的增删改查</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、查看视图的数据 ★</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_v4;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_v1 <span class="keyword">WHERE</span> last_name=<span class="string">'Partners'</span>;</span><br><span class="line"></span><br><span class="line">2、插入视图的数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_v4(last_name,department_id) <span class="keyword">VALUES</span>(<span class="string">'虚竹'</span>,<span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">3、修改视图的数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> my_v4 <span class="keyword">SET</span> last_name =<span class="string">'梦姑'</span> <span class="keyword">WHERE</span> last_name=<span class="string">'虚竹'</span>;</span><br><span class="line"></span><br><span class="line">4、删除视图的数据</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> my_v4;</span><br></pre></td></tr></table></figure><h6 id="9-3、某些视图不能更新"><a href="#9-3、某些视图不能更新" class="headerlink" title="9-3、某些视图不能更新"></a>9-3、某些视图不能更新</h6><p>包含以下关键字的sql语句：</p><ul><li>分组函数、distinct、group  by、having、union或者union all。</li><li>常量视图。</li><li>Select中包含子查询。</li><li>join</li><li>from一个不能更新的视图。</li><li>where子句的子查询引用了from子句中的表。<h6 id="9-4、视图逻辑的更新"><a href="#9-4、视图逻辑的更新" class="headerlink" title="9-4、视图逻辑的更新"></a>9-4、视图逻辑的更新</h6></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#方式一：重新创建</span><br><span class="line">CREATE OR REPLACE VIEW test_v7</span><br><span class="line">AS</span><br><span class="line">SELECT last_name FROM employees</span><br><span class="line">WHERE employee_id&gt;100;</span><br><span class="line"></span><br><span class="line">#方式二: 修改更新视图逻辑</span><br><span class="line">ALTER VIEW test_v7</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT * FROM test_v7;</span><br></pre></td></tr></table></figure><h6 id="9-5、视图的删除"><a href="#9-5、视图的删除" class="headerlink" title="9-5、视图的删除"></a>9-5、视图的删除</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW test_v1,test_v2,test_v3;</span><br></pre></td></tr></table></figure><h6 id="9-6、视图结构的查看"><a href="#9-6、视图结构的查看" class="headerlink" title="9-6、视图结构的查看"></a>9-6、视图结构的查看</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DESC test_v7;</span><br><span class="line">SHOW CREATE VIEW test_v7;</span><br></pre></td></tr></table></figure><h5 id="十、变量"><a href="#十、变量" class="headerlink" title="十、变量"></a>十、变量</h5><h6 id="10-1、系统变量"><a href="#10-1、系统变量" class="headerlink" title="10-1、系统变量"></a>10-1、系统变量</h6><ul><li>1、全局变量(作用域：针对于所有会话（连接）有效，但不能跨重启)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES;</span><br><span class="line"></span><br><span class="line">查看满足条件的部分系统变量</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &apos;%char%&apos;;</span><br><span class="line"></span><br><span class="line">查看指定的系统变量的值</span><br><span class="line">SELECT @@global.autocommit;</span><br><span class="line"></span><br><span class="line">为某个系统变量赋值</span><br><span class="line">SET @@global.autocommit=0;</span><br><span class="line">SET GLOBAL autocommit=0;</span><br></pre></td></tr></table></figure><ul><li>2、会话变量(作用域：针对于当前会话（连接）有效)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES;</span><br><span class="line"></span><br><span class="line">查看满足条件的部分会话变量</span><br><span class="line">SHOW SESSION VARIABLES LIKE &apos;%char%&apos;;</span><br><span class="line"></span><br><span class="line">查看指定的会话变量的值</span><br><span class="line">SELECT @@autocommit;</span><br><span class="line">SELECT @@session.tx_isolation;</span><br><span class="line"></span><br><span class="line">为某个会话变量赋值</span><br><span class="line">SET @@session.tx_isolation=&apos;read-uncommitted&apos;;</span><br><span class="line">SET SESSION tx_isolation=&apos;read-committed&apos;;</span><br></pre></td></tr></table></figure><h6 id="10-2、自定义变量"><a href="#10-2、自定义变量" class="headerlink" title="10-2、自定义变量"></a>10-2、自定义变量</h6><ul><li><p>1、用户变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 声明并初始化</span><br><span class="line">SET @变量名=值;</span><br><span class="line">SET @变量名:=值;</span><br><span class="line">SELECT @变量名:=值;</span><br><span class="line"></span><br><span class="line">- 赋值</span><br><span class="line"></span><br><span class="line">方式一：一般用于赋简单的值</span><br><span class="line">SET 变量名=值;</span><br><span class="line">SET 变量名:=值;</span><br><span class="line">SELECT 变量名:=值;</span><br><span class="line"></span><br><span class="line">方式二：一般用于赋表 中的字段值</span><br><span class="line">SELECT 字段名或表达式 INTO 变量</span><br><span class="line">FROM 表;</span><br><span class="line"></span><br><span class="line">- 使用</span><br><span class="line">select @变量名;</span><br></pre></td></tr></table></figure></li><li><p>2、局部变量</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">声明：</span><br><span class="line">declare 变量名 类型 【default 值】;</span><br><span class="line"></span><br><span class="line">赋值：</span><br><span class="line">方式一：一般用于赋简单的值</span><br><span class="line">SET 变量名=值;</span><br><span class="line">SET 变量名:=值;</span><br><span class="line">SELECT 变量名:=值;</span><br><span class="line"></span><br><span class="line">方式二：一般用于赋表 中的字段值</span><br><span class="line">SELECT 字段名或表达式 INTO 变量</span><br><span class="line">FROM 表;</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">select 变量名</span><br></pre></td></tr></table></figure><h6 id="10-3、系统变量和自定义变量区别"><a href="#10-3、系统变量和自定义变量区别" class="headerlink" title="10-3、系统变量和自定义变量区别"></a>10-3、系统变量和自定义变量区别</h6><table><thead><tr><th></th><th>作用域</th><th>定义位置</th><th>语法</th></tr></thead><tbody><tr><td>用户变量</td><td>当前会话</td><td>会话的任何地方</td><td>加@符号，不用指定类型</td></tr><tr><td>局部变量</td><td>定义它的BEGIN END中</td><td>BEGIN END的第一句话</td><td>一般不用加@,需要指定类型</td></tr></tbody></table><h5 id="十一、存储过程和函数"><a href="#十一、存储过程和函数" class="headerlink" title="十一、存储过程和函数"></a>十一、存储过程和函数</h5><ul><li><strong>含义</strong>：一组经过预先编译的sql语句的集合。</li><li><strong>好处</strong>：<ul><li>1、提高了sql语句的重用性，减少了开发程序员的压力。</li><li>2、提高了效率。</li><li>3、减少了传输次数。</li></ul></li><li><strong>分类</strong>：<ul><li>1、无返回无参。</li><li>2、仅仅带in类型，无返回有参。</li><li>3、仅仅带out类型，有返回无参。</li><li>4、既带in又带out，有返回有参。</li><li>5、带inout，有返回有参。<h6 id="11-1、创建存储过程"><a href="#11-1、创建存储过程" class="headerlink" title="11-1、创建存储过程"></a>11-1、创建存储过程</h6></li></ul></li><li>1、DELIMITER 关键字及语法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql 默认以分号为语句的结束，但是在创建存储过程时 sql 语句中一般会出现多个分号。为了不让语句过早遇见分号;执行。在创建语句首行使用该关键字+特殊符号来指定其他字符为语句的结束。最后再指定 delimiter ; 恢复分号为语句结束标志。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">DELIMITER $$ </span><br><span class="line">DROP TRIGGER IF EXISTS `updateegopriceondelete`$$ </span><br><span class="line">CREATE </span><br><span class="line">    TRIGGER `updateegopriceondelete` AFTER  DELETE ON  `customerinfo` </span><br><span class="line">    FOR EACH ROW BEGIN </span><br><span class="line">DELETE FROM egoprice  WHERE customerId=OLD.customerId; </span><br><span class="line">    END$$ </span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><ul><li>2 、语法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#1、语法</span><br><span class="line">create procedure 存储过程名(in|out|inout 参数名  参数类型,...)</span><br><span class="line">begin</span><br><span class="line">存储过程体</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">#2、类似于方法</span><br><span class="line">修饰符 返回类型 方法名(参数类型 参数名,...)&#123;</span><br><span class="line"></span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#3、注意</span><br><span class="line">1、需要设置新的结束标记</span><br><span class="line">delimiter 新的结束标记</span><br><span class="line">示例：</span><br><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)</span><br><span class="line">BEGIN</span><br><span class="line">sql语句1;</span><br><span class="line">sql语句2;</span><br><span class="line"></span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end</span><br><span class="line"></span><br><span class="line">3、参数前面的符号的意思</span><br><span class="line">in:该参数只能作为输入 （该参数不能做返回值）</span><br><span class="line">out：该参数只能作为输出（该参数只能做返回值）</span><br><span class="line">inout：既能做输入又能做输出</span><br></pre></td></tr></table></figure><h6 id="11-2、调用存储过程"><a href="#11-2、调用存储过程" class="headerlink" title="11-2、调用存储过程"></a>11-2、调用存储过程</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 存储过程名(实参列表)</span><br></pre></td></tr></table></figure><h6 id="11-3、创建函数"><a href="#11-3、创建函数" class="headerlink" title="11-3、创建函数"></a>11-3、创建函数</h6><ul><li>学过的函数：LENGTH、SUBSTR、CONCAT 等。</li><li>语法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型</span><br><span class="line">BEGIN</span><br><span class="line">函数体</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure><h6 id="11-4、调用函数"><a href="#11-4、调用函数" class="headerlink" title="11-4、调用函数"></a>11-4、调用函数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 函数名（实参列表）</span><br></pre></td></tr></table></figure><h6 id="11-5、函数和存储过程的区别"><a href="#11-5、函数和存储过程的区别" class="headerlink" title="11-5、函数和存储过程的区别"></a>11-5、函数和存储过程的区别</h6><table><thead><tr><th></th><th>关键字</th><th>调用语法</th><th>返回值</th><th>应用场景</th></tr></thead><tbody><tr><td>函数</td><td>FUNCTION</td><td>SELECT 函数()</td><td>只能是一个</td><td>一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个</td></tr><tr><td>存储过程</td><td>PROCEDURE</td><td>CALL 存储过程()</td><td>可以有0个或多个</td><td>一般用于更新</td></tr></tbody></table><h5 id="十二、流程控制结构"><a href="#十二、流程控制结构" class="headerlink" title="十二、流程控制结构"></a>十二、流程控制结构</h5><h6 id="12-1、分支"><a href="#12-1、分支" class="headerlink" title="12-1、分支"></a>12-1、分支</h6><p><strong>一、if函数</strong><br>    语法：if(条件，值1，值2)<br>    特点：可以用在任何位置</p><p><strong>二、case语句</strong></p><p>语法：</p><pre><code>情况一：类似于switchcase 表达式when 值1 then 结果1或语句1(如果是语句，需要加分号) when 值2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）情况二：类似于多重ifcase when 条件1 then 结果1或语句1(如果是语句，需要加分号) when 条件2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）</code></pre><p>特点：<br>    可以用在任何位置</p><p><strong>三、if elseif语句</strong></p><p>语法：</p><pre><code>if 情况1 then 语句1;elseif 情况2 then 语句2;...else 语句n;end if;</code></pre><p>特点：<br>    只能用在begin end中！！！！！！！！！！！！！！！</p><p>三者比较：<br>            应用场合<br>    if函数        简单双分支<br>    case结构    等值判断 的多分支<br>    if结构        区间判断 的多分支</p><h6 id="12-2、循环"><a href="#12-2、循环" class="headerlink" title="12-2、循环"></a>12-2、循环</h6><p><strong>语法：</strong></p><pre><code>【标签：】WHILE 循环条件  DO    循环体END WHILE 【标签】;</code></pre><p><strong>特点：</strong></p><pre><code>只能放在BEGIN END里面如果要搭配leave跳转语句，需要使用标签，否则可以不用标签leave类似于java中的break语句，跳出所在循环！！！</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h5 id=&quot;一、为什么要学习数据库&quot;&gt;&lt;a href=&quot;#一、为什么要学习数据库&quot; class=&quot;headerlink&quot; title=&quot;一、为什么要学习数据库&quot;&gt;&lt;/a&gt;一、为什么要学习数据库&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;1、持久化数据到本地。&lt;/li
      
    
    </summary>
    
      <category term="MySQL基础" scheme="http://pengguozhen.github.io/categories/MySQL%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="MySQL基础" scheme="http://pengguozhen.github.io/tags/MySQL%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>一、SQL 转换：Oracle 转 MySQL</title>
    <link href="http://pengguozhen.github.io/MySQL%E6%9B%BF%E4%BB%A3Oracle%E5%BA%8F%E5%88%97.html"/>
    <id>http://pengguozhen.github.io/MySQL替代Oracle序列.html</id>
    <published>2019-04-25T03:05:07.000Z</published>
    <updated>2019-04-25T06:09:07.321Z</updated>
    
    <content type="html"><![CDATA[<p><strong>什么是自增长？</strong></p><ul><li>自增长只能用于表中的其中一个字段。</li><li>自增长只能被分配给固定表的固定的某一字段，不能被多个表共用。</li><li>自增长会把一个未指定或NULL值的字段自动填上。</li></ul><h5 id="一、在-Oracle-中如何实现-MySQL-的自增长？"><a href="#一、在-Oracle-中如何实现-MySQL-的自增长？" class="headerlink" title="一、在 Oracle 中如何实现 MySQL 的自增长？"></a>一、在 Oracle 中如何实现 MySQL 的自增长？</h5><p>请看下面的实例：</p><ul><li><p>1-1、在 MYSQL 里有这样一张表:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Movie(  </span><br><span class="line">  <span class="keyword">id</span>           <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,  </span><br><span class="line">  <span class="keyword">name</span>     <span class="built_in">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">  released <span class="keyword">YEAR</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)  </span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Movie (<span class="keyword">name</span>,released) <span class="keyword">VALUES</span> (<span class="string">'Gladiator'</span>,<span class="number">2000</span>);  </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Movie (<span class="keyword">id</span>,<span class="keyword">name</span>,released) <span class="keyword">VALUES</span> (<span class="literal">NULL</span>,<span class="string">'The Bourne Identity'</span>,<span class="number">1998</span>);</span><br></pre></td></tr></table></figure></li><li><p>1-2、在 ORACLE 是这样的使用序列对象+触发器来完成 MySQL 的自增长功能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Movie(  </span><br><span class="line"> <span class="keyword">id</span>          <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line"> <span class="keyword">name</span>     VARCHAR2(<span class="number">60</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line"> released <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)  </span><br><span class="line">);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SEQUENCE</span> MovieSeq;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Movie (<span class="keyword">id</span>,<span class="keyword">name</span>,released) <span class="keyword">VALUES</span> (MovieSeq.NEXTVAL,<span class="string">'Gladiator'</span>,<span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>在 Oracle 下为表添加一个触发器，就可以实现 MySQL 自增长功能:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.  <span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">TRIGGER</span> BRI_MOVIE_TRG  </span><br><span class="line"><span class="number">2.</span>  <span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> Movie  </span><br><span class="line"><span class="number">3.</span>  <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span>  </span><br><span class="line"><span class="number">4.</span>  <span class="keyword">BEGIN</span>  </span><br><span class="line"><span class="number">5.</span>  <span class="keyword">SELECT</span> MovieSeq.NEXTVAL <span class="keyword">INTO</span> :new.id <span class="keyword">FROM</span> DUAL;  </span><br><span class="line">6.  <span class="keyword">END</span> BRI_MOVIE_TRG;  </span><br><span class="line">7.  .  </span><br><span class="line">8.  RUN;</span><br></pre></td></tr></table></figure></p><p>这样，插入记录就可以成为 MYSQL 风格：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Movie (<span class="keyword">name</span>,released) <span class="keyword">VALUES</span> (<span class="string">'The Lion King'</span>,<span class="number">1994</span>);</span><br></pre></td></tr></table></figure><p>下面我们来看看如何在 mysql 数据里使用 Oracle 序列语法 .NEXTVAL 和  .CURVAL。</p><h5 id="二、MySQL-如何实现-Oracle-序列？"><a href="#二、MySQL-如何实现-Oracle-序列？" class="headerlink" title="二、MySQL 如何实现 Oracle 序列？"></a>二、MySQL 如何实现 Oracle 序列？</h5><p><strong>一般使用序列 (Sequence) 来处理主键字段，在 MySQL中 是没有序列的，但是 MySQL有提供了自增长 (increment) 来实现类似的目的，但也只是自增，而不能设置步长、开始索引、是否循环等，最重要的是一张表只能由一个字段使用自增，但有的时候我们需要两个或两个以上的字段实现自增（单表多字段自增），MySQL本身是实现不了的，但我们可以用创建一个序列表，使用函数来获取序列的值。</strong></p><p>我们假设在 MySQL 中序列的语法是:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NEXTVAL(’sequence’);</span><br><span class="line">CURRVAL(’sequence’);</span><br><span class="line">SETVAL(’sequence’,value);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="keyword">sequence</span>;  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">sequence</span> (  </span><br><span class="line"><span class="keyword">name</span>              <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">current_value <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line"><span class="keyword">increment</span>       <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,  </span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">name</span>)  </span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;  </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">sequence</span> <span class="keyword">VALUES</span> (<span class="string">'MovieSeq'</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h6 id="测试一下结果："><a href="#测试一下结果：" class="headerlink" title="测试一下结果："></a>测试一下结果：</h6><p>测试 <strong>currval</strong> 函数使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* currval 函数的实现 */</span></span><br><span class="line"> <span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> currval;  </span><br><span class="line"> DELIMITER $  </span><br><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> currval (seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>))  </span><br><span class="line"> <span class="keyword">RETURNS</span> <span class="built_in">INTEGER</span>  </span><br><span class="line"> CONTAINS <span class="keyword">SQL</span>  </span><br><span class="line"> <span class="keyword">BEGIN</span>  </span><br><span class="line"> <span class="keyword">DECLARE</span> <span class="keyword">value</span> <span class="built_in">INTEGER</span>;  </span><br><span class="line"> <span class="keyword">SET</span> <span class="keyword">value</span> = <span class="number">0</span>;  </span><br><span class="line"> <span class="keyword">SELECT</span> current_value <span class="keyword">INTO</span> <span class="keyword">value</span>  </span><br><span class="line"> <span class="keyword">FROM</span> <span class="keyword">sequence</span>  </span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;  </span><br><span class="line"> RETURN value;  </span><br><span class="line"> <span class="keyword">END</span>$  </span><br><span class="line"> DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.  mysql&gt; SELECT currval(<span class="string">'MovieSeq'</span>);  </span><br><span class="line">2.  +---------------------+  </span><br><span class="line">3.  | currval(<span class="string">'MovieSeq'</span>) |  </span><br><span class="line">4.  +---------------------+  </span><br><span class="line">5.  |                   3 |  </span><br><span class="line">6.  +---------------------+  </span><br><span class="line">7.  1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)  </span><br><span class="line">8.  mysql&gt; SELECT currval(<span class="string">'x'</span>);  </span><br><span class="line">9.  +--------------+  </span><br><span class="line">10.  | currval(<span class="string">'x'</span>) |  </span><br><span class="line">11.  +--------------+  </span><br><span class="line">12.  |            0 |  </span><br><span class="line">13.  +--------------+  </span><br><span class="line">14.  1 row <span class="keyword">in</span> <span class="built_in">set</span>, 1 warning (0.00 sec)  </span><br><span class="line">15.  mysql&gt; show warnings;  </span><br><span class="line">16.  +---------+------+------------------+  </span><br><span class="line">17.  | Level   | Code | Message          |  </span><br><span class="line">18.  +---------+------+------------------+  </span><br><span class="line">19.  | Warning | 1329 | No data to FETCH |  </span><br><span class="line">20.  +---------+------+------------------+  </span><br><span class="line">21.  1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>测试 <strong>nextval</strong> 函数使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* nextval 函数的实现 */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="keyword">nextval</span>;  </span><br><span class="line">DELIMITER $  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> <span class="keyword">nextval</span> (seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>))  </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">INTEGER</span>  </span><br><span class="line">CONTAINS <span class="keyword">SQL</span>  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">sequence</span>  </span><br><span class="line"><span class="keyword">SET</span>          current_value = current_value + <span class="keyword">increment</span>  </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;  </span><br><span class="line">RETURN currval(seq_name);  </span><br><span class="line"><span class="keyword">END</span>$  </span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.  mysql&gt; select nextval(<span class="string">'MovieSeq'</span>);  </span><br><span class="line">2.  +---------------------+  </span><br><span class="line">3.  | nextval(<span class="string">'MovieSeq'</span>) |  </span><br><span class="line">4.  +---------------------+  </span><br><span class="line">5.  |                  15 |  </span><br><span class="line">6.  +---------------------+  </span><br><span class="line">7.  1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.09 sec)  </span><br><span class="line"></span><br><span class="line">9.  mysql&gt; select nextval(<span class="string">'MovieSeq'</span>);  </span><br><span class="line">10.  +---------------------+  </span><br><span class="line">11.  | nextval(<span class="string">'MovieSeq'</span>) |  </span><br><span class="line">12.  +---------------------+  </span><br><span class="line">13.  |                  20 |  </span><br><span class="line">14.  +---------------------+  </span><br><span class="line">15.  1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.01 sec)  </span><br><span class="line"></span><br><span class="line">17.  mysql&gt; select nextval(<span class="string">'MovieSeq'</span>);  </span><br><span class="line">18.  +---------------------+  </span><br><span class="line">19.  | nextval(<span class="string">'MovieSeq'</span>) |  </span><br><span class="line">20.  +---------------------+  </span><br><span class="line">21.  |                  25 |  </span><br><span class="line">22.  +---------------------+  </span><br><span class="line">23.  1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>测试 <strong>setval</strong> 函数的使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* setval 函数的实现 */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> setval;  </span><br><span class="line">DELIMITER $  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> setval (seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>), <span class="keyword">value</span> <span class="built_in">INTEGER</span>)  </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">INTEGER</span>  </span><br><span class="line">CONTAINS <span class="keyword">SQL</span>  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">sequence</span>  </span><br><span class="line"><span class="keyword">SET</span>          current_value = <span class="keyword">value</span>  </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;  </span><br><span class="line">RETURN currval(seq_name);  </span><br><span class="line"><span class="keyword">END</span>$  </span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  mysql&gt; select setval('MovieSeq',<span class="number">150</span>);  </span><br><span class="line"><span class="number">2.</span>  +------------------------+  </span><br><span class="line"><span class="number">3.</span>  | setval('MovieSeq',<span class="number">150</span>) |  </span><br><span class="line"><span class="number">4.</span>  +------------------------+  </span><br><span class="line"><span class="number">5.</span>  |                    <span class="number">150</span> |  </span><br><span class="line"><span class="number">6.</span>  +------------------------+  </span><br><span class="line"><span class="number">7.</span>  <span class="number">1</span> row in set (<span class="number">0.06</span> sec)  </span><br><span class="line"></span><br><span class="line"><span class="number">9.</span>  mysql&gt; select curval('MovieSeq');  </span><br><span class="line"><span class="number">10.</span>  +---------------------+  </span><br><span class="line"><span class="number">11.</span>  | currval('MovieSeq') |  </span><br><span class="line"><span class="number">12.</span>  +---------------------+  </span><br><span class="line"><span class="number">13.</span>  |                 <span class="number">150</span> |  </span><br><span class="line"><span class="number">14.</span>  +---------------------+  </span><br><span class="line"><span class="number">15.</span>  <span class="number">1</span> row in set (<span class="number">0.00</span> sec)  </span><br><span class="line"></span><br><span class="line"><span class="number">17.</span>  mysql&gt; select nextval('MovieSeq');  </span><br><span class="line"><span class="number">18.</span>  +---------------------+  </span><br><span class="line"><span class="number">19.</span>  | nextval('MovieSeq') |  </span><br><span class="line"><span class="number">20.</span>  +---------------------+  </span><br><span class="line"><span class="number">21.</span>  |                 <span class="number">155</span> |  </span><br><span class="line"><span class="number">22.</span>  +---------------------+  </span><br><span class="line"><span class="number">23.</span>  <span class="number">1</span> row in set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h5 id="三、MySQL-替代-Oracle-序列实例："><a href="#三、MySQL-替代-Oracle-序列实例：" class="headerlink" title="三、MySQL 替代 Oracle 序列实例："></a>三、MySQL 替代 Oracle 序列实例：</h5><ul><li>1、问题场景：<br><strong>一般使用序列 (Sequence) 来处理主键字段，在 MySQL中 是没有序列的，但是 MySQL有提供了自增长 (increment) 来实现类似的目的，但也只是自增，而不能设置步长、开始索引、是否循环等，最重要的是一张表只能由一个字段使用自增，但有的时候我们需要两个或两个以上的字段实现自增（单表多字段自增），MySQL本身是实现不了的，但我们可以用创建一个序列表，使用函数来获取序列的值。</strong></li></ul><p>– MySQL 给数据表某个字段创建序列。<br>– 序列：自增（步长、开始索引、是否循环），暂不考虑是否循环自增（触发器可实现？）<br>select * from PAN_WF_HISTORYNODE;– ORDER_NUMBER 字段创建序列</p><p>– 创建代替序列的数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="keyword">sequence</span>;  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">sequence</span> (  </span><br><span class="line"><span class="keyword">name</span>              <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="comment">-- 序列 名称 50个字符最大值问题已够用，暂不考虑是否循环。</span></span><br><span class="line">current_value <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,  <span class="comment">-- 当前值</span></span><br><span class="line"><span class="keyword">increment</span>       <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,  <span class="comment">-- 步长</span></span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">name</span>)  </span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;  </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">sequence</span> <span class="keyword">VALUES</span> (<span class="string">'seq_hisnode'</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>–  处理 序列的 currval 函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span> <span class="keyword">global</span> log_bin_trust_function_creators=<span class="number">1</span>;<span class="comment">-- 解决自定义函数报错：ERROR 1418-This function has none of DETERMINISTIC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> currval;  </span><br><span class="line">DELIMITER $  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> currval (seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>))  </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">INTEGER</span>  </span><br><span class="line">CONTAINS <span class="keyword">SQL</span>  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line">  <span class="keyword">DECLARE</span> <span class="keyword">value</span> <span class="built_in">INTEGER</span>;  </span><br><span class="line">  <span class="keyword">SET</span> <span class="keyword">value</span> = <span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">SELECT</span> current_value <span class="keyword">INTO</span> <span class="keyword">value</span>  </span><br><span class="line">  <span class="keyword">FROM</span> <span class="keyword">sequence</span>  </span><br><span class="line">  <span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;  </span><br><span class="line">  RETURN value;  </span><br><span class="line"><span class="keyword">END</span>$  </span><br><span class="line">DELIMITER ;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> currval(<span class="string">'seq_hisnode'</span>);<span class="comment">-- 测试 该函数的使用。</span></span><br></pre></td></tr></table></figure><p>– 处理序列的 nextval 函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="keyword">nextval</span>;  </span><br><span class="line">DELIMITER $  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> <span class="keyword">nextval</span> (seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>))  </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">INTEGER</span>  </span><br><span class="line">CONTAINS <span class="keyword">SQL</span>  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line">   <span class="keyword">UPDATE</span> <span class="keyword">sequence</span>  </span><br><span class="line">   <span class="keyword">SET</span>          current_value = current_value + <span class="keyword">increment</span>  </span><br><span class="line">   <span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;  </span><br><span class="line">   RETURN currval(seq_name);  </span><br><span class="line"><span class="keyword">END</span>$  </span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">nextval</span>(<span class="string">'seq_hisnode'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> PAN_WF_HISTORYNODE <span class="keyword">values</span>()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;什么是自增长？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自增长只能用于表中的其中一个字段。&lt;/li&gt;
&lt;li&gt;自增长只能被分配给固定表的固定的某一字段，不能被多个表共用。&lt;/li&gt;
&lt;li&gt;自增长会把一个未指定或NULL值的字段自动填上。&lt;/li&gt;
&lt;/
      
    
    </summary>
    
      <category term="MySQL 学习" scheme="http://pengguozhen.github.io/categories/MySQL-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MySQL 学习" scheme="http://pengguozhen.github.io/tags/MySQL-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub page 搭建个人博客</title>
    <link href="http://pengguozhen.github.io/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo+%20github%20page%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%9F.html"/>
    <id>http://pengguozhen.github.io/如何使用Hexo+ github page搭建博客？.html</id>
    <published>2019-03-25T04:12:59.560Z</published>
    <updated>2019-03-25T05:43:23.033Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><ul><li><p>1、如何使用 github 搭建博客？<br>参考链接：</p><ul><li><a href="https://www.cnblogs.com/jackyroc/p/7681938.html" target="_blank" rel="noopener">https://www.cnblogs.com/jackyroc/p/7681938.html</a></li></ul></li><li><p>2、hexo 本地目录各文件以及文件夹的作用？</p><pre><code>主要看 _config.yml 文件。</code></pre></li><li>3、假如自己有多台设备，如何同步管理博客？<br> 参考链接： <ul><li><a href="https://juejin.im/post/5acf22e6f265da23994eeac9" target="_blank" rel="noopener">https://juejin.im/post/5acf22e6f265da23994eeac9</a></li></ul></li><li>4、hexo next 主题 Hexo-NexT配置超炫网页效果<pre><code>参考链接：</code></pre><ul><li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html</a></li><li><a href="https://juejin.im/post/5bcd2d395188255c3b7dc1db#heading-0" target="_blank" rel="noopener">https://juejin.im/post/5bcd2d395188255c3b7dc1db#heading-0</a></li></ul></li><li>5、hexo 如何发布文章？<ul><li><a href="https://www.jianshu.com/p/265b2c653e6f" target="_blank" rel="noopener">https://www.jianshu.com/p/265b2c653e6f</a></li><li><a href="https://www.zengyilun.com/HexoEditor/" target="_blank" rel="noopener">https://www.zengyilun.com/HexoEditor/</a></li><li><a href="https://www.cnblogs.com/xingyunblog/p/8681205.html" target="_blank" rel="noopener">https://www.cnblogs.com/xingyunblog/p/8681205.html</a></li></ul></li><li><p>6、个人定制？</p><pre><code>主题推荐：</code></pre><ul><li><a href="https://blog.csdn.net/qincidong/article/details/82415271" target="_blank" rel="noopener">https://blog.csdn.net/qincidong/article/details/82415271</a></li><li><a href="http://tengj.top/categories/hexo%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97/" target="_blank" rel="noopener">http://tengj.top/categories/hexo%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97/</a></li><li><a href="https://www.titanjun.top/" target="_blank" rel="noopener">https://www.titanjun.top/</a></li><li><p><a href="https://www.haomwei.com/" target="_blank" rel="noopener">https://www.haomwei.com/</a></p><p>主题的配置文件修改后可热部署，Hexo 的配置文件不可。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、如何使用 github 搭建博客？&lt;br&gt;参考链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/jackyroc/p/7681938.html&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Hexo" scheme="http://pengguozhen.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://pengguozhen.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>第3章-线性表</title>
    <link href="http://pengguozhen.github.io/%E7%AC%AC3%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8.html"/>
    <id>http://pengguozhen.github.io/第3章-线性表.html</id>
    <published>2019-03-25T02:51:43.036Z</published>
    <updated>2019-03-24T18:50:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p><img src="https://i.loli.net/2019/03/25/5c983b29bd6f0.jpg" alt="线性表"></p><h3 id="1、线性表定义"><a href="#1、线性表定义" class="headerlink" title="1、线性表定义"></a>1、线性表定义</h3><p>零个或多个数据元素的有限序列。</p><p>1、第一元素无前驱、最后一个元素无后继。<br>2、每个元素有且仅有一个前驱、后继。<br>3、相同数据元素。</p><hr><h3 id="2、线性表的抽象数据类型"><a href="#2、线性表的抽象数据类型" class="headerlink" title="2、线性表的抽象数据类型"></a>2、线性表的抽象数据类型</h3><hr><h3 id="3、线性表的顺序存储结构（数组实现）"><a href="#3、线性表的顺序存储结构（数组实现）" class="headerlink" title="3、线性表的顺序存储结构（数组实现）"></a>3、线性表的顺序存储结构（数组实现）</h3><p>线性表的两种物理存储结构（顺序存储结构、链式存储结构）</p><ul><li>1、顺序存储结构：指的是用一段地址连续的存储单元依次存储线性表的数据元素。</li><li><p>2、插入</p></li><li><p>3、删除</p></li></ul><p>优点：<br>可以快速存取表中的任意元素值。<br>无需为表示表中元素之间的逻辑关系而增加额外的存储空间。</p><p>缺点：<br>插入和删除操作需要移动大量元素；<br>线性表长度发生变化时，难以确定存储长度。<br>造成存储空间的碎片。</p><hr><h3 id="4、线性表的链式存储结构"><a href="#4、线性表的链式存储结构" class="headerlink" title="4、线性表的链式存储结构"></a>4、线性表的链式存储结构</h3><p>链式存储结构：</p><h4 id="4-1、单链表"><a href="#4-1、单链表" class="headerlink" title="4-1、单链表"></a>4-1、单链表</h4><ul><li>1、为什么使用单链表？<br>数组实现的顺序存储在插入和删除操作时需要移动大量的元素，且存储空间的容量难以确定。</li><li>2、单链表的插入、删除、修改、查找<br>实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dataStruct.singleLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线性表（链表）--节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pengguozhen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年4月2日 上午11:41:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node head;<span class="comment">// 指向链表头节点的引用变量</span></span><br><span class="line"><span class="keyword">private</span> Node tail;<span class="comment">// 指向链表尾节点的引用变量</span></span><br><span class="line"><span class="keyword">int</span> size;<span class="comment">// 链表中当前总节点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;<span class="comment">// 生成链表对象是一个空表</span></span><br><span class="line">head = <span class="keyword">null</span>;</span><br><span class="line">tail = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;<span class="comment">// 返回链表的长度</span></span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>查询--指定位置的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getElement</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="comment">// 1、获取指定位置的元素</span></span><br><span class="line"><span class="keyword">return</span> findNodeByIndex(index).data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findNodeByIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="comment">// 查找 指定索引位置的节点</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"线性表索引越界"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span> &amp;&amp; head.next == <span class="keyword">null</span>) &#123;<span class="comment">// 如果要插入位置的前一个节点为头结点并且头结点的next 域为null，直接返回头结点。</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">Node current = head;<span class="comment">// 从头节点开始下移遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size &amp; current.next != <span class="keyword">null</span>; i++, current = current.next) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == index) &#123;</span><br><span class="line"><span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>查询--指定元素的位置(查找数据域存放的是element的节点位置)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findIndexByElement</span><span class="params">(T element)</span> </span>&#123;<span class="comment">// 2、查找 指定元素的位置(查找数据域存放的是element的节点位置)</span></span><br><span class="line">Node current = head;<span class="comment">// 从第一个节点开始查找对比数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size &amp; current.next != <span class="keyword">null</span>; i++, current = current.next) &#123;</span><br><span class="line"><span class="keyword">if</span> (current.data.equals(element))</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>插入--在指定位置之前插入一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment"> * 在java中有这么一条规则，声明在方法中的变量在使用时必须要初始化;全局变量如果不赋值会有默认值。</span></span><br><span class="line"><span class="comment"> * 例如：int size; 本例中 size 的初始值为 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, T element)</span> </span>&#123;<span class="comment">// 插入 在指定索引位置插入一个元素</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"线性表索引越界"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>)<span class="comment">// 如果链表为空，直接调用add方法</span></span><br><span class="line">&#123;</span><br><span class="line">add(element);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="comment">// 链表不为空时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>)<span class="comment">// 在链表头插入</span></span><br><span class="line">&#123;</span><br><span class="line">addAtHead(element);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node prev = findNodeByIndex(index - <span class="number">1</span>);<span class="comment">// 找到要插入位置的前一个节点</span></span><br><span class="line">prev.next = <span class="keyword">new</span> Node(element, prev.next);<span class="comment">// 插入后prev的next指向新节点，新节点的next指向原来prev的下一个节点</span></span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 尾插法 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T element)</span> </span>&#123;<span class="comment">// 插入 尾插法在每次在链表尾添加新节点</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">head = <span class="keyword">new</span> Node(element, <span class="keyword">null</span>);</span><br><span class="line">tail = head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(element, <span class="keyword">null</span>);</span><br><span class="line">tail.next = newNode;</span><br><span class="line">tail = newNode;</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 头插法 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(T element)</span> </span>&#123; <span class="comment">// 插入 头插法在链表头部加入新节点</span></span><br><span class="line"><span class="comment">// 在头部插入新节点，就是让新节点的next指向原来的head,让新节点作为链表的头节点</span></span><br><span class="line">head = <span class="keyword">new</span> Node(element, head);</span><br><span class="line"><span class="comment">// newNode.next = head;</span></span><br><span class="line"><span class="comment">// head = newNode;</span></span><br><span class="line"><span class="comment">// 如果插入之前是空链表</span></span><br><span class="line"><span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">tail = head;</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>删除--指定位置的节点 并返回删除节点中的元素值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">delete</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">Node deleteNode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"线性表索引越界"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>)<span class="comment">// 删除头节点</span></span><br><span class="line">&#123;</span><br><span class="line">deleteNode = head;</span><br><span class="line">head = head.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node prev = findNodeByIndex(index - <span class="number">1</span>);<span class="comment">// 获取要删除的节点的前一个节点</span></span><br><span class="line">deleteNode = prev.next;<span class="comment">// 要删除的节点就是prev的next指向的节点</span></span><br><span class="line">prev.next = deleteNode.next;<span class="comment">// 删除以后prev的next指向被删除节点之前所指向的next</span></span><br><span class="line"></span><br><span class="line">deleteNode.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> deleteNode.data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>删除--链表中最后一个元素  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> delete(size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>清除链表中所有的元素  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">head = <span class="keyword">null</span>;</span><br><span class="line">tail = <span class="keyword">null</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表的输出 重写toString方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"["</span>);<span class="comment">// 使用StringBuilder类</span></span><br><span class="line"><span class="keyword">for</span> (Node current = head; current != <span class="keyword">null</span>; current = current.next)<span class="comment">// 从head开始遍历</span></span><br><span class="line">&#123;</span><br><span class="line">sb.append(current.data.toString() + <span class="string">","</span>);<span class="comment">// 把节点的数据拼接起来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len = sb.length();</span><br><span class="line"><span class="keyword">return</span> sb.delete(len - <span class="number">1</span>, len).append(<span class="string">"]"</span>).toString();<span class="comment">// 把最后一个元素的，删除然后加上]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>判断链表是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>内部节点类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pengguozhen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年4月2日 下午12:10:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>// 节点类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> T data;<span class="comment">// 数据项</span></span><br><span class="line"><span class="keyword">private</span> Node next;<span class="comment">// 引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;<span class="comment">// 空参构造器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data, Node next)</span> </span>&#123;<span class="comment">// 初始化节点信息</span></span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dataStruct.singleLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">list.add(<span class="string">"aa"</span>);<span class="comment">// 链表头插入</span></span><br><span class="line">list.addAtHead(<span class="string">"cc"</span>);<span class="comment">// 链表尾插入</span></span><br><span class="line">list.insert(<span class="number">2</span>, <span class="string">"bb"</span>);<span class="comment">// 在指定任意位置插入</span></span><br><span class="line">System.out.println(list.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="4-2、静态链表"><a href="#4-2、静态链表" class="headerlink" title="4-2、静态链表"></a>4-2、静态链表</h4><ul><li>1、为什么使用静态链表？<br>为没有指针（引用）的编程语言提供链式存储结构实现的思想。</li></ul><h4 id="4-3、循环链表"><a href="#4-3、循环链表" class="headerlink" title="4-3、循环链表"></a>4-3、循环链表</h4><h4 id="4-4、双向链表"><a href="#4-4、双向链表" class="headerlink" title="4-4、双向链表"></a>4-4、双向链表</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/25/5c983b29bd6f0.jpg&quot; alt=&quot;线性表&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1、线性表定义&quot;&gt;&lt;a href=&quot;#1、线性表定义&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="数据结构" scheme="http://pengguozhen.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://pengguozhen.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>第2章-算法</title>
    <link href="http://pengguozhen.github.io/%E7%AC%AC2%E7%AB%A0-%E7%AE%97%E6%B3%95.html"/>
    <id>http://pengguozhen.github.io/第2章-算法.html</id>
    <published>2019-03-25T02:51:43.028Z</published>
    <updated>2019-03-24T18:50:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>摘自大话数据结构</p><h3 id="1、算法和数据结构的关系"><a href="#1、算法和数据结构的关系" class="headerlink" title="1、算法和数据结构的关系"></a>1、算法和数据结构的关系</h3><ul><li>重要的数据结构就那么几种、只有配合上算法才能学习到数据结构的用处。</li><li>算法：解决特定问题的步骤描述，在计算机中表现为指令的有限序列，每个指令代表一种操作。</li></ul><hr><h3 id="2、算法的特性"><a href="#2、算法的特性" class="headerlink" title="2、算法的特性"></a>2、算法的特性</h3><ul><li><p>输入、输出<br>算法具有零个或多个输入、至少有一个输出。算法一定有输出、如果没有输出。算法没有意义，便不需要算法。输出形式可以是打印，也可以是返回一个或多个值。</p></li><li><p>有穷性<br>指算法不会无穷循环，而没有结果。</p></li><li>确定性<br>执行的每一步都必须确定，相同的输入只能有唯一的输出结果。</li><li>可行性<br>每一步都是可以执行的。</li></ul><hr><h3 id="3、算法设计的要求"><a href="#3、算法设计的要求" class="headerlink" title="3、算法设计的要求"></a>3、算法设计的要求</h3><p>好的算法：</p><ul><li>正确性</li><li>可读性</li><li>健壮性</li><li>高效率和低存储量</li></ul><hr><h3 id="4、算法效率的度量"><a href="#4、算法效率的度量" class="headerlink" title="4、算法效率的度量"></a>4、算法效率的度量</h3><p>时间复杂度（大O表示法）–渐进时间复杂度</p><p>时间复杂度：O（f（n））表示随问题规模n 的增长速度。是一个增长率。即时间复杂度表示随着输入大小 n 的增长，算法时间的增长速度（程序执行次数函数的增长率）；</p><p>一般情况下 ，随着 n 的增大 O（n）增长最慢的为最优算法。</p><hr><h3 id="5、渐进时间复杂度的计算"><a href="#5、渐进时间复杂度的计算" class="headerlink" title="5、渐进时间复杂度的计算"></a>5、渐进时间复杂度的计算</h3><h4 id="5-1、由执行次数T-n-推导-大O-T-n"><a href="#5-1、由执行次数T-n-推导-大O-T-n" class="headerlink" title="5-1、由执行次数T(n) 推导 大O(T(n) )"></a>5-1、由执行次数T(n) 推导 大O(T(n) )</h4><p>推导方法：</p><ul><li>1、计算出算法执行次数的函数T(n)。</li><li><p>2、常数项不影响函数的增长速度，c 代表常数。<br>  T(n)=c 时，T(n)&gt;&gt;O(n)=O(1)，<br>  T(n) !=c 时，将常数项省略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一个 Hello, World 的例子中 T(n) = <span class="number">2</span>，所以我们说那个函数(算法)的时间复杂度为 O(<span class="number">1</span>)。</span><br><span class="line">T(n) = n + <span class="number">29</span>，此时时间复杂度为 O(n)。</span><br></pre></td></tr></table></figure></li><li><p>3、函数高次项对于函数的增长速度影像是最大的，n<sup>3</sup>的增长速度是远超 n<sup>2</sup> 的，同时 n<sup>2</sup> 的增长速度是远超 n 的。 同时因为要求的精度不高，所以我们直接忽略低此项。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如</span><br><span class="line">T(n) = n^<span class="number">3</span> + n^<span class="number">2</span> + <span class="number">29</span>，此时时间复杂度为 O(n^<span class="number">3</span>)。</span><br></pre></td></tr></table></figure><ul><li>4、因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如</span><br><span class="line">T(n) = <span class="number">3</span>n^<span class="number">3</span>，此时时间复杂度为 O(n^<span class="number">3</span>)。</span><br></pre></td></tr></table></figure><p><strong>综合起来：如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。为了方便描述，下文称此为 大O推导法。</strong></p><h4 id="5-2、由算法分析出执行次数-T-n"><a href="#5-2、由算法分析出执行次数-T-n" class="headerlink" title="5-2、由算法分析出执行次数 T(n)"></a>5-2、由算法分析出执行次数 T(n)</h4><p><strong>由执行次数推导出 大O 并不困难，困难的是如何从算法中分析出 执行次数 T（n）。</strong><br><strong>基本策略：由内到外、从最深层分析。如果遇到函数调用，要深入函数进行分析。</strong><br>四个便利法则：</p><ul><li>1、对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个循环的时间复杂度为 O(n×m)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;         <span class="comment">// 循环次数为 n</span></span><br><span class="line">        printf(<span class="string">"Hello, World!\n"</span>);      <span class="comment">// 循环体时间复杂度为 O(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2、对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c…，则这个循环的时间复杂度为 O(n×a×b×c…)。分析的时候应该由里向外分析这些循环。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;         <span class="comment">// 循环次数为 n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;       <span class="comment">// 循环次数为 n</span></span><br><span class="line">            printf(<span class="string">"Hello, World!\n"</span>);      <span class="comment">// 循环体时间复杂度为 O(1)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3、对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一部分时间复杂度为 O(n^2)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            printf(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二部分时间复杂度为 O(n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        printf(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>4、对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一条路径时间复杂度为 O(n^2)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                printf(<span class="string">"输入数据大于等于零\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 第二条路径时间复杂度为 O(n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            printf(<span class="string">"输入数据小于零\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3、常见的-大O-时间复杂度。"><a href="#5-3、常见的-大O-时间复杂度。" class="headerlink" title="5-3、常见的 大O 时间复杂度。"></a>5-3、常见的 大O 时间复杂度。</h4><ul><li>1、常数阶<br>O（1）</li><li>2、线性阶<br>O（n）</li><li>3、对数阶<br>O（logn）</li><li>4、平方阶<br>O（n<sup>2</sup>）</li></ul><hr><h3 id="6、最坏时间与平均情况"><a href="#6、最坏时间与平均情况" class="headerlink" title="6、最坏时间与平均情况"></a>6、最坏时间与平均情况</h3><ul><li>1、最坏时间：最坏情况运行时间的一种保证，我们提到的时间都是最坏情况的运行时间。</li><li>2、平均情况：平均运行时间是最有意义的，它是期望的运行时间。（很难通过分析得到，一般通过数据实验后估算出来。）</li></ul><p>总结：对算法的分析：1、根据运行计算平均运行时间。2、分析最坏时间。<br>一般算法分析时指的是最坏运行时间。</p><hr><h3 id="7、算法空间复杂度"><a href="#7、算法空间复杂度" class="headerlink" title="7、算法空间复杂度"></a>7、算法空间复杂度</h3><p>使用存储空间来换取运行时间</p><hr><h3 id="8、时间复杂度计算–练习"><a href="#8、时间复杂度计算–练习" class="headerlink" title="8、时间复杂度计算–练习"></a>8、时间复杂度计算–练习</h3><ul><li>1、基础题<br>求该方法的时间复杂度<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            printf(<span class="string">"Hello World\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>参考答案：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当 i = 0 时，内循环执行 n 次运算，当 i = 1 时，内循环执行 n - 1 次运算……当 i = n - 1 时，内循环执行 1 次运算。</span><br><span class="line">所以，执行次数 T(n) = n + (n - 1) + (n - 2)……+ 1 = n(n + 1) / 2 = n^2 / 2 + n / 2。</span><br><span class="line">根据上文说的 大O推导法 可以知道，此时时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">等差数列 </span><br><span class="line">通项公式：an=a1+(n-1)*d。</span><br><span class="line">求和公式：Sn=a1*n+[n*(n-1)*d]/2。</span><br></pre></td></tr></table></figure><ul><li>2、进阶题<br>求该方法的时间复杂度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">        printf(<span class="string">"%i\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考答案：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假设循环次数为 t，则循环条件满足 2^t <span class="tag">&lt; <span class="attr">n</span>。</span></span><br><span class="line"><span class="tag">可以得出，执行次数<span class="attr">t</span> = <span class="string">log(2)(n)，即</span> <span class="attr">T</span>(<span class="attr">n</span>) = <span class="string">log(2)(n)，可见时间复杂度为</span> <span class="attr">O</span>(<span class="attr">log</span>(<span class="attr">2</span>)(<span class="attr">n</span>))，即 <span class="attr">O</span>(<span class="attr">log</span> <span class="attr">n</span>)。</span></span><br></pre></td></tr></table></figure><ul><li>3、再次进阶<br>求该方法的时间复杂度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> aFunc(n - <span class="number">1</span>) + aFunc(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考答案：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">显然运行次数，T(0) = T(1) = 1，同时 T(n) = T(n - 1) + T(n - 2) + 1，这里的 1 是其中的加法算一次执行。</span><br><span class="line">显然 T(n) = T(n - 1) + T(n - 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n &gt;= 1 时 T(n) <span class="tag">&lt; (<span class="attr">5</span>/<span class="attr">3</span>)^<span class="attr">n</span>，同时当 <span class="attr">n</span> &gt;</span> 4 时 T(n) &gt;= (3/2)^n。</span><br><span class="line">所以该方法的时间复杂度可以表示为 O((5/3)^n)，简化后为 O(2^n)。</span><br><span class="line">可见这个方法所需的运行时间是以指数的速度增长的。如果大家感兴趣，可以试下分别用 1，10，100 的输入大小来测试下算法的运行时间，相信大家会感受到时间复杂度的无穷魅力。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;摘自大话数据结构&lt;/p&gt;
&lt;h3 id=&quot;1、算法和数据结构的关系&quot;&gt;&lt;a href=&quot;#1、算法和数据结构的关系&quot; class=&quot;headerlink&quot; title=&quot;1、算法和数据结构的关系&quot;&gt;&lt;/a&gt;1、算法和数据结构的关系&lt;/h3&gt;&lt;ul&gt;
      
    
    </summary>
    
      <category term="数据结构" scheme="http://pengguozhen.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://pengguozhen.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>第1章-数据结构绪论</title>
    <link href="http://pengguozhen.github.io/%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA.html"/>
    <id>http://pengguozhen.github.io/第1章-数据结构绪论.html</id>
    <published>2019-03-25T02:51:43.021Z</published>
    <updated>2019-03-24T18:50:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]<br><strong>该笔记摘抄于 《大话数据结构》<br>工作中所需要的栈、队列、链表、散列表等结构；查找、排序等算法在开发语言的工具包中都有完美实现，为什么还要学习数据结构弄懂其算法实现的原理？</strong></p><h3 id="1、数据结构起源"><a href="#1、数据结构起源" class="headerlink" title="1、数据结构起源"></a>1、数据结构起源</h3><ul><li><p>从计算机是用来进行数据计算的到现实中的问题需要一些科学有效的手段（表、树、图等数据结构）才能处理。</p></li><li><p>数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。<br>注：<code>这句话应该意思是，数据结构不是研究数值和数值计算的，而是研究对象（对象不止是数值，也可能是类对象或者其他），研究这些对象之间的关系（比如有什么共同点，比如顺序如何），以及操作（比如排序，插入等）</code>。</p></li><li><p>程序设计的实质是对确定的问题选择一种好的结构、加上设计一种好的算法。<strong>即程序设计=数据结构+算法。</strong></p></li></ul><hr><h3 id="2、基本概念和术语"><a href="#2、基本概念和术语" class="headerlink" title="2、基本概念和术语"></a>2、基本概念和术语</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据结构基本概念</span></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数据 – 程序的操作对象，用于描述客观事物</span></span><br><span class="line"><span class="comment">数据的特点：</span></span><br><span class="line"><span class="comment">可以输入到计算机</span></span><br><span class="line"><span class="comment">可以被计算机程序处理</span></span><br><span class="line"><span class="comment">数据是一个抽象的概念，将其进行分类后得到程序设计语言中的类型。如：int，float，char等等</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数据项：一个数据元素由若干数据项组成</span></span><br><span class="line"><span class="comment">数据元素：组成数据对象的基本单位</span></span><br><span class="line"><span class="comment">数据对象：性质相同的数据元素的集合（类似于数组一般）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数据元素之间不是独立的，存在特定的关系，这些关系即结构</span></span><br><span class="line"><span class="comment">数据结构指数据对象中数据元素之间的关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个结构体类型</span></span><br><span class="line">struct Teacher   <span class="comment">//一种数据类型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>    name[<span class="number">32</span>];<span class="comment">//数据项</span></span><br><span class="line">    <span class="keyword">char</span>    tile[<span class="number">32</span>];<span class="comment">//数据项</span></span><br><span class="line">    <span class="keyword">int</span>        age;<span class="comment">//数据项</span></span><br><span class="line">    <span class="keyword">char</span>    addr[<span class="number">128</span>];<span class="comment">//数据项</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    struct Teacher t1; <span class="comment">//数据元素</span></span><br><span class="line">    struct Teacher tArray[<span class="number">30</span>]; <span class="comment">//数据对象</span></span><br><span class="line">    memset(&amp;t1, <span class="number">0</span>, sizeof(t1));</span><br><span class="line"></span><br><span class="line">    strcpy(t1.name, <span class="string">"name"</span>); <span class="comment">//数据项</span></span><br><span class="line">    strcpy(t1.addr, <span class="string">"addr"</span>); <span class="comment">//数据项</span></span><br><span class="line">    strcpy(t1.tile, <span class="string">"addr"</span>); <span class="comment">//数据项</span></span><br><span class="line">    t1.age = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3、逻辑结构与物理结构"><a href="#3、逻辑结构与物理结构" class="headerlink" title="3、逻辑结构与物理结构"></a>3、逻辑结构与物理结构</h3><p>数据结构分为逻辑结构与物理结构</p><h4 id="3-1、逻辑结构"><a href="#3-1、逻辑结构" class="headerlink" title="3-1、逻辑结构"></a>3-1、逻辑结构</h4><p><strong>是指数据对象中数据元素之间的关系。</strong><br>分为四种。</p><pre><code>- 集合结构</code></pre><p><img src="https://www.github.com/pengguozhen/xiaoshujiangTC/raw/master/小书匠/1550666857719.png" alt="集合"></p><pre><code>- 线性结构</code></pre><p><img src="https://www.github.com/pengguozhen/xiaoshujiangTC/raw/master/小书匠/1550666942223.png" alt="线性结构"></p><pre><code>- 树</code></pre><p><img src="https://www.github.com/pengguozhen/xiaoshujiangTC/raw/master/小书匠/1550666972834.png" alt="树形结构"></p><pre><code>- 图</code></pre><p><img src="https://www.github.com/pengguozhen/xiaoshujiangTC/raw/master/小书匠/1550667025595.png" alt="图形结构"></p><h4 id="3-2、物理结构（存储结构）"><a href="#3-2、物理结构（存储结构）" class="headerlink" title="3-2、物理结构（存储结构）"></a>3-2、物理结构（存储结构）</h4><p>数据的逻辑结构在计算机中的存储形式。实际上是指如何把数据元素存储到计算机存储器中的</p><p><strong>数据元素的存储结构形式有两种</strong>：<br>    顺序存储结构：如数组<br>    链式存储结构：如链表，是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以不是连续的。</p><p>注：逻辑结构是面向问题的、物理结构是面向计算机的，基本的目标就是将数据及其逻辑关系存储到计算机的内存中。</p><h3 id="4、抽象数据类型"><a href="#4、抽象数据类型" class="headerlink" title="4、抽象数据类型"></a>4、抽象数据类型</h3><h4 id="4-1、数据类型"><a href="#4-1、数据类型" class="headerlink" title="4-1、数据类型"></a>4-1、数据类型</h4><p>计算机需要对数据进行分类，就分出来很多数据的类型。比如 int，float 等。</p><h4 id="4-2、抽象数据类型"><a href="#4-2、抽象数据类型" class="headerlink" title="4-2、抽象数据类型"></a>4-2、抽象数据类型</h4><ul><li>1、为什么需要抽象数据类型？<br>无论什么计算机、什么语言都会面临类似的整数运算，我们可以考虑将其抽象出来。抽象是抽取出事物具有的普遍性本质，是对事物的一个概括，是一种思考问题的方式。</li><li>2、定义<br>抽象数据类型（ADT）是指一个数学模型及定义在该模型上的一组操作。它仅取决于其逻辑特征，而与计算机内部如何表示和实现无关。比如刚才说得整型，各个计算机，不管大型机、小型机、PC、平板电脑甚至智能手机，都有“整型”类型，也需要整形运算，那么整型其实就是一个抽象数据类型。</li></ul><p>Java 中 接本数据类型、引用类型</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;br&gt;&lt;strong&gt;该笔记摘抄于 《大话数据结构》&lt;br&gt;工作中所需要的栈、队列、链表、散列表等结构；查找、排序等算法在开发语言的工具包中都有完美实现，为什么还要学习数据结构弄懂其算法实现的原理？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1、数据结构起源&quot;&gt;
      
    
    </summary>
    
      <category term="数据结构" scheme="http://pengguozhen.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://pengguozhen.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Hexo</title>
    <link href="http://pengguozhen.github.io/hello-world.html"/>
    <id>http://pengguozhen.github.io/hello-world.html</id>
    <published>2019-02-14T09:09:29.792Z</published>
    <updated>2019-03-25T04:12:46.423Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="Hexo" scheme="http://pengguozhen.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://pengguozhen.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
