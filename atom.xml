<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ta的笑很甜</title>
  
  <subtitle>你好</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-24T18:50:10.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ta 的笑很甜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第3章-线性表</title>
    <link href="http://yoursite.com/2019/03/25/%E7%AC%AC3%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/03/25/第3章-线性表/</id>
    <published>2019-03-25T02:51:43.036Z</published>
    <updated>2019-03-24T18:50:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p><img src="https://i.loli.net/2019/03/25/5c983b29bd6f0.jpg" alt="线性表"></p><h3 id="1、线性表定义"><a href="#1、线性表定义" class="headerlink" title="1、线性表定义"></a>1、线性表定义</h3><p>零个或多个数据元素的有限序列。</p><p>1、第一元素无前驱、最后一个元素无后继。<br>2、每个元素有且仅有一个前驱、后继。<br>3、相同数据元素。</p><hr><h3 id="2、线性表的抽象数据类型"><a href="#2、线性表的抽象数据类型" class="headerlink" title="2、线性表的抽象数据类型"></a>2、线性表的抽象数据类型</h3><hr><h3 id="3、线性表的顺序存储结构（数组实现）"><a href="#3、线性表的顺序存储结构（数组实现）" class="headerlink" title="3、线性表的顺序存储结构（数组实现）"></a>3、线性表的顺序存储结构（数组实现）</h3><p>线性表的两种物理存储结构（顺序存储结构、链式存储结构）</p><ul><li>1、顺序存储结构：指的是用一段地址连续的存储单元依次存储线性表的数据元素。</li><li><p>2、插入</p></li><li><p>3、删除</p></li></ul><p>优点：<br>可以快速存取表中的任意元素值。<br>无需为表示表中元素之间的逻辑关系而增加额外的存储空间。</p><p>缺点：<br>插入和删除操作需要移动大量元素；<br>线性表长度发生变化时，难以确定存储长度。<br>造成存储空间的碎片。</p><hr><h3 id="4、线性表的链式存储结构"><a href="#4、线性表的链式存储结构" class="headerlink" title="4、线性表的链式存储结构"></a>4、线性表的链式存储结构</h3><p>链式存储结构：</p><h4 id="4-1、单链表"><a href="#4-1、单链表" class="headerlink" title="4-1、单链表"></a>4-1、单链表</h4><ul><li>1、为什么使用单链表？<br>数组实现的顺序存储在插入和删除操作时需要移动大量的元素，且存储空间的容量难以确定。</li><li>2、单链表的插入、删除、修改、查找<br>实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dataStruct.singleLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线性表（链表）--节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pengguozhen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年4月2日 上午11:41:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node head;<span class="comment">// 指向链表头节点的引用变量</span></span><br><span class="line"><span class="keyword">private</span> Node tail;<span class="comment">// 指向链表尾节点的引用变量</span></span><br><span class="line"><span class="keyword">int</span> size;<span class="comment">// 链表中当前总节点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;<span class="comment">// 生成链表对象是一个空表</span></span><br><span class="line">head = <span class="keyword">null</span>;</span><br><span class="line">tail = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;<span class="comment">// 返回链表的长度</span></span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>查询--指定位置的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getElement</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="comment">// 1、获取指定位置的元素</span></span><br><span class="line"><span class="keyword">return</span> findNodeByIndex(index).data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findNodeByIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="comment">// 查找 指定索引位置的节点</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"线性表索引越界"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span> &amp;&amp; head.next == <span class="keyword">null</span>) &#123;<span class="comment">// 如果要插入位置的前一个节点为头结点并且头结点的next 域为null，直接返回头结点。</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">Node current = head;<span class="comment">// 从头节点开始下移遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size &amp; current.next != <span class="keyword">null</span>; i++, current = current.next) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == index) &#123;</span><br><span class="line"><span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>查询--指定元素的位置(查找数据域存放的是element的节点位置)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findIndexByElement</span><span class="params">(T element)</span> </span>&#123;<span class="comment">// 2、查找 指定元素的位置(查找数据域存放的是element的节点位置)</span></span><br><span class="line">Node current = head;<span class="comment">// 从第一个节点开始查找对比数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size &amp; current.next != <span class="keyword">null</span>; i++, current = current.next) &#123;</span><br><span class="line"><span class="keyword">if</span> (current.data.equals(element))</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>插入--在指定位置之前插入一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment"> * 在java中有这么一条规则，声明在方法中的变量在使用时必须要初始化;全局变量如果不赋值会有默认值。</span></span><br><span class="line"><span class="comment"> * 例如：int size; 本例中 size 的初始值为 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, T element)</span> </span>&#123;<span class="comment">// 插入 在指定索引位置插入一个元素</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"线性表索引越界"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>)<span class="comment">// 如果链表为空，直接调用add方法</span></span><br><span class="line">&#123;</span><br><span class="line">add(element);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="comment">// 链表不为空时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>)<span class="comment">// 在链表头插入</span></span><br><span class="line">&#123;</span><br><span class="line">addAtHead(element);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node prev = findNodeByIndex(index - <span class="number">1</span>);<span class="comment">// 找到要插入位置的前一个节点</span></span><br><span class="line">prev.next = <span class="keyword">new</span> Node(element, prev.next);<span class="comment">// 插入后prev的next指向新节点，新节点的next指向原来prev的下一个节点</span></span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 尾插法 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T element)</span> </span>&#123;<span class="comment">// 插入 尾插法在每次在链表尾添加新节点</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">head = <span class="keyword">new</span> Node(element, <span class="keyword">null</span>);</span><br><span class="line">tail = head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(element, <span class="keyword">null</span>);</span><br><span class="line">tail.next = newNode;</span><br><span class="line">tail = newNode;</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 头插法 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(T element)</span> </span>&#123; <span class="comment">// 插入 头插法在链表头部加入新节点</span></span><br><span class="line"><span class="comment">// 在头部插入新节点，就是让新节点的next指向原来的head,让新节点作为链表的头节点</span></span><br><span class="line">head = <span class="keyword">new</span> Node(element, head);</span><br><span class="line"><span class="comment">// newNode.next = head;</span></span><br><span class="line"><span class="comment">// head = newNode;</span></span><br><span class="line"><span class="comment">// 如果插入之前是空链表</span></span><br><span class="line"><span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">tail = head;</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>删除--指定位置的节点 并返回删除节点中的元素值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">delete</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">Node deleteNode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"线性表索引越界"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>)<span class="comment">// 删除头节点</span></span><br><span class="line">&#123;</span><br><span class="line">deleteNode = head;</span><br><span class="line">head = head.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node prev = findNodeByIndex(index - <span class="number">1</span>);<span class="comment">// 获取要删除的节点的前一个节点</span></span><br><span class="line">deleteNode = prev.next;<span class="comment">// 要删除的节点就是prev的next指向的节点</span></span><br><span class="line">prev.next = deleteNode.next;<span class="comment">// 删除以后prev的next指向被删除节点之前所指向的next</span></span><br><span class="line"></span><br><span class="line">deleteNode.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> deleteNode.data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>删除--链表中最后一个元素  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> delete(size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>清除链表中所有的元素  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">head = <span class="keyword">null</span>;</span><br><span class="line">tail = <span class="keyword">null</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表的输出 重写toString方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"["</span>);<span class="comment">// 使用StringBuilder类</span></span><br><span class="line"><span class="keyword">for</span> (Node current = head; current != <span class="keyword">null</span>; current = current.next)<span class="comment">// 从head开始遍历</span></span><br><span class="line">&#123;</span><br><span class="line">sb.append(current.data.toString() + <span class="string">","</span>);<span class="comment">// 把节点的数据拼接起来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len = sb.length();</span><br><span class="line"><span class="keyword">return</span> sb.delete(len - <span class="number">1</span>, len).append(<span class="string">"]"</span>).toString();<span class="comment">// 把最后一个元素的，删除然后加上]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>判断链表是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">TODO:</span>内部节点类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pengguozhen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年4月2日 下午12:10:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>// 节点类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> T data;<span class="comment">// 数据项</span></span><br><span class="line"><span class="keyword">private</span> Node next;<span class="comment">// 引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;<span class="comment">// 空参构造器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data, Node next)</span> </span>&#123;<span class="comment">// 初始化节点信息</span></span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dataStruct.singleLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">list.add(<span class="string">"aa"</span>);<span class="comment">// 链表头插入</span></span><br><span class="line">list.addAtHead(<span class="string">"cc"</span>);<span class="comment">// 链表尾插入</span></span><br><span class="line">list.insert(<span class="number">2</span>, <span class="string">"bb"</span>);<span class="comment">// 在指定任意位置插入</span></span><br><span class="line">System.out.println(list.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="4-2、静态链表"><a href="#4-2、静态链表" class="headerlink" title="4-2、静态链表"></a>4-2、静态链表</h4><ul><li>1、为什么使用静态链表？<br>为没有指针（引用）的编程语言提供链式存储结构实现的思想。</li></ul><h4 id="4-3、循环链表"><a href="#4-3、循环链表" class="headerlink" title="4-3、循环链表"></a>4-3、循环链表</h4><h4 id="4-4、双向链表"><a href="#4-4、双向链表" class="headerlink" title="4-4、双向链表"></a>4-4、双向链表</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/25/5c983b29bd6f0.jpg&quot; alt=&quot;线性表&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1、线性表定义&quot;&gt;&lt;a href=&quot;#1、线性表定义&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>第2章-算法</title>
    <link href="http://yoursite.com/2019/03/25/%E7%AC%AC2%E7%AB%A0-%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/25/第2章-算法/</id>
    <published>2019-03-25T02:51:43.028Z</published>
    <updated>2019-03-24T18:50:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>摘自大话数据结构</p><h3 id="1、算法和数据结构的关系"><a href="#1、算法和数据结构的关系" class="headerlink" title="1、算法和数据结构的关系"></a>1、算法和数据结构的关系</h3><ul><li>重要的数据结构就那么几种、只有配合上算法才能学习到数据结构的用处。</li><li>算法：解决特定问题的步骤描述，在计算机中表现为指令的有限序列，每个指令代表一种操作。</li></ul><hr><h3 id="2、算法的特性"><a href="#2、算法的特性" class="headerlink" title="2、算法的特性"></a>2、算法的特性</h3><ul><li><p>输入、输出<br>算法具有零个或多个输入、至少有一个输出。算法一定有输出、如果没有输出。算法没有意义，便不需要算法。输出形式可以是打印，也可以是返回一个或多个值。</p></li><li><p>有穷性<br>指算法不会无穷循环，而没有结果。</p></li><li>确定性<br>执行的每一步都必须确定，相同的输入只能有唯一的输出结果。</li><li>可行性<br>每一步都是可以执行的。</li></ul><hr><h3 id="3、算法设计的要求"><a href="#3、算法设计的要求" class="headerlink" title="3、算法设计的要求"></a>3、算法设计的要求</h3><p>好的算法：</p><ul><li>正确性</li><li>可读性</li><li>健壮性</li><li>高效率和低存储量</li></ul><hr><h3 id="4、算法效率的度量"><a href="#4、算法效率的度量" class="headerlink" title="4、算法效率的度量"></a>4、算法效率的度量</h3><p>时间复杂度（大O表示法）–渐进时间复杂度</p><p>时间复杂度：O（f（n））表示随问题规模n 的增长速度。是一个增长率。即时间复杂度表示随着输入大小 n 的增长，算法时间的增长速度（程序执行次数函数的增长率）；</p><p>一般情况下 ，随着 n 的增大 O（n）增长最慢的为最优算法。</p><hr><h3 id="5、渐进时间复杂度的计算"><a href="#5、渐进时间复杂度的计算" class="headerlink" title="5、渐进时间复杂度的计算"></a>5、渐进时间复杂度的计算</h3><h4 id="5-1、由执行次数T-n-推导-大O-T-n"><a href="#5-1、由执行次数T-n-推导-大O-T-n" class="headerlink" title="5-1、由执行次数T(n) 推导 大O(T(n) )"></a>5-1、由执行次数T(n) 推导 大O(T(n) )</h4><p>推导方法：</p><ul><li>1、计算出算法执行次数的函数T(n)。</li><li><p>2、常数项不影响函数的增长速度，c 代表常数。<br>  T(n)=c 时，T(n)&gt;&gt;O(n)=O(1)，<br>  T(n) !=c 时，将常数项省略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一个 Hello, World 的例子中 T(n) = <span class="number">2</span>，所以我们说那个函数(算法)的时间复杂度为 O(<span class="number">1</span>)。</span><br><span class="line">T(n) = n + <span class="number">29</span>，此时时间复杂度为 O(n)。</span><br></pre></td></tr></table></figure></li><li><p>3、函数高次项对于函数的增长速度影像是最大的，n<sup>3</sup>的增长速度是远超 n<sup>2</sup> 的，同时 n<sup>2</sup> 的增长速度是远超 n 的。 同时因为要求的精度不高，所以我们直接忽略低此项。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如</span><br><span class="line">T(n) = n^<span class="number">3</span> + n^<span class="number">2</span> + <span class="number">29</span>，此时时间复杂度为 O(n^<span class="number">3</span>)。</span><br></pre></td></tr></table></figure><ul><li>4、因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如</span><br><span class="line">T(n) = <span class="number">3</span>n^<span class="number">3</span>，此时时间复杂度为 O(n^<span class="number">3</span>)。</span><br></pre></td></tr></table></figure><p><strong>综合起来：如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。为了方便描述，下文称此为 大O推导法。</strong></p><h4 id="5-2、由算法分析出执行次数-T-n"><a href="#5-2、由算法分析出执行次数-T-n" class="headerlink" title="5-2、由算法分析出执行次数 T(n)"></a>5-2、由算法分析出执行次数 T(n)</h4><p><strong>由执行次数推导出 大O 并不困难，困难的是如何从算法中分析出 执行次数 T（n）。</strong><br><strong>基本策略：由内到外、从最深层分析。如果遇到函数调用，要深入函数进行分析。</strong><br>四个便利法则：</p><ul><li>1、对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个循环的时间复杂度为 O(n×m)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;         <span class="comment">// 循环次数为 n</span></span><br><span class="line">        printf(<span class="string">"Hello, World!\n"</span>);      <span class="comment">// 循环体时间复杂度为 O(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2、对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c…，则这个循环的时间复杂度为 O(n×a×b×c…)。分析的时候应该由里向外分析这些循环。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;         <span class="comment">// 循环次数为 n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;       <span class="comment">// 循环次数为 n</span></span><br><span class="line">            printf(<span class="string">"Hello, World!\n"</span>);      <span class="comment">// 循环体时间复杂度为 O(1)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3、对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一部分时间复杂度为 O(n^2)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            printf(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二部分时间复杂度为 O(n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        printf(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>4、对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一条路径时间复杂度为 O(n^2)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                printf(<span class="string">"输入数据大于等于零\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 第二条路径时间复杂度为 O(n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            printf(<span class="string">"输入数据小于零\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3、常见的-大O-时间复杂度。"><a href="#5-3、常见的-大O-时间复杂度。" class="headerlink" title="5-3、常见的 大O 时间复杂度。"></a>5-3、常见的 大O 时间复杂度。</h4><ul><li>1、常数阶<br>O（1）</li><li>2、线性阶<br>O（n）</li><li>3、对数阶<br>O（logn）</li><li>4、平方阶<br>O（n<sup>2</sup>）</li></ul><hr><h3 id="6、最坏时间与平均情况"><a href="#6、最坏时间与平均情况" class="headerlink" title="6、最坏时间与平均情况"></a>6、最坏时间与平均情况</h3><ul><li>1、最坏时间：最坏情况运行时间的一种保证，我们提到的时间都是最坏情况的运行时间。</li><li>2、平均情况：平均运行时间是最有意义的，它是期望的运行时间。（很难通过分析得到，一般通过数据实验后估算出来。）</li></ul><p>总结：对算法的分析：1、根据运行计算平均运行时间。2、分析最坏时间。<br>一般算法分析时指的是最坏运行时间。</p><hr><h3 id="7、算法空间复杂度"><a href="#7、算法空间复杂度" class="headerlink" title="7、算法空间复杂度"></a>7、算法空间复杂度</h3><p>使用存储空间来换取运行时间</p><hr><h3 id="8、时间复杂度计算–练习"><a href="#8、时间复杂度计算–练习" class="headerlink" title="8、时间复杂度计算–练习"></a>8、时间复杂度计算–练习</h3><ul><li>1、基础题<br>求该方法的时间复杂度<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            printf(<span class="string">"Hello World\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>参考答案：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当 i = 0 时，内循环执行 n 次运算，当 i = 1 时，内循环执行 n - 1 次运算……当 i = n - 1 时，内循环执行 1 次运算。</span><br><span class="line">所以，执行次数 T(n) = n + (n - 1) + (n - 2)……+ 1 = n(n + 1) / 2 = n^2 / 2 + n / 2。</span><br><span class="line">根据上文说的 大O推导法 可以知道，此时时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">等差数列 </span><br><span class="line">通项公式：an=a1+(n-1)*d。</span><br><span class="line">求和公式：Sn=a1*n+[n*(n-1)*d]/2。</span><br></pre></td></tr></table></figure><ul><li>2、进阶题<br>求该方法的时间复杂度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">        printf(<span class="string">"%i\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考答案：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假设循环次数为 t，则循环条件满足 2^t <span class="tag">&lt; <span class="attr">n</span>。</span></span><br><span class="line"><span class="tag">可以得出，执行次数<span class="attr">t</span> = <span class="string">log(2)(n)，即</span> <span class="attr">T</span>(<span class="attr">n</span>) = <span class="string">log(2)(n)，可见时间复杂度为</span> <span class="attr">O</span>(<span class="attr">log</span>(<span class="attr">2</span>)(<span class="attr">n</span>))，即 <span class="attr">O</span>(<span class="attr">log</span> <span class="attr">n</span>)。</span></span><br></pre></td></tr></table></figure><ul><li>3、再次进阶<br>求该方法的时间复杂度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">aFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> aFunc(n - <span class="number">1</span>) + aFunc(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考答案：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">显然运行次数，T(0) = T(1) = 1，同时 T(n) = T(n - 1) + T(n - 2) + 1，这里的 1 是其中的加法算一次执行。</span><br><span class="line">显然 T(n) = T(n - 1) + T(n - 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n &gt;= 1 时 T(n) <span class="tag">&lt; (<span class="attr">5</span>/<span class="attr">3</span>)^<span class="attr">n</span>，同时当 <span class="attr">n</span> &gt;</span> 4 时 T(n) &gt;= (3/2)^n。</span><br><span class="line">所以该方法的时间复杂度可以表示为 O((5/3)^n)，简化后为 O(2^n)。</span><br><span class="line">可见这个方法所需的运行时间是以指数的速度增长的。如果大家感兴趣，可以试下分别用 1，10，100 的输入大小来测试下算法的运行时间，相信大家会感受到时间复杂度的无穷魅力。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;摘自大话数据结构&lt;/p&gt;
&lt;h3 id=&quot;1、算法和数据结构的关系&quot;&gt;&lt;a href=&quot;#1、算法和数据结构的关系&quot; class=&quot;headerlink&quot; title=&quot;1、算法和数据结构的关系&quot;&gt;&lt;/a&gt;1、算法和数据结构的关系&lt;/h3&gt;&lt;ul&gt;
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>第1章-数据结构绪论</title>
    <link href="http://yoursite.com/2019/03/25/%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/"/>
    <id>http://yoursite.com/2019/03/25/第1章-数据结构绪论/</id>
    <published>2019-03-25T02:51:43.021Z</published>
    <updated>2019-03-24T18:50:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]<br><strong>该笔记摘抄于 《大话数据结构》<br>工作中所需要的栈、队列、链表、散列表等结构；查找、排序等算法在开发语言的工具包中都有完美实现，为什么还要学习数据结构弄懂其算法实现的原理？</strong></p><h3 id="1、数据结构起源"><a href="#1、数据结构起源" class="headerlink" title="1、数据结构起源"></a>1、数据结构起源</h3><ul><li><p>从计算机是用来进行数据计算的到现实中的问题需要一些科学有效的手段（表、树、图等数据结构）才能处理。</p></li><li><p>数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。<br>注：<code>这句话应该意思是，数据结构不是研究数值和数值计算的，而是研究对象（对象不止是数值，也可能是类对象或者其他），研究这些对象之间的关系（比如有什么共同点，比如顺序如何），以及操作（比如排序，插入等）</code>。</p></li><li><p>程序设计的实质是对确定的问题选择一种好的结构、加上设计一种好的算法。<strong>即程序设计=数据结构+算法。</strong></p></li></ul><hr><h3 id="2、基本概念和术语"><a href="#2、基本概念和术语" class="headerlink" title="2、基本概念和术语"></a>2、基本概念和术语</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据结构基本概念</span></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数据 – 程序的操作对象，用于描述客观事物</span></span><br><span class="line"><span class="comment">数据的特点：</span></span><br><span class="line"><span class="comment">可以输入到计算机</span></span><br><span class="line"><span class="comment">可以被计算机程序处理</span></span><br><span class="line"><span class="comment">数据是一个抽象的概念，将其进行分类后得到程序设计语言中的类型。如：int，float，char等等</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数据项：一个数据元素由若干数据项组成</span></span><br><span class="line"><span class="comment">数据元素：组成数据对象的基本单位</span></span><br><span class="line"><span class="comment">数据对象：性质相同的数据元素的集合（类似于数组一般）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数据元素之间不是独立的，存在特定的关系，这些关系即结构</span></span><br><span class="line"><span class="comment">数据结构指数据对象中数据元素之间的关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个结构体类型</span></span><br><span class="line">struct Teacher   <span class="comment">//一种数据类型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>    name[<span class="number">32</span>];<span class="comment">//数据项</span></span><br><span class="line">    <span class="keyword">char</span>    tile[<span class="number">32</span>];<span class="comment">//数据项</span></span><br><span class="line">    <span class="keyword">int</span>        age;<span class="comment">//数据项</span></span><br><span class="line">    <span class="keyword">char</span>    addr[<span class="number">128</span>];<span class="comment">//数据项</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    struct Teacher t1; <span class="comment">//数据元素</span></span><br><span class="line">    struct Teacher tArray[<span class="number">30</span>]; <span class="comment">//数据对象</span></span><br><span class="line">    memset(&amp;t1, <span class="number">0</span>, sizeof(t1));</span><br><span class="line"></span><br><span class="line">    strcpy(t1.name, <span class="string">"name"</span>); <span class="comment">//数据项</span></span><br><span class="line">    strcpy(t1.addr, <span class="string">"addr"</span>); <span class="comment">//数据项</span></span><br><span class="line">    strcpy(t1.tile, <span class="string">"addr"</span>); <span class="comment">//数据项</span></span><br><span class="line">    t1.age = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3、逻辑结构与物理结构"><a href="#3、逻辑结构与物理结构" class="headerlink" title="3、逻辑结构与物理结构"></a>3、逻辑结构与物理结构</h3><p>数据结构分为逻辑结构与物理结构</p><h4 id="3-1、逻辑结构"><a href="#3-1、逻辑结构" class="headerlink" title="3-1、逻辑结构"></a>3-1、逻辑结构</h4><p><strong>是指数据对象中数据元素之间的关系。</strong><br>分为四种。</p><pre><code>- 集合结构</code></pre><p><img src="https://www.github.com/pengguozhen/xiaoshujiangTC/raw/master/小书匠/1550666857719.png" alt="集合"></p><pre><code>- 线性结构</code></pre><p><img src="https://www.github.com/pengguozhen/xiaoshujiangTC/raw/master/小书匠/1550666942223.png" alt="线性结构"></p><pre><code>- 树</code></pre><p><img src="https://www.github.com/pengguozhen/xiaoshujiangTC/raw/master/小书匠/1550666972834.png" alt="树形结构"></p><pre><code>- 图</code></pre><p><img src="https://www.github.com/pengguozhen/xiaoshujiangTC/raw/master/小书匠/1550667025595.png" alt="图形结构"></p><h4 id="3-2、物理结构（存储结构）"><a href="#3-2、物理结构（存储结构）" class="headerlink" title="3-2、物理结构（存储结构）"></a>3-2、物理结构（存储结构）</h4><p>数据的逻辑结构在计算机中的存储形式。实际上是指如何把数据元素存储到计算机存储器中的</p><p><strong>数据元素的存储结构形式有两种</strong>：<br>    顺序存储结构：如数组<br>    链式存储结构：如链表，是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以不是连续的。</p><p>注：逻辑结构是面向问题的、物理结构是面向计算机的，基本的目标就是将数据及其逻辑关系存储到计算机的内存中。</p><h3 id="4、抽象数据类型"><a href="#4、抽象数据类型" class="headerlink" title="4、抽象数据类型"></a>4、抽象数据类型</h3><h4 id="4-1、数据类型"><a href="#4-1、数据类型" class="headerlink" title="4-1、数据类型"></a>4-1、数据类型</h4><p>计算机需要对数据进行分类，就分出来很多数据的类型。比如 int，float 等。</p><h4 id="4-2、抽象数据类型"><a href="#4-2、抽象数据类型" class="headerlink" title="4-2、抽象数据类型"></a>4-2、抽象数据类型</h4><ul><li>1、为什么需要抽象数据类型？<br>无论什么计算机、什么语言都会面临类似的整数运算，我们可以考虑将其抽象出来。抽象是抽取出事物具有的普遍性本质，是对事物的一个概括，是一种思考问题的方式。</li><li>2、定义<br>抽象数据类型（ADT）是指一个数学模型及定义在该模型上的一组操作。它仅取决于其逻辑特征，而与计算机内部如何表示和实现无关。比如刚才说得整型，各个计算机，不管大型机、小型机、PC、平板电脑甚至智能手机，都有“整型”类型，也需要整形运算，那么整型其实就是一个抽象数据类型。</li></ul><p>Java 中 接本数据类型、引用类型</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;br&gt;&lt;strong&gt;该笔记摘抄于 《大话数据结构》&lt;br&gt;工作中所需要的栈、队列、链表、散列表等结构；查找、排序等算法在开发语言的工具包中都有完美实现，为什么还要学习数据结构弄懂其算法实现的原理？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1、数据结构起源&quot;&gt;
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/02/14/hello-world/"/>
    <id>http://yoursite.com/2019/02/14/hello-world/</id>
    <published>2019-02-14T09:09:29.792Z</published>
    <updated>2019-02-13T07:58:05.679Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
